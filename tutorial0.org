#+OPTIONS: num:nil toc:nil
#+REVEAL_ROOT: file:///home/mdn/reveal.js-3.6.0
#+REVEAL_TRANS: slide
#+REVEAL_THEME: moon
#+Title: C++ a more in depth look into the language
#+Author: Martin Nestorov
#+Email: mdn150@aubg.edu / @mdnestorov

* Who am I?  
    - Martin Nestorov
    - Junior 2nd sem.
    - I like to type . . . a lot
    - email: mdn150@aubg.edu
    - Twitter: @mnestorov

* Why I chose to make these small tutorials
  - People seem to have some problems with the transition from C++ to FDS

  - I want to help!
  - I want to also learn!

#+BEGIN NOTES:
Over the course of the past several years I found a certain love for C++, but instead of just reading about the language and doing some small experiments with it,
I wanted to share my knowledge and to get better at it. Seeing how some students struggle with C++ in the beginning I decided that I can help out. That way not only
am I learning more in-depth concepts, but also I am making the lives of students easier (hopefully).
#+END NOTES

* What we are going to cover
  C++ as four sub-languages
  - C
  - OOP
  - STL
  - Templates

#+BEGIN NOTES:
C++ can be generally divided into four sub-categories or sub-languages.
It's a daunting task to go over all of these aspects and trying to teach everything, mainly because I can't! But instead I will try to cover some topics
that haven't been covered in depth in the C++ lectures and are somewhat elude to the students. Now our list seems like this
#+END NOTES
  - File structure
  - STL
  - Memory management
  - Templates
  - Inheritance
  - OOP

* File structure

#+BEGIN NOTES:
It has come to my attention that many people, while writing their homeworks, neglect the advantages of structuring their source files. This is most noticeable
when they are writing the first 3 FDS homeworks or their FDS project. Being able to properly manage your project into several files and to navigate between them
in an optimal and cohesive way will minimize your C++ suffering (and coding experience in general).

Now most of you already know this, but there are several great advantages to separating your .CXX files from your .HXX files. One such advantage is that, multiple people
can start working on several header files and instead of you waiting for them to be ready, you can continue with your work while they finish theirs. This separation of
implementation is important, because it minimizes dev time. But because you will be working mostly alone with your solutions, you will see another great adwhat steps does c++ go througt to runvantage of structuring
your files. And that is - it will be much easier for you to understand what you are doing and thus will minimize debugging and problem fixing time.

Since most of you are working with Visual Studio, here is how your structure looks like now:
Picture 1

And here is how you would want it to look.
Picture 2

Now I am not going to tell you how to add files and where ti put them, I will just show you how to properly implement header and source files and how to avoid collisions and
also how to stop writing those damn "xfz.header" files.

First things first.

What's the difference between headers and source?
Apart from the obvious name difference, header files are considered to be the definition part of the source code, while source (cpp) files are the implementation part.
Keeping them separate allows us to keep a clean directory and structure and to separate our logic from our implementation.
#+END NOTES

* How does compilation work?

  There are 4 steps of compiling C++ code:
  - Preprocessing
  - Compilation
  - Assembly
  - Linking

#+BEGIN NOTES:
When we are trying to run a piece of code (in our case C++), the computer goes through several steps before we see the output, or the errors. 

The first part is the so called preprocessing step, where the preprocessor handles the `preprocessor` directives. These are the `#include`, `#define`, `#if`, `#ifndef`, etc. pieces of code we put on the top
of our files. At this stage, one file at a time, each of these directives are replaces with their respective pieces of code from other files (they are usually declarations). That is why when we have
multiple source files, we include only the header files, because they only show us the declarations and not the definitions (thus we minimize time in this step). So after the
directives have been replaced with the respective file contents or snippets of files (depending in the `#if` `#ifndef` and `#ifdef` and the macro #define keywords) we get at the end "pure C++" code.
The preprocessor also adds line numbers so that the further steps can identify where the inserted code came from.
As an example, if we write `#include <iostream>` we actually just insert the contents from the `iostream` file on the top of our main source file (again we must remember that most of
the time, we are just including declarations).
So at the end of all of this copying, we get a temporary file that is just C/C++ code. It's indicated by the `*.i` or `*.ii` file extension, meaning that this file is just C/C++ code and must not be preprocessed.
We must note that the preprocessor is agnostic to the C++ syntax, that is why for instance, in Visual Studio we have the `#pragma` directive that tries to do the `#ifndef` directive work, but that's just a lie. 
We have to be careful where and how we put our includes.
Tip: one of the things we want to do while writing C++ code is to minimize our reliance on the preprocessor. That is, if we are `#define`-ning macros as constants so that we can use them throughout our program, we might
encounter strange errors, because these directives may be treated as not part of the language. As an example, if we write `#define A_RATIO 1.18` the preprocessor might skip the name and just include the double 1.18. Then
if we get, or when we get, an error referring to 1.18, we might not know it's because it was a macro define lost from the preprocessor. Instead we can just use `const`s as such: `const double ARatio = 1.18;` Now we know
that the compiler will see this variable and we won't bang our head against the wall with unnecessary errors.

After we have our "pure C++" code (ending with the *.i/*.ii) suffix, we are ready to move to the next step - Compilation.
