<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Templates and STL</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../css/reveal.css"/>

<link rel="stylesheet" href="../css/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../css/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Templates and STL</h1><h2 class="author">Martin Nestorov</h2>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-orgdf18390">Generics in C++</a></li>
<li><a href="#/slide-org8901d45">Template programming</a></li>
<li><a href="#/slide-org0c4701d">The STL</a></li>
<li><a href="#/slide-org265df74">Exercises</a></li>
<li><a href="#/slide-orgbd8bf1a">Resources</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-orgdf18390">
<h2 id="orgdf18390">Generics in C++</h2>
<aside class="notes">
<p>
One of the things that C++ manages to do very well is to provide generic programming to us. The <b>STL</b> is one of the best functionalities that have been ever made in the language. <code>Vectors</code>, <code>lists</code>, <code>for_each</code>, and many many more containers are available to use to shorten our code, make it more understandable, and make it independent from types! The C++ template mechanism was also Turing complete (you can compute any computable value with it), which led to template meta programming. With this tutorial we will go over what templates can do, how we can use them (and when) and then we will concentrate on the STL.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org8901d45">
<h2 id="org8901d45">Template programming</h2>
<ul>
<li class="fragment roll-in">Templates</li>
<li class="fragment roll-in">Compile-time polymorphism</li>
<li class="fragment roll-in"><code>typename</code> or <code>class</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org35e4e6d">
<h3 id="org35e4e6d">Templates</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #d26937;">T</span> <span style="color: #599cab;">GetMax</span> <span style="color: #99d1ce;">(</span><span style="color: #d26937;">T</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">T</span> <span style="color: #599cab;">b</span><span style="color: #99d1ce;">)</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e;">(</span>a &gt; b ? a : b<span style="color: #33859e;">)</span>;
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span><span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">doProcessing</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">T</span>&amp; <span style="color: #599cab;">w</span><span style="color: #99d1ce;">)</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>w.size<span style="color: #d26937;">()</span> &gt; <span style="color: #33859e; font-weight: bold;">10</span> &amp;&amp; w != someObject<span style="color: #33859e;">)</span>
<span class="linenr">4: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">5: </span>        <span style="color: #d26937;">T</span> <span style="color: #599cab;">temp</span><span style="color: #d26937;">(</span>w<span style="color: #d26937;">)</span>;
<span class="linenr">6: </span>        temp.normalize<span style="color: #d26937;">()</span>;
<span class="linenr">7: </span>        temp.swap<span style="color: #d26937;">(</span>w<span style="color: #d26937;">)</span>;
<span class="linenr">8: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">9: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
There is a good chance that you will not be dealing with a lot of template code in C++ and that's okay. But it is still a good idea to be able to understand and write templates in C++. In fact, compared to Java or C#, C++ has more flexibility when it comes to writing such code (although this isn't always good). So what are templates? They are just something that can be substituted for something else during run-time. It allows us to greatly reuse code, abstracts us from dealing with types, but at the same time, it makes executables larger, and sometimes slower.
</p>

<p>
Okay so let's look at a template.
</p>

<p>
In the first piece of code, we have a template function that returns the larger of the two types. These types can be literally anything - they can by <code>int</code>, <code>double</code>, <code>char</code>, <code>someObject</code>, etc. As long as the type <code>T</code> has an implementation of <code>&gt;</code>, this will compile and this will run. In the second example we can see even clearer when we say that some template must support something. We are passing <code>w</code> by reference (so maybe it's an object). The parameter uses the <code>size()</code>, <code>normalize()</code>, and <code>swap()</code> functions (okay, it's an object). We also have the operator <code>!=</code> in use, and we also have a copy constructor. If we were to just substitute <code>T&amp; w</code> with <code>SpecificObject&amp; w</code>, we would not worry that <code>w</code> supports all of these functionalities, because we have explicitly stated what we are passing. But since we are using a template, we are <b>expecting</b> that <code>T</code> supports them. This is the meaning of an <b>implicit</b> interface. Writing templates means that we are dealing with implicit interfaces in the first place.
</p>

<p>
It's okay not to stress it that much when we are writing generic functions, which are designed to handle build-in types (such as <code>int</code> and <code>double</code>), but when we are working with user defined types, we have to be careful what the function is actually doing, and does it support the interface.
</p>

<p>
One thing to consider when dealing with implicit interfaces is that it's not important whether what the function we are using does what it has to do. This means that when we call <code>w.size()</code>, this might return some integer indicating the size of <code>w</code>, but it might not, it might not ever return a number! As long as the function call returns something that can be used with the <code>&gt;</code> operator, this code will compile! Maybe the function is defined in some base class where it is inherited, everything is valid as long as the next operator runs. The same is true for the <code>!=</code> operator. It can take a type <code>X</code> and a type <code>Y</code> and as long as <b><b>T</b></b> is convertable to <b><b>X</b></b> and <b><b>someObject</b></b> to <b><b>Y</b></b>, the statement will run. So we can say that implicit interfaces are just a set of valid expressions, which impose some constraints. So the constraint of the whole expression doesn't really matter of the types used in it as long as the final yielded result is compatible with <code>bool</code>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org3bc3ddd">
<h3 id="org3bc3ddd">Compile-time polymoprhism</h3>
<ul>
<li>In old C++ - function overloading</li>
<li>In template C++ - almost the same, but with unknown types</li>

</ul>

<aside class="notes">
<p>
Okay we get what an implicit interface is. But next to this there is another very important aspect of templates and that is <b><b>compile-time polymorphism</b></b>. Sounds scary, it's not. You've most probably have used this and in the world of normal functions this is also known as <b>function overloading</b>. There is a debate whether this should also be referred to as polymorphism, but it is what it is. Now where do templates come along in this? Much similar to overloading, when we are declaring multiple templates, we can specify at some point in our code what the template will be (i.e. what type). Since we are telling the compiler the type, during compile time, the type of the template used will be mapped in the object file and will resolve at that time. In contrast to dynamic binding, where during runtime it is decided which function is called, the compiler knows based on the types we use what to substituted for when a function is called.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org14715ca">
<h4 id="org14715ca">The Mixin idiom</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MixinClass</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">T</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">code</span>
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MixinBase</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span> :
<span class="linenr"> 3: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">f</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span> <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"HELLO"</span> &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl; <span style="color: #33859e;">}</span>;
<span class="linenr"> 4: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Mixin</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">T</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">10: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">f</span><span style="color: #33859e;">()</span> 
<span class="linenr">11: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">12: </span>        <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"call from mixin f method"</span> &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">13: </span>        <span style="color: #33859e; font-weight: bold;">T</span>::f<span style="color: #d26937;">()</span>;
<span class="linenr">14: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">15: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">16: </span>
<span class="linenr">17: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">18: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Mixin2</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">T</span>
<span class="linenr">19: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">20: </span><span style="color: #195466; font-weight: bold;">public</span> :
<span class="linenr">21: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">g</span><span style="color: #33859e;">()</span> 
<span class="linenr">22: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">23: </span>        <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"call from mixin2 g method"</span> &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">24: </span>        <span style="color: #33859e; font-weight: bold;">T</span>::f<span style="color: #d26937;">()</span>;
<span class="linenr">25: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">26: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">27: </span>
<span class="linenr">28: </span><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span><span style="color: #99d1ce;">()</span>
<span class="linenr">29: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">30: </span>    <span style="color: #d26937;">Mixin2</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">Mixin</span> <span style="color: #d26937;">&lt;</span><span style="color: #d26937;">MixinBase</span><span style="color: #d26937;">&gt;</span> <span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">mix</span>;
<span class="linenr">31: </span>    mix.g<span style="color: #33859e;">()</span>;
<span class="linenr">32: </span>
<span class="linenr">33: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr">34: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Now that we know about implicit interfaces and the fact that template must support the interface in the method body, we can talk about one of the most useful concepts in C++, which is the <b><b>Mixin</b></b>.
</p>

<p>
Mixins are a great way to reuse code and overcome come implementational problems that <b>composition and delegation</b> and <b>inheritance-based-reuse</b> bring. From a syntactic point of view this is a <code>mixin</code>. This is a template class that inherits from the type of the template. Simple enough, but why is this important? Well, mixins are like putting all of the reusable code in the derived class (instead of the conventional way of putting the reusable code in the base class). Basically, mixins are small classes that implement a very specific functionality for another class, through a specified class that provides the specific features the functionality needs.More abstractly speaking, mixins are small fragments of a class that are intended to be composed with other classes. Let's say we are trying to model something, we start writing our code and implement all of our classes and hierarchies normally as we know, at which point we have several classes, orthogonal to each other (<code>decoupled</code>). We might have some common interface between those classes and at that point we inherit from that interface. We writing our explicit implementation of what we have inherited. Everything seems fine, but the problem with this design is that we do not have an easy way to combine our modeled classes with each other. This is where mixins come in play. They allow us to create primitive classes that are used as building blocks. We can plug in any class we want into them and get the functionality we desire, while keeping the classes orthogonal to each other.
</p>

<p>
From the example we can see how a mixin can be used to <b>"plug-in"</b> classes together and get some functionality out of them. The code works like this - we create an object that is combined from a base class that just outputs a string and two other mixin classes. At this point we can see how we are usgin multiple inheritance, i.e. inhereting from the template class. We can simply traverse the output of the program and see how using the <code>g()</code> method we get the output of the <code>Mixin2</code> class, which, then using the template <code>T</code> calls the <code>f()</code> method. Since that <code>T</code> is of type <code>Mixin</code>, we go to that class and execute <code>f()</code>. In that method call we also have another <code>f()</code>, but this time the <code>T</code> of the template is of type <code>MixinBase</code>. Sort of a long traversal, but nothing too complicated. This is how we use mixins in the simplest form. Now let's look at a more practical example.
</p>

<p>
Remember, don't use mixins unless your programs needs them. Although their versatility, they bring complexity to the whole structure.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org7dfa3f7">
<h3 id="org7dfa3f7"><code>typename</code> or <code>class</code></h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span> <span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Thing</span>;
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span> <span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">OtherThing</span>;
</pre>
</div>

<aside class="notes">
<p>
One of the things you might have noticed until now is that, in all of the examples we have seen so far, the keyword <code>typename</code> has been used. Now let's talk about the differnece between why and when to use <code>typename</code> and when to use <code>class</code> when declaring templates and so on. In the example we have, the difference between declaring a template parameter with <code>class</code> or <code>typename</code> is <b>nothing</b>. But there is a logical difference. Some people like the <b>class</b> because it's less typing, others like <b>typename</b>, because it indicates that the passed parameter doesn't need to be a class type. You can choose to use <b>typename</b> when any type is allowed and to use <b>class</b> when a user-defined type is passed. So what's the big fuss, when both are considered equal by C++. Well, C++ does find a difference between the two, and sometimes we do have to use only typename, and sometimes we have to use class only. Here are the edge cases.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Demonstration</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">4: </span>    <span style="color: #33859e; font-weight: bold;">T</span>::<span style="color: #d26937;">A</span> *<span style="color: #599cab;">aObj</span>; <span style="color: #245361;">// </span><span style="color: #245361;">oops! error!</span>
<span class="linenr">5: </span>    <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #33859e; font-weight: bold;">T</span>::<span style="color: #d26937;">A</span> *<span style="color: #599cab;">aObg</span>; <span style="color: #245361;">// </span><span style="color: #245361;">correct!</span>
<span class="linenr">6: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
For <b>typename</b> - During the olden days of standardization of the language, the C++ people found a problem when trying to make declarative statements in a templated class. That is, when we have a template class, in which we use the template to access another nested template, we would get an error. The problem was that when we are accessing nested templates, C++ doesn't recognize we are doing that and it thinks that we are actually multiplying object <code>A</code> by <code>aObj</code>. In order to fix this, we just have to tell the compiler that we want to declare something (and not break everything). This is the situation when we use <b>typename</b>, to indicate a declerative statement.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #33859e;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span>, <span style="color: #195466; font-weight: bold;">typename</span><span style="color: #33859e;">&gt;</span> <span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Container</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Type</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MyContainer</span>: <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">Container</span><span style="color: #99d1ce;">&lt;</span><span style="color: #d26937;">Type</span>, <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">allocator</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">Type</span><span style="color: #33859e;">&gt;</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #245361;">//</span><span style="color: #245361;">code</span>
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
For <b>class</b> - The other edge case is when we have a <b>template template parameter</b> declaration. When we are declaring a template template, we are limited to use the <code>class</code> keyword in order to tell the compiler that the template parameter is <code>Container</code>. If we are to write <code>template Container</code>, then we would get a compiler error. This is the way it is&#x2026; almost. Form C++ 17 this is no longer a problem since writing either <code>class</code> or <code>template</code> will yield the same valid result. If you are using C++ 14 or 11, keep in mind for this restriction.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0c4701d">
<h2 id="org0c4701d">The STL</h2>
<ul>
<li class="fragment roll-in">Containers</li>
<li class="fragment roll-in">Vectors, strings, maps, and sets</li>
<li class="fragment roll-in">Iterators</li>
<li class="fragment roll-in">Lambda expressions</li>

</ul>

<aside class="notes">
<p>
Now that we have a good grasp of what templates are, we can concentrate on one of the best things in C++ - the STL (<b>The Standard template Library</b>). The STL is an arrangement of containers that allows us to manipulate our data in easy and intuitive ways. Although there is a whole other book specifically for how to use the STL in an effective manner. We can't cover all of those items here, so we will just look over some of the most useful things (or at least to my perception). Nevertheless, after this section you should feel comfortable to dive deep into the world of STL, it's both fun and it makes C++ much much easier (if done right).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgff9f721">
<h3 id="orgff9f721">Containers</h3>
<ul>
<li class="fragment roll-in">Sequence containers</li>
<li class="fragment roll-in">Associative containers</li>
<li class="fragment roll-in">Unordered associative containers</li>
<li class="fragment roll-in">Container adapters</li>

</ul>

<aside class="notes">
<p>
The containers of C++ are the fundamentals of how the STL works. These are collections of the same object, where they hold/own the elements in them. Containers are very flexible due to their <b>template</b> implementation. We have three general forms of containers. <b>Sequence</b> containers  control the order in which elements are stored (<code>vector</code>, <code>array</code>, <code>list</code>, <code>deque</code>). The order in which we insert our data is the order we are going to get it. <b>Associative</b> containers control the position of the elements (<code>set</code>, <code>map</code>, <code>multimap</code>, <code>multiset</code>). In this case the elements are not inserted based to the position they have, but on their value. Finally we have <b>Unordered</b> associative containers, which holds the position of the elements through a hash to each element (<code>unordered_set</code>, <code>unordered_map</code>). There are also the so called <b>container adapters</b>, which are not full blown containers, but are used to hold some other container in them (<code>stack</code>, <code>queue</code>, <code>priority_queue</code>). These adapters hold the other container and through the adapter do we access the elements. Of course there are many more types of containers, but these are the basics and should get you going.
</p>

</aside>

</section>
<section >

<p>
To <code>size()</code> or to <code>empty()</code>?
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">if</span> <span style="color: #99d1ce;">(</span>cont.size<span style="color: #33859e;">()</span> == <span style="color: #33859e; font-weight: bold;">0</span><span style="color: #99d1ce;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">same lines</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">if</span> <span style="color: #99d1ce;">(</span>cont.empty<span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>     <span style="color: #245361;">// </span><span style="color: #245361;">of code</span>
</pre>
</div>

<aside class="notes">
<p>
Now let's talk about some implementations we can use with containers, which are going to make our lives easier. One this is that we will often, when using containers, see if it's empty or not. We have to ways of doing that, wither through <code>cont.size() == 0</code> or <code>cont.empty()</code>. Which one is the better way? The latter is. Because, when we are calling the <code>size()</code> function, we are telling the container to traverse through the whole construct to see what is the actual size. The problem here is that, size cannot be implemented to return in constant time. Since new elements have to change the size of the container, this puts the implementer in a conundrum, how to make size return in constant time, and different container implementations make different choices. To overcome this, just use <code>empty()</code>, because this method will always return in constant time.
</p>

</aside>

</section>
<section >

<p>
Prefer range member functions to for loops
</p>

<div class="org-src-container">

<pre  class="fragment (roll-in)"><span class="linenr">0: </span>v1.assign<span style="color: #99d1ce;">(</span>v2.begin<span style="color: #33859e;">()</span> + v2.size<span style="color: #33859e;">()</span> / <span style="color: #33859e; font-weight: bold;">2</span>, v2.end<span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="fragment (roll-in)"><span class="linenr">0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">vector</span><span style="color: #99d1ce;">&lt;</span>Obj<span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">v1</span>,<span style="color: #599cab;">v2</span>;
<span class="linenr">1: </span>
<span class="linenr">2: </span><span style="color: #245361;">// </span><span style="color: #245361;">code thingies</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span>v1.clear<span style="color: #99d1ce;">()</span>;
<span class="linenr">5: </span><span style="color: #195466; font-weight: bold;">for</span> <span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">auto</span> &amp;<span style="color: #599cab;">v</span> : v2.begin<span style="color: #33859e;">()</span> + v2.size<span style="color: #33859e;">()</span> / <span style="color: #33859e; font-weight: bold;">2</span><span style="color: #99d1ce;">)</span>
<span class="linenr">6: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">7: </span>    v1.push_back<span style="color: #33859e;">(</span>v<span style="color: #33859e;">)</span>;
<span class="linenr">8: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
One of the best things about the containers is that they come with built in awesome member functions that will do a lot of work for us with the added benefit of making the code base clearer and smaller. The problem is that we don't always know that the containers we are using have such awesome functions that come along with them. Specifically, if you like writing for loops for containers, then maybe it's time to look over what that specific data structure can do for you. Let's take this example. We have two vectors <code>v1</code> and <code>v2</code>. We want to make <code>v1</code> be the same as the second half of <code>v2</code>, what's the easiest way? Answer : <code>v1.assign(v2.begin() + v2.size() / 2, v2.end());</code>. Here we are achieving a few things. First we are making our code much smaller and clearer, combining everything we want into just a few characters. Second, we are not using some form of looping logic we wrote, because look at how we would have to write it if we were to make it ourselves. The best way to overcome such problems is to ask yourself before you try to use a loop - "What do I want to achieve with this loop and can I use something from the containers method set?". This will both decrease the code you write and will increase your knowledge of the STL, because most of these range based members are in the majority of containers.
</p>

</aside>

</section>
<section >

<p>
Delete <code>new</code> ed objects in containers
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">awesomeFunction</span><span style="color: #99d1ce;">()</span>
<span class="linenr">1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">2: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">vector</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">Obj</span>*<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">v_obj</span>;
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">for</span> <span style="color: #33859e;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = <span style="color: #33859e; font-weight: bold;">0</span>; i &lt; <span style="color: #33859e; font-weight: bold;">42</span>; i++<span style="color: #33859e;">)</span>
<span class="linenr">4: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">5: </span>        v_obj.push_back<span style="color: #d26937;">(</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">Obj</span><span style="color: #d26937;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">ticking timebomb</span>
<span class="linenr">6: </span>        <span style="color: #245361;">// </span><span style="color: #245361;">more code...</span>
<span class="linenr">7: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">8: </span><span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">memory leak happens here!</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">awesomeFunction</span><span style="color: #99d1ce;">()</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">.. same code as before</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>    <span style="color: #195466; font-weight: bold;">for</span> <span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">auto</span> &amp;<span style="color: #599cab;">v</span> : v_obj<span style="color: #33859e;">)</span>
<span class="linenr"> 5: </span>    <span style="color: #33859e;">{</span>
<span class="linenr"> 6: </span>        <span style="color: #195466; font-weight: bold;">delete</span> v;
<span class="linenr"> 7: </span>    <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">no memory leaks!</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">}</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #245361;">// </span><span style="color: #245361;">or</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">manageFlights</span><span style="color: #99d1ce;">()</span>
<span class="linenr">13: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">14: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">vector</span><span style="color: #33859e;">&lt;</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">unique_ptr</span><span style="color: #d26937;">&lt;</span>Plane<span style="color: #d26937;">&gt;</span> <span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">airport</span>;
<span class="linenr">15: </span>    <span style="color: #195466; font-weight: bold;">for</span> <span style="color: #33859e;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = <span style="color: #33859e; font-weight: bold;">0</span>; i &lt; <span style="color: #33859e; font-weight: bold;">10</span>; i++<span style="color: #33859e;">)</span>
<span class="linenr">16: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">17: </span>        airport.push_back<span style="color: #d26937;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::make_unique<span style="color: #888ca6;">&lt;</span>Plane<span style="color: #888ca6;">&gt;()</span><span style="color: #d26937;">)</span>;
<span class="linenr">18: </span>        airport.at<span style="color: #d26937;">(</span>i<span style="color: #d26937;">)</span>-&gt;fuel = <span style="color: #33859e; font-weight: bold;">4000</span>;
<span class="linenr">19: </span>        <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; airport.at<span style="color: #d26937;">(</span>i<span style="color: #d26937;">)</span>-&gt;fuel &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">20: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">21: </span><span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">No memory leaks!</span>
</pre>
</div>

<aside class="notes">
<p>
More often than not, you will be creating objects on the <code>heap</code> regularly and you will be using your containers as usual. So you will, naturally, combine both your new objects in the containers, but there is a small problem here. Containers by themselves do handle their own memory and they do delete themselves once their are of no need, but that doesn't mean that they will handle data on the <code>heap</code>. That's why if you have collections that are filled with such objects, you have to manually delete them. Now there is some wiggle room and that is that we can use <b>smart pointer</b> to our advantage and not worry about memory allocation and deletion. Now there is some clearing up to do. Before <b>C++ 11</b>, we had only one type of smart pointer and that is the <code>auto_ptr</code>. Since then <code>auto_ptr</code> isn't all that smart and caused a lot of troubles. One of which is the fact that we couldn't use it with any container. It was so bad that the C++ standards committee actually forced a rule where the compiler will not allow the program to have an <code>auto_ptr</code> in any container. But after C++ 11, things changed and we have <code>uniquq_ptr</code>, which should be your default <b>goto</b> when dealing with smart pointers. Let's get back to our example. Now we have to general approaches to fix our code leak. One is to manually go over the container with a <code>for loop</code> and delete by hand what we have created. Or the other is to use the magical <code>unique_ptr</code> and let that handle everything. Generally, use the smart pointers that are at our disposal.
</p>

</aside>

</section>
<section >

<p>
How to <b><b>really</b></b> erase things from a container
</p>

<ul>
<li>dependent on specific container</li>
<li>erase-remove idiom</li>
<li>normal remove</li>

</ul>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #245361;">// </span><span style="color: #245361;">removes all elements with the value 5 from a vector</span>
<span class="linenr">1: </span>v.erase<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::remove<span style="color: #33859e;">(</span>v.begin<span style="color: #d26937;">()</span>, v.end<span style="color: #d26937;">()</span>, <span style="color: #33859e; font-weight: bold;">5</span><span style="color: #33859e;">)</span>, v.end<span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #245361;">// </span><span style="color: #245361;">remove all elements with the value 42 from a list</span>
<span class="linenr">4: </span>c.remove<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">42</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #245361;">// </span><span style="color: #245361;">remove all elements with the value 68.9 from a map</span>
<span class="linenr">7: </span>m.erase<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">68.9</span><span style="color: #99d1ce;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Why do we need to know that there are 3 types of containers? Many reasons, but one of them is, because this will help us utilize the removal of items in an efficient manner. Every type of container has it's own way to remove elements and there is not general approach, but here are some guidelines. If you have a <code>string</code>, <code>vector</code>, or a <code>deque</code> (i.e. a sequential container), then use the <b>erase-remove-idiom</b>. What is the <b>erase-remove-idiom</b>? It's a popular technique for these types of containers where we call the two methods <code>erase()</code> and <code>remove()</code> to delete something. We can see from the example how to use it. <b>Note</b>: that in order to use <code>remove()</code> we must include the <code>&lt;algorithm&gt;</code> library in our code, since the sequential containers don't have such a method.
</p>

<p>
For <b>lists</b>, the situation is different. Although the above will work, there is a better way. You should just use the built in <code>remove</code> method in the list class. In general here is another <b>rule as a bonus</b>: prefer the class specific methods of containers to the same methods in the <code>algorithm</code> file. This is much more efficient.
</p>

<p>
For <b>associative containers</b> however things are different. We should never use anything that has the word <b>remove</b> as a way to delete elements from the container. This will probably lead to data corruption and in-proper element removal. Also such container don't even have a method called <code>remove()</code>. Instead we should use the <code>erase()</code> method and it will work just fine.
</p>

<p>
In general the <b>erase-remove idiom</b> should work for most things, but with little experimenting you will get the hang of things.
</p>

</aside>

</section>
<section >

<p>
What about if we have a conditional?
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">bool</span> <span style="color: #599cab;">bad_val</span><span style="color: #99d1ce;">(</span>x<span style="color: #99d1ce;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">returns whether or not x is a bad value</span>
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #245361;">// </span><span style="color: #245361;">removes bad_val if it returns true</span>
<span class="linenr"> 3: </span>some_list.erase<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::remove_if<span style="color: #33859e;">(</span>some_list.begin<span style="color: #d26937;">()</span>, some_list.end<span style="color: #d26937;">()</span>, bad_val<span style="color: #33859e;">)</span>, some_list.end<span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #245361;">// </span><span style="color: #245361;">same as previous line but for lists specifically</span>
<span class="linenr"> 6: </span>c.remove_if<span style="color: #99d1ce;">(</span>bad_val<span style="color: #99d1ce;">)</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #245361;">// </span><span style="color: #245361;">bad way</span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">for</span> <span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">AssocContainer</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">int</span><span style="color: #33859e;">&gt;</span>::<span style="color: #d26937;">iterator</span> <span style="color: #599cab;">i</span> = c.begin<span style="color: #33859e;">()</span>; i!= c.end<span style="color: #33859e;">()</span>; ++i<span style="color: #99d1ce;">)</span>
<span class="linenr">10: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">11: </span>   <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>bad_val<span style="color: #d26937;">(</span>*i<span style="color: #d26937;">)</span><span style="color: #33859e;">)</span> c.erase<span style="color: #33859e;">(</span>i<span style="color: #33859e;">)</span>; 
<span class="linenr">12: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">13: </span>
<span class="linenr">14: </span><span style="color: #245361;">// </span><span style="color: #245361;">good way</span>
<span class="linenr">15: </span><span style="color: #195466; font-weight: bold;">for</span> <span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">AssocContainer</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">int</span><span style="color: #33859e;">&gt;</span>::<span style="color: #d26937;">iterator</span> <span style="color: #599cab;">i</span> = c.begin<span style="color: #33859e;">()</span>; i!= c.end<span style="color: #33859e;">()</span>;<span style="color: #99d1ce;">)</span>
<span class="linenr">16: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">17: </span>   <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>bad_val<span style="color: #d26937;">(</span>*i<span style="color: #d26937;">)</span><span style="color: #33859e;">)</span> c.erase<span style="color: #33859e;">(</span>i++<span style="color: #33859e;">)</span>;
<span class="linenr">18: </span>   <span style="color: #195466; font-weight: bold;">else</span> ++i;
<span class="linenr">19: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The previous example was if we wanted to remove all elements with a specific value. But if we are to use a conditional statement, under which we want to remove something, we can go about in a similar way. Again we will see how to remove items in the different types of containers.
</p>

<p>
For sequential containers (<code>vector</code>, <code>string</code>, <code>deque</code>, and <code>list</code>) is very similar to the previous method. If we have a <b>list</b> specifically, we can use the built in method <code>remove_if()</code>.
</p>

<p>
This is pretty familiar, but there is a catch when we reach the associative containers. There is not method to do what we want to do, which means that we have to write our own loop. That's not a problem, because the logic is easy to implement, but we might fall into a trap. Looking at the two examples, we can see almost similar code. The first snippet seems pretty intuitive, and it is, but it will yield <b><b>undefined</b></b> behavior. Because we are erasing <code>i</code> at the time we find the <code>bad_val</code>, that erasure will make all iterators that point to the value <b>invalid</b>. This means that once that piece of code runs, the returned <code>i</code> will be invalid, making the code <b>undefined</b> since we are then using <code>i</code> again to increment. To overcome this we have to keep in mind the position of <code>i</code> in order to never <b>invalidate</b> it. Thus, we remove the incrementation from the <code>for</code> statement, and handle it in the <code>if</code> statement. Once we reach the bad value, just before we erase the value, we pass the old <b>unincremented</b> value of <code>i</code> and return the new <b>incremented</b> one. We do this with the postfix notation. If don't have a bad value, then we just increment normally <code>i</code>.
</p>

<p>
From my perspective, this is one of those moments where C++ isn't as consistent as we want, because we are doing the same thing for different containers with different code. It's not that bad and once we start writing the code we will get the hang of it, but we still have to remember what are the optimal way to do this job.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org88fba52">
<h3 id="org88fba52">Vectors, strings, maps, and sets</h3>
<aside class="notes">
<p>
Until now, we just talked about the general idea about containers and how to work with them. Every container has a specific job it does best, and most containers have some general use. These four are the most popular. We can't cover all of the containers in a single swoop, but having an idea of the most popular and useful ones will give you courage to experiment and dig deeper into the STL. Now let's get this out of the way, don't use <code>array</code> or <code>char*</code>. Using those two things will bring you a lot of headaces and will just make you have C++. When I started learning C++ all I did was use arrays of different types and it was just a paint - you have no dynamic memory allocation, you had to be careful when you are indexing and reading/writing elements, the syntax is annoying, etc. Instead you should adopt the use of <code>vectors</code> and <code>strings</code> anywhere you have a sequence of elements or a sequence of characters. Underneath both of these structures do use arrays and char pointers, but we don't want to deal with that. I encourage everyone to just look over the specifications of <code>vector</code> and <code>string</code> and to get familiar with the methods. Here we will look over some ways to utilize these STLs as best as we can.
</p>

<p>
In order to really drive the point home, here is what happens, when we are using normal arrays in our code. We have to remember to delete everything in the array that we have put, then we must use the correct form of delete (<code>delete</code> or <code>delete []</code>), then we must make sure that we delete the elements only once. Even if we are not making an array of a type <code>T</code> (let's say we are using <code>int</code>), we still encounter the problem of having to know in advance how much space we need, let alone the situation when we have to iterate over the elements to do some trivial thing. So anytime you decide to write <code>new T[..]</code>, this about if you can't use <code>vector</code> instead.
</p>

</aside>

</section>
<section >

<p>
Reserve space for optimization
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span>vector.size<span style="color: #99d1ce;">()</span>
<span class="linenr">1: </span>vector.capacity<span style="color: #99d1ce;">()</span>
<span class="linenr">2: </span>vector.resize<span style="color: #99d1ce;">(</span><span style="color: #d26937;">size_t</span> <span style="color: #599cab;">n</span><span style="color: #99d1ce;">)</span>
<span class="linenr">3: </span>vector.reserve<span style="color: #99d1ce;">(</span><span style="color: #d26937;">size_t</span> <span style="color: #599cab;">n</span><span style="color: #99d1ce;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
All of this is great, but we can further increase the usefulness of the STL in order to minimize unnecessary operations and save us some trouble. First of which is this - when we are declaring vector object, we have several way to populate the vector - through <b>initialization lists</b>, through <code>push_back()</code>, and so on. Although vector can handle it's own dynamic allocation, there is still a way to optimize things. Because vector calls the underlying <code>realloc()</code> C function, it goes through a 4 step process - <b>1.</b> Allocate new memory that is a multiple of the previous size of the container. <b>2.</b> Then copy all of the previous elements of the previous memory to the new memory. <b>3.</b> Destroy the objects of the old memory. <b>4.</b> Deallocate the old memory. If we are increasing the size of our vector in excess, we will call all of these steps, which will naturally lead to a slower running program. Minimizing this behavior will be a great thing. Another striking thing is that every time such an operation is executed, every pointer, reference, and iterators will be invalidated. This is an even better reason for us to make sure that we optimize these processes.
</p>

<p>
Now before we do that let's just go over the function that <code>vector</code> supports about memory. <code>size()</code> just tells us how may elements there are currently in the container. <code>capacity()</code> tells us how many elements can be inserted with the already allocated memory. <code>resize(size_t n)</code> just resizes the number of elements the container has. If the new number is less than the previous size, then the last elements are deleted and removed, if the new number is greater than the previous size, the remaining empty objects are called with a default initialization. If the new number if larger than the current capacity, there will be a reallocation operation in order to make space for the new elements, before they are inserted. <code>reserve(size_t n)</code> forces the container to change to <code>n</code> given than <code>n</code> is no less than the current size of the container. This typically forces a reallocation, since we want to increase the seize, but of we are to shrink the size, the call is almost always ignored.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #245361;">// </span><span style="color: #245361;">normal code</span>
<span class="linenr">1: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">vector</span><span style="color: #99d1ce;">&lt;</span><span style="color: #d26937;">int</span><span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">v</span>;
<span class="linenr">2: </span><span style="color: #195466; font-weight: bold;">for</span> <span style="color: #99d1ce;">(</span>i = <span style="color: #33859e; font-weight: bold;">0</span>; i &lt; <span style="color: #33859e; font-weight: bold;">1000</span>; i++<span style="color: #99d1ce;">)</span> v.push_back<span style="color: #99d1ce;">(</span>i<span style="color: #99d1ce;">)</span>;
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #245361;">// </span><span style="color: #245361;">better code</span>
<span class="linenr">5: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">vector</span><span style="color: #99d1ce;">&lt;</span><span style="color: #d26937;">int</span><span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">v</span>;
<span class="linenr">6: </span>v.reserve<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">1000</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">7: </span><span style="color: #195466; font-weight: bold;">for</span> <span style="color: #99d1ce;">(</span>i = <span style="color: #33859e; font-weight: bold;">0</span>; i &lt; <span style="color: #33859e; font-weight: bold;">1000</span>; i++<span style="color: #99d1ce;">)</span> v.push_back<span style="color: #99d1ce;">(</span>i<span style="color: #99d1ce;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
So instead of doing meaningless re-allocations, object constructions, destructions, and so on, we can use the power of <code>reserve</code> to tell C++ in advance what we will need for now. So if we are to push, let's say 1000 integers into a vector, we might right a simple code that does that. The first piece of code will do around <b>2</b> to <b>10</b> re-allocations, since each time a reallocation is needed, most compilers increase the size of the container by a factor of the previous size. But if we are to use the reserve method we would do <b>0</b> re-allocations. Of course this can be translated if we are using objects which would cause even more time saving.
</p>

</aside>

</section>
<section >

<p>
<b>Shrink-to-fit</b> or how to decrease the size of a vector that is too big
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #245361;">// </span><span style="color: #245361;">vectors</span>
<span class="linenr">1: </span><span style="color: #33859e; font-weight: bold;">std</span>::vector<span style="color: #99d1ce;">&lt;</span>Object<span style="color: #99d1ce;">&gt;(</span>myVectOgObjects<span style="color: #99d1ce;">)</span>.swap<span style="color: #99d1ce;">(</span>myVectOgObjects<span style="color: #99d1ce;">)</span>;
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #245361;">// </span><span style="color: #245361;">strings</span>
<span class="linenr">4: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>;
<span class="linenr">5: </span><span style="color: #599cab;">string</span><span style="color: #99d1ce;">()</span>.swap<span style="color: #99d1ce;">(</span>s<span style="color: #99d1ce;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Here is another cool little trick. Imagine that you have a very large vector that holds a lot of data initially. But after you have processes some of data you sort (or partially sort) your vector and decide that you want the first few elements. You delete the unnecessary elements from the vector by calling a ranged base <code>erase()</code> method (as you should), but although the size of the vector did shrink, it's capacity is still big (unchanged). So you can use the simple, but non-intuitive trick of <b>swap-to-shrink-to-fit</b>. It's strange that we have to explicitly call <code>vector&lt;T&gt;</code> in order to swap and shrink, but what is happening is that in that place, there is a hidden temporary vector that is the exact copy of the one we want to shrink (created through the vector copy constructor), and after the method call, we get the exact size and capacity we want for our original vector.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org827413f">
<h3 id="org827413f">Iterators</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">ifstream</span> <span style="color: #599cab;">inputFile</span><span style="color: #99d1ce;">(</span><span style="color: #2aa889;">"interestingData.txt"</span><span style="color: #99d1ce;">)</span>;
<span class="linenr"> 1: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">fileData</span><span style="color: #99d1ce;">(</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::istream_iterator<span style="color: #d26937;">&lt;</span><span style="color: #d26937;">char</span><span style="color: #d26937;">&gt;(</span><span style="color: #599cab;">inputFile</span><span style="color: #d26937;">)</span><span style="color: #33859e;">)</span>,istream_iterator<span style="color: #33859e;">&lt;</span><span style="color: #d26937;">char</span><span style="color: #33859e;">&gt;()</span><span style="color: #99d1ce;">)</span>; 
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">ok code</span>
<span class="linenr"> 4: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">ifstream</span> <span style="color: #599cab;">inputFile</span><span style="color: #99d1ce;">(</span><span style="color: #2aa889;">"interestingData.txt"</span><span style="color: #99d1ce;">)</span>;
<span class="linenr"> 5: </span>inputFile.unset<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">ios</span>::skipws<span style="color: #99d1ce;">)</span>;
<span class="linenr"> 6: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">fileData</span><span style="color: #99d1ce;">(</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::istream_iterator<span style="color: #d26937;">&lt;</span><span style="color: #d26937;">char</span><span style="color: #d26937;">&gt;(</span><span style="color: #599cab;">inputFile</span><span style="color: #d26937;">)</span><span style="color: #33859e;">)</span>, istream_iterator<span style="color: #33859e;">&lt;</span><span style="color: #d26937;">char</span><span style="color: #33859e;">&gt;()</span><span style="color: #99d1ce;">)</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #245361;">// </span><span style="color: #245361;">better code</span>
<span class="linenr"> 9: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">ifstream</span> <span style="color: #599cab;">inputFile</span><span style="color: #99d1ce;">(</span><span style="color: #2aa889;">"interestingData.txt"</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">10: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">fileData</span><span style="color: #99d1ce;">(</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::istreambuf_iterator<span style="color: #d26937;">&lt;</span><span style="color: #d26937;">char</span><span style="color: #d26937;">&gt;(</span><span style="color: #599cab;">inputFile</span><span style="color: #d26937;">)</span><span style="color: #33859e;">)</span>,istreambuf_iterator<span style="color: #33859e;">&lt;</span><span style="color: #d26937;">char</span><span style="color: #33859e;">&gt;()</span><span style="color: #99d1ce;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Apart from the normal data structures that the STL has to offer, we have also one more interesting topic to look at - iterators. Basically, iterators are some object that points to an element from a container. There are four types of iterators (<code>iterator</code>, <code>reverse_iterator</code>, <code>const_iterator</code>, <code>const_reverse_iterator</code>). Iterators are written in the style of <code>T*</code>, where for each type of iterator, there is a similar way of implementing it. The suggestion here is simple, prefer to use only the simple iterator that C++ gives us. There are several reasons for this. First, the option for us to insert or erase an objects into a container in a specific position accepts only iterators of type <code>iterator</code> (not any of the other kinds). Also, although we can transform one type of iterator into anther, this transformation is not always possible. At this point we might not even bother and stick to our normal iterators.
</p>

<p>
Aside from the general use of iterators I want to mention something that is mostly looked over and should be used more often. It has made my life much easier when it comes to command line user input and that is the <code>istreambuf_iterator</code>. Until know we are used to getting input from the console by using the <code>std::cin &lt;&lt;</code> operator. This is a fine until we realize that the operator omits white spaces, and the moment we need to use a blank space we hit a wall. One way to overcome this is to disable the option to skip white spaces through the <code>ios</code> namespace. But since that approach is kind if slow (maybe even up to 40%) slower. That's why we can just use the <code>istreambuf_iterator</code> which is much more intuitive to use.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org8eaa724">
<h3 id="org8eaa724">Lambda expressions</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #99d1ce;">[]()</span> <span style="color: #99d1ce;">{</span> . . . <span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">empty lambda function</span>
<span class="linenr"> 1: </span><span style="color: #245361;">// </span><span style="color: #245361;">or </span>
<span class="linenr"> 2: </span><span style="color: #99d1ce;">[]</span> <span style="color: #99d1ce;">()</span> <span style="color: #195466; font-weight: bold;">mutable</span> -&gt; T <span style="color: #99d1ce;">{</span> . . . <span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">T is a return type</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #99d1ce;">[]</span> <span style="color: #245361;">// </span><span style="color: #245361;">capture list</span>
<span class="linenr"> 5: </span><span style="color: #99d1ce;">()</span> <span style="color: #245361;">// </span><span style="color: #245361;">argument list</span>
<span class="linenr"> 6: </span><span style="color: #99d1ce;">{}</span> <span style="color: #245361;">// </span><span style="color: #245361;">function body</span>
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #245361;">// </span><span style="color: #245361;">capture list options</span>
<span class="linenr"> 9: </span><span style="color: #99d1ce;">[]</span>   <span style="color: #245361;">// </span><span style="color: #245361;">empty list, no access from locals</span>
<span class="linenr">10: </span><span style="color: #99d1ce;">[</span>x<span style="color: #99d1ce;">]</span>  <span style="color: #245361;">// </span><span style="color: #245361;">access to locals by value</span>
<span class="linenr">11: </span><span style="color: #99d1ce;">[</span>&amp;x<span style="color: #99d1ce;">]</span> <span style="color: #245361;">// </span><span style="color: #245361;">access to locals by ref</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">[</span>&amp;<span style="color: #99d1ce;">]</span>  <span style="color: #245361;">// </span><span style="color: #245361;">access to any local var by the reference</span>
<span class="linenr">13: </span><span style="color: #99d1ce;">[</span>=<span style="color: #99d1ce;">]</span>  <span style="color: #245361;">// </span><span style="color: #245361;">access to any local var by the value</span>
<span class="linenr">14: </span><span style="color: #99d1ce;">[</span>=, &amp;y<span style="color: #99d1ce;">]</span> <span style="color: #245361;">// </span><span style="color: #245361;">mix them together</span>
</pre>
</div>

<aside class="notes">
<p>
Since C++ 11, we have this neat thing called <b>lambda functions</b> or <b>lambda expressions</b>. If you come from a background of <b>Java</b> or <b>C#</b>, these might sound familiar to you. So what are they and what kind of problems do they help us to solve? In some simple terms, <b>lambda functions</b> are small snippets of code, also typically called an anonymous function objects, that are never going to be reused and are not worth bothering to name and define. This means that if we want to make some operation over a container, instead of creating a separate <code>namespace</code> or <code>struct</code> or a <code>class</code> where we will have this lonely <b>one-time-use</b> function, we can just use a lambda function and be done with it. They can be used instead of a named class with an <code>operator()</code>. Here is the basic syntax of a lambda function. We have three parts of a lambda function - the <b>capture list</b>, the <b>argument list</b>, an optional <b>mutable</b> specifier, an optional <b>return type</b> <code>-&gt;</code>, and the <b>function body</b>. The argument list and the function body work like any other function so we don't need to explain them, but the capture list and mutable specifier are pretty interesting. The capture defines <b>what</b> from the outside of the lambda function can be used inside it and <b>how</b> (either to be passed by reference or by value). There are several ways we can use the capture list - we can specify an empty list <code>[]</code>, which tell us that no local names from the surrounding context can be used inside the function body. For such a list, data is taken from the passed arguments or from non-local variables. We can use <code>[&amp;]</code>, which tells us that we can use all local variables <b>by-reference</b>. We can also have an implicit capture by value with <code>[=]</code>, where all local variables can be used as copied (<b>by-value</b>). We can have an explicit capture list like <code>[capture-list]</code>, where we specify the names of the local variables we want to use. Here if we use the <code>&amp;</code> sign we tell C++ that the captured variables are to be used with a <b>reference</b>. This can be expanded to be like <code>[&amp;, capture-list]</code>, where we specify that all local variables are to be used with a <b>reference</b>, except the specified ones in the list, which are to be used by value. With the same logic we can have <code>[=, capture-list]</code>, and you can guess what this means (all local variables are to be used by value, except the ones in the capture list, which are to be used with a reference). Of course you can mix all of these together with a comma separator.
</p>

<p>
Now what does the <code>mutable</code> keyword do in this situation? Well this allows us to modify the whole lambda expression in the function body, i.e. change the lambda's copies of variables that are captured by value. Usually we don't want to do this, so by default this option is turned <b>off</b>. This comes in handy not all that often, but what it allows us ot do, is to change variables in the scope of the lambda body when the variables are passed by value. Because underneath, function objects with <code>operator()()</code> are implemented with a <code>const</code> member function, this is why the default behavior of the lambda function is to also use variables as a constant. If we wanted to change a variable (that is passed by value) and not use the <code>mutable</code> keyword, we would get a compilation error.
</p>

<p>
So what about return types? Well, like any other function, we can specify the lambda to have either an implicit return type or an explicit one. Sometimes the function can deduce what we want on its own. For instance, if we lack the <code>return</code> keyword, the function will return <code>void</code>. If we have, as an example, <code>return x+y;</code>, the lambda will be of that return type. But sometimes, we will have a complex situation, where C++ cannot deduce what we are going to return, that's why we can use the optional form <code>-&gt;</code> to tell it what it should expect. Let's say we have this sitation - <code>auto f = [b]() -&gt;int { if (b) return 1: else return 2; };</code> . In this case we have to explicitly tell C++ what to expect, since the body is too complicated.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org265df74">
<h2 id="org265df74">Exercises</h2>
<ul>
<li><a href="https://www.reddit.com/r/dailyprogrammer/">Reddit - Daily programmer</a></li>
<li><a href="https://drive.google.com/open?id=1jREN-VuC4sa8QE6E5n71oJ2C9Vp3ciJ1">189 Programming questions</a></li>
<li><a href="https://github.com/Anarcroth/daily-code-challenges">My coding challenges</a></li>

</ul>

<aside class="notes">
<p>
Instead of just listing a ton of links to challenges and exercises, here are a few links that will provide much more. One is a sub-reddit, specifically dedicated to solving coding challenges. Most of them are doable in just a few hours. My advice here is to do the easy ones, because they will <b>"force"</b> in one way or another to experiment with the <b>STL</b> or with object orientation. Although the harder challenges are very fun, they are more about concept, where as the easier ones a just to use some basic algorithm, where the STL is the perfect place for such practice. The pdf is a famous book filled with coding tasks that you might see in an interview, think of them as small tasks about specific topics in each chapter. Whether you have chosen the pdf or the reddit board, just force yourself to experiment with new concepts and new STL features. The best way to learn a language is to practice, practice, practice. Finally I have also shared my personal <b>github</b> repository where I occasionally solve such tasks. By no means are they well solved or optimal, but at least you can see somebody else's code and can learn from my mistakes.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgbd8bf1a">
<h2 id="orgbd8bf1a">Resources</h2>
<div class="outline-text-2" id="text-orgbd8bf1a">
</div>
</section>
</section>
<section>
<section id="slide-orgb9a0ab4">
<h3 id="orgb9a0ab4">Templates</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/29298212/what-is-an-implicit-interface">Implicit Interface</a></li>
<li><a href="https://stackoverflow.com/questions/1881468/what-is-compile-time-polymorphism-and-why-does-it-only-apply-to-functions">Compile-time polymorphism</a></li>
<li><a href="http://advancedcpp.livejournal.com/728.html">Compile-time polymorphism 2</a></li>
<li><a href="https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html">Mixins</a></li>
<li><a href="https://stackoverflow.com/questions/18773367/what-are-mixins-as-a-concept">Mixins 2</a></li>
<li><a href="https://stackoverflow.com/questions/7085265/what-is-c-mixin-style">Mixins 3</a></li>
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Curiously_Recurring_Template_Pattern">Mixins 4</a></li>
<li><a href="http://www.thinkbottomup.com.au/site/blog/C%20%20_Mixins_-_Reuse_through_inheritance_is_good">Mixins 5</a></li>
<li><a href="https://yanniss.github.io/practical-fmtd.pdf">Mixins 6</a></li>
<li><a href="https://web.archive.org/web/20060619131004/http://blogs.msdn.com/slippman/archive/2004/08/11/212768.aspx">Typename why do we have it</a></li>
<li><a href="https://stackoverflow.com/questions/2023977/difference-of-keywords-typename-and-class-in-templates">Typename and class</a></li>
<li><a href="https://stackoverflow.com/questions/2023977/difference-of-keywords-typename-and-class-in-templates">Difference between typename and class</a></li>

</ul>

</section>
</section>
<section>
<section id="slide-org84733ac">
<h3 id="org84733ac">STL</h3>
<ul>
<li><a href="http://www.cplusplus.com/reference/stl/">Containers</a></li>
<li><a href="http://en.cppreference.com/w/cpp/container">Containers 2</a></li>
<li><a href="https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/lectures/containers.html">Containers 3</a></li>
<li><a href="https://eli.thegreenplace.net/2012/06/20/c11-using-unique_ptr-with-standard-library-containers">Smart pointers</a></li>
<li><a href="https://jonasdevlieghere.com/containers-of-unique-pointers/">Unique pointer</a></li>
<li><a href="https://stackoverflow.com/questions/17753442/dealing-with-unique-ptr-in-containers">How to use unique pointers in containers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom">Erase-remove idiom</a></li>
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Erase-Remove">Erase-remove idiom 2</a></li>
<li><a href="https://stackoverflow.com/questions/347441/erasing-elements-from-a-vector">Erase elements from a vector</a></li>
<li><a href="http://www.cplusplus.com/reference/iterator/">Iterators</a></li>
<li><a href="https://stackoverflow.com/questions/131241/why-use-iterators-instead-of-array-indices">Why use iterators</a></li>

</ul>

</section>
</section>
<section>
<section id="slide-orga2494a0">
<h3 id="orga2494a0">Lambdas</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/5501959/why-does-c0xs-lambda-require-mutable-keyword-for-capture-by-value-by-defau">Mutable</a></li>
<li><a href="https://stackoverflow.com/questions/12765442/c-lambda-expression-anonymous-function?noredirect=1&amp;lq=1">Anonymous functions</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/lambda">Lambdas</a></li>
<li><a href="https://stackoverflow.com/questions/15559658/c11-lambdas-and-the-square-brackets?noredirect=1&amp;lq=1">Lambdas 2</a></li>
<li><a href="https://stackoverflow.com/questions/31494188/what-does-the-code-mean-in-c?noredirect=1&amp;lq=1">Lambdas 3</a></li>
<li><a href="https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11">What is a lambda expression</a></li>
<li><a href="https://stackoverflow.com/questions/356950/c-functors-and-their-uses">Functors</a></li>
<li><a href="http://www.bogotobogo.com/cplusplus/functors.php">Function Objects</a></li>
<li><a href="https://stackoverflow.com/questions/7852101/c-lambda-with-captures-as-a-function-pointer">Lambda with captures</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="../js/head.min.js"></script>
<script src="../js/reveal.js"></script>

<script>
 // Full list of configuration options available here:
 // https://github.com/hakimel/reveal.js#configuration
 Reveal.initialize({

     controls: true,
     progress: true,
     history: true,
     center: true,
     slideNumber: 'c',
     rollingLinks: true,
     keyboard: true,
     overview: true,
     width: 1920,
     height: 1080,
     margin: 0.00,
     maxScale: 2.00,

     theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
     transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
     transitionSpeed: 'default',
     multiplex: {
         secret: '', // null if client
         id: '', // id, obtained from socket.io server
         url: '' // Location of socket.io server
     },

     // Optional libraries used to extend on reveal.js
     dependencies: [
         { src: '../js/classList.js', condition: function() { return !document.body.classList; } },
         { src: '../js/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
         { src: '../js/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
         { src: '../js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
         { src: '../js/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
 });
</script>
</body>
</html>
