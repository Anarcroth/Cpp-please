<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Templates and STL</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Templates and STL</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-01-23 вт 20:11</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org38f42b4">Generics in C++</a></li>
<li><a href="#/slide-org44f767a">Template programming</a></li>
<li><a href="#/slide-org4749866">The STL</a></li>
<li><a href="#/slide-org49eae88">Exercises</a></li>
<li><a href="#/slide-org1bd0a89">Resources</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-org38f42b4">
<h2 id="org38f42b4">Generics in C++</h2>
<aside class="notes">
<p>
One of the things that C++ manages to do very well is to provide generic programming to us. The <b>STL</b> is one of the best functionalities that have been ever made in the language. <code>Vectors</code>, <code>lists</code>, <code>for_each</code>, and many many more containers are available to use to shorten our code, make it more understandable, and make it independent from types! The C++ template mechanism was also Turing complete (you can compute any computable value with it), which led to template meta programming. With this tutorial we will go over what templates can do, how we can use them (and when) and then we will concentrate on the STL.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org44f767a">
<h2 id="org44f767a">Template programming</h2>
<ul>
<li class="fragment roll-in">Templates</li>
<li class="fragment roll-in">Compile-time polymorphism</li>
<li class="fragment roll-in"><code>typename</code> or <code>class</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgc150bd3">
<h3 id="orgc150bd3">Templates</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #d26937;">T</span> <span style="color: #599cab;">GetMax</span> <span style="color: #99d1ce;">(</span><span style="color: #d26937;">T</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">T</span> <span style="color: #599cab;">b</span><span style="color: #99d1ce;">)</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e;">(</span>a &gt; b ? a : b<span style="color: #33859e;">)</span>;
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span><span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">doProcessing</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">T</span>&amp; <span style="color: #599cab;">w</span><span style="color: #99d1ce;">)</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>w.size<span style="color: #d26937;">()</span> &gt; <span style="color: #33859e; font-weight: bold;">10</span> &amp;&amp; w != someObject<span style="color: #33859e;">)</span>
<span class="linenr">4: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">5: </span>        <span style="color: #d26937;">T</span> <span style="color: #599cab;">temp</span><span style="color: #d26937;">(</span>w<span style="color: #d26937;">)</span>;
<span class="linenr">6: </span>        temp.normalize<span style="color: #d26937;">()</span>;
<span class="linenr">7: </span>        temp.swap<span style="color: #d26937;">(</span>w<span style="color: #d26937;">)</span>;
<span class="linenr">8: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">9: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
There is a good chance that you will not be dealing with a lot of template code in C++ and that's okay. But it is still a good idea to be able to understand and write templates in C++. In fact, compared to Java or C#, C++ has more flexibility when it comes to writing such code (although this isn't always good). So what are templates? They are just something that can be substituted for something else during run-time. It allows us to greatly reuse code, abstracts us from dealing with types, but at the same time, it makes executables larger, and sometimes slower.
</p>

<p>
Okay so let's look at a template.
</p>

<p>
In the first piece of code, we have a template function that returns the larger of the two types. These types can be literally anything - they can by <code>int</code>, <code>double</code>, <code>char</code>, <code>someObject</code>, etc. As long as the type <code>T</code> has an implementation of <code>&gt;</code>, this will compile and this will run. In the second example we can see even clearer when we say that some template must support something. We are passing <code>w</code> by reference (so maybe it's an object). The parameter uses the <code>size()</code>, <code>normalize()</code>, and <code>swap()</code> functions (okay, it's an object). We also have the operator <code>!=</code> in use, and we also have a copy constructor. If we were to just substitute <code>T&amp; w</code> with <code>SpecificObject&amp; w</code>, we would not worry that <code>w</code> supports all of these functionalities, because we have explicitly stated what we are passing. But since we are using a template, we are <b>expecting</b> that <code>T</code> supports them. This is the meaning of an <b>implicit</b> interface. Writing templates means that we are dealing with implicit interfaces in the first place.
</p>

<p>
It's okay not to stress it that much when we are writing generic functions, which are designed to handle build-in types (such as <code>int</code> and <code>double</code>), but when we are working with user defined types, we have to be careful what the function is actually doing, and does it support the interface.
</p>

<p>
One thing to consider when dealing with implicit interfaces is that it's not important whether what the function we are using does what it has to do. This means that when we call <code>w.size()</code>, this might return some integer indicating the size of <code>w</code>, but it might not, it might not ever return a number! As long as the function call returns something that can be used with the <code>&gt;</code> operator, this code will compile! Maybe the function is defined in some base class where it is inherited, everything is valid as long as the next operator runs. The same is true for the <code>!=</code> operator. It can take a type <code>X</code> and a type <code>Y</code> and as long as <b><b>T</b></b> is convertable to <b><b>X</b></b> and <b><b>someObject</b></b> to <b><b>Y</b></b>, the statement will run. So we can say that implicit interfaces are just a set of valid expressions, which impose some constraints. So the constraint of the whole expression doesn't really matter of the types used in it as long as the final yielded result is compatible with <code>bool</code>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org6193b02">
<h3 id="org6193b02">Compile-time polymoprhism</h3>
<ul>
<li>In old C++ - function overloading</li>
<li>In template C++ - almost the same, but with unknown types</li>

</ul>

<aside class="notes">
<p>
Okay we get what an implicit interface is. But next to this there is another very important aspect of templates and that is <b><b>compile-time polymorphism</b></b>. Sounds scary, it's not. You've most probably have used this and in the world of normal functions this is also known as <b>function overloading</b>. There is a debate whether this should also be referred to as polymorphism, but it is what it is. Now where do templates come along in this? Much similar to overloading, when we are declaring multiple templates, we can specify at some point in our code what the template will be (i.e. what type). Since we are telling the compiler the type, during compile time, the type of the template used will be mapped in the object file and will resolve at that time. In contrast to dynamic binding, where during runtime it is decided which function is called, the compiler knows based on the types we use what to substituted for when a function is called.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgb18e307">
<h4 id="orgb18e307">The Mixin idiom</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MixinClass</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">T</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">code</span>
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MixinBase</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span> :
<span class="linenr"> 3: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">f</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span> <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"HELLO"</span> &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl; <span style="color: #33859e;">}</span>;
<span class="linenr"> 4: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Mixin</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">T</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">10: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">f</span><span style="color: #33859e;">()</span> 
<span class="linenr">11: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">12: </span>        <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"call from mixin f method"</span> &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">13: </span>        <span style="color: #33859e; font-weight: bold;">T</span>::f<span style="color: #d26937;">()</span>;
<span class="linenr">14: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">15: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">16: </span>
<span class="linenr">17: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">18: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Mixin2</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">T</span>
<span class="linenr">19: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">20: </span><span style="color: #195466; font-weight: bold;">public</span> :
<span class="linenr">21: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">g</span><span style="color: #33859e;">()</span> 
<span class="linenr">22: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">23: </span>        <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"call from mixin2 g method"</span> &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">24: </span>        <span style="color: #33859e; font-weight: bold;">T</span>::f<span style="color: #d26937;">()</span>;
<span class="linenr">25: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">26: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">27: </span>
<span class="linenr">28: </span><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span><span style="color: #99d1ce;">()</span>
<span class="linenr">29: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">30: </span>    <span style="color: #d26937;">Mixin2</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">Mixin</span> <span style="color: #d26937;">&lt;</span><span style="color: #d26937;">MixinBase</span><span style="color: #d26937;">&gt;</span> <span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">mix</span>;
<span class="linenr">31: </span>    mix.g<span style="color: #33859e;">()</span>;
<span class="linenr">32: </span>
<span class="linenr">33: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr">34: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Now that we know about implicit interfaces and the fact that template must support the interface in the method body, we can talk about one of the most useful concepts in C++, which is the <b><b>Mixin</b></b>.
</p>

<p>
Mixins are a great way to reuse code and overcome come implementational problems that <b>composition and delegation</b> and <b>inheritance-based-reuse</b> bring. From a syntactic point of view this is a <code>mixin</code>. This is a template class that inherits from the type of the template. Simple enough, but why is this important? Well, mixins are like putting all of the reusable code in the derived class (instead of the conventional way of putting the reusable code in the base class). Basically, mixins are small classes that implement a very specific functionality for another class, through a specified class that provides the specific features the functionality needs.More abstractly speaking, mixins are small fragments of a class that are intended to be composed with other classes. Let's say we are trying to model something, we start writing our code and implement all of our classes and hierarchies normally as we know, at which point we have several classes, orthogonal to each other (<code>decoupled</code>). We might have some common interface between those classes and at that point we inherit from that interface. We writing our explicit implementation of what we have inherited. Everything seems fine, but the problem with this design is that we do not have an easy way to combine our modeled classes with each other. This is where mixins come in play. They allow us to create primitive classes that are used as building blocks. We can plug in any class we want into them and get the functionality we desire, while keeping the classes orthogonal to each other.
</p>

<p>
From the example we can see how a mixin can be used to <b>"plug-in"</b> classes together and get some functionality out of them. The code works like this - we create an object that is combined from a base class that just outputs a string and two other mixin classes. At this point we can see how we are usgin multiple inheritance, i.e. inhereting from the template class. We can simply traverse the output of the program and see how using the <code>g()</code> method we get the output of the <code>Mixin2</code> class, which, then using the template <code>T</code> calls the <code>f()</code> method. Since that <code>T</code> is of type <code>Mixin</code>, we go to that class and execute <code>f()</code>. In that method call we also have another <code>f()</code>, but this time the <code>T</code> of the template is of type <code>MixinBase</code>. Sort of a long traversal, but nothing too complicated. This is how we use mixins in the simplest form. Now let's look at a more practical example.
</p>

<p>
Remember, don't use mixins unless your programs needs them. Although their versatility, they bring complexity to the whole structure.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc4eae55">
<h3 id="orgc4eae55"><code>typename</code> or <code>class</code></h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span> <span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Thing</span>;
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span> <span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">OtherThing</span>;
</pre>
</div>

<aside class="notes">
<p>
One of the things you might have noticed until now is that, in all of the examples we have seen so far, the keyword <code>typename</code> has been used. Now let's talk about the differnece between why and when to use <code>typename</code> and when to use <code>class</code> when declaring templates and so on. In the example we have, the difference between declaring a template parameter with <code>class</code> or <code>typename</code> is <b>nothing</b>. But there is a logical difference. Some people like the <b>class</b> because it's less typing, others like <b>typename</b>, because it indicates that the passed parameter doesn't need to be a class type. You can choose to use <b>typename</b> when any type is allowed and to use <b>class</b> when a user-defined type is passed. So what's the big fuss, when both are considered equal by C++. Well, C++ does find a difference between the two, and sometimes we do have to use only typename, and sometimes we have to use class only. Here are the edge cases.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Demonstration</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">4: </span>    <span style="color: #33859e; font-weight: bold;">T</span>::<span style="color: #d26937;">A</span> *<span style="color: #599cab;">aObj</span>; <span style="color: #245361;">// </span><span style="color: #245361;">oops! error!</span>
<span class="linenr">5: </span>    <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #33859e; font-weight: bold;">T</span>::<span style="color: #d26937;">A</span> *<span style="color: #599cab;">aObg</span>; <span style="color: #245361;">// </span><span style="color: #245361;">correct!</span>
<span class="linenr">6: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
For <b>typename</b> - During the olden days of standardization of the language, the C++ people found a problem when trying to make declarative statements in a templated class. That is, when we have a template class, in which we use the template to access another nested template, we would get an error. The problem was that when we are accessing nested templates, C++ doesn't recognize we are doing that and it thinks that we are actually multiplying object <code>A</code> by <code>aObj</code>. In order to fix this, we just have to tell the compiler that we want to declare something (and not break everything). This is the situation when we use <b>typename</b>, to indicate a declerative statement.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #33859e;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span>, <span style="color: #195466; font-weight: bold;">typename</span><span style="color: #33859e;">&gt;</span> <span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Container</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Type</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MyContainer</span>: <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">Container</span><span style="color: #99d1ce;">&lt;</span><span style="color: #d26937;">Type</span>, <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">allocator</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">Type</span><span style="color: #33859e;">&gt;</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #245361;">//</span><span style="color: #245361;">code</span>
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
For <b>class</b> - The other edge case is when we have a <b>template template parameter</b> declaration. When we are declaring a template template, we are limited to use the <code>class</code> keyword in order to tell the compiler that the template parameter is <code>Container</code>. If we are to write <code>template Container</code>, then we would get a compiler error. This is the way it is&#x2026; almost. Form C++ 17 this is no longer a problem since writing either <code>class</code> or <code>template</code> will yield the same valid result. If you are using C++ 14 or 11, keep in mind for this restriction.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org4749866">
<h2 id="org4749866">The STL</h2>
<ul>
<li class="fragment roll-in">Containers</li>
<li class="fragment roll-in">Vectors, strings, maps, and sets</li>
<li class="fragment roll-in">Iterators</li>
<li class="fragment roll-in">Lambda functions</li>

</ul>

<aside class="notes">
<p>
Now that we have a good grasp of what templates are, we can concentrate on one of the best things in C++ - the STL (<b>The Standard template Library</b>). The STL is an arrangement of containers that allows us to manipulate our data in easy and intuitive ways. Although there is a whole other book specifically for how to use the STL in an effective manner. We can't cover all of those items here, so we will just look over some of the most useful things (or at least to my perception). Nevertheless, after this section you should feel comfortable to dive deep into the world of STL, it's both fun and it makes C++ much much easier (if done right).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org1ad4974">
<h3 id="org1ad4974">Containers</h3>
<ul>
<li class="fragment roll-in">Sequence containers</li>
<li class="fragment roll-in">Associative containers</li>
<li class="fragment roll-in">Unordered associative containers</li>
<li class="fragment roll-in">Container adapters</li>

</ul>

<aside class="notes">
<p>
The containers of C++ are the fundamentals of how the STL works. These are collections of the same object, where they hold/own the elements in them. Containers are very flexible due to their <b>template</b> implementation. We have three general forms of containers. <b>Sequence</b> containers  control the order in which elements are stored (<code>vector</code>, <code>array</code>, <code>list</code>, <code>deque</code>). The order in which we insert our data is the order we are going to get it. <b>Associative</b> containers control the position of the elements (<code>set</code>, <code>map</code>, <code>multimap</code>, <code>multiset</code>). In this case the elements are not inserted based to the position they have, but on their value. Finally we have <b>Unordered</b> associative containers, which holds the position of the elements through a hash to each element (<code>unordered_set</code>, <code>unordered_map</code>). There are also the so called <b>container adapters</b>, which are not full blown containers, but are used to hold some other container in them (<code>stack</code>, <code>queue</code>, <code>priority_queue</code>). These adapters hold the other container and through the adapter do we access the elements. Of course there are many more types of containers, but these are the basics and should get you going.
</p>

</aside>

</section>
<section >

<p>
To <code>size()</code> or to <code>empty()</code>?
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">if</span> <span style="color: #99d1ce;">(</span>cont.size<span style="color: #33859e;">()</span> == <span style="color: #33859e; font-weight: bold;">0</span><span style="color: #99d1ce;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">same lines</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">if</span> <span style="color: #99d1ce;">(</span>cont.empty<span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>     <span style="color: #245361;">// </span><span style="color: #245361;">of code</span>
</pre>
</div>

<aside class="notes">
<p>
Now let's talk about some implementations we can use with containers, which are going to make our lives easier. One this is that we will often, when using containers, see if it's empty or not. We have to ways of doing that, wither through <code>cont.size() == 0</code> or <code>cont.empty()</code>. Which one is the better way? The latter is. Because, when we are calling the <code>size()</code> function, we are telling the container to traverse through the whole construct to see what is the actual size. The problem here is that, size cannot be implemented to return in constant time. Since new elements have to change the size of the container, this puts the implementer in a conundrum, how to make size return in constant time, and different container implementations make different choices. To overcome this, just use <code>empty()</code>, because this method will always return in constant time.
</p>

</aside>

</section>
<section >

<p>
Prefer range member functions to for loops
</p>

<div class="org-src-container">

<pre  class="fragment (roll-in)"><span class="linenr">0: </span>v1.assign<span style="color: #99d1ce;">(</span>v2.begin<span style="color: #33859e;">()</span> + v2.size<span style="color: #33859e;">()</span> / <span style="color: #33859e; font-weight: bold;">2</span>, v2.end<span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="fragment (roll-in)"><span class="linenr">0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">vector</span><span style="color: #99d1ce;">&lt;</span>Obj<span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">v1</span>,<span style="color: #599cab;">v2</span>;
<span class="linenr">1: </span>
<span class="linenr">2: </span><span style="color: #245361;">// </span><span style="color: #245361;">code thingies</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span>v1.clear<span style="color: #99d1ce;">()</span>;
<span class="linenr">5: </span><span style="color: #195466; font-weight: bold;">for</span> <span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">auto</span> &amp;<span style="color: #599cab;">v</span> : v2.begin<span style="color: #33859e;">()</span> + v2.size<span style="color: #33859e;">()</span> / <span style="color: #33859e; font-weight: bold;">2</span><span style="color: #99d1ce;">)</span>
<span class="linenr">6: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">7: </span>    v1.push_back<span style="color: #33859e;">(</span>v<span style="color: #33859e;">)</span>;
<span class="linenr">8: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
One of the best things about the containers is that they come with built in awesome member functions that will do a lot of work for us with the added benefit of making the code base clearer and smaller. The problem is that we don't always know that the containers we are using have such awesome functions that come along with them. Specifically, if you like writing for loops for containers, then maybe it's time to look over what that specific data structure can do for you. Let's take this example. We have two vectors <code>v1</code> and <code>v2</code>. We want to make <code>v1</code> be the same as the second half of <code>v2</code>, what's the easiest way? Answer : <code>v1.assign(v2.begin() + v2.size() / 2, v2.end());</code>. Here we are achieving a few things. First we are making our code much smaller and clearer, combining everything we want into just a few characters. Second, we are not using some form of looping logic we wrote, because look at how we would have to write it if we were to make it ourselves. The best way to overcome such problems is to ask yourself before you try to use a loop - "What do I want to achieve with this loop and can I use something from the containers method set?". This will both decrease the code you write and will increase your knowledge of the STL, because most of these range based members are in the majority of containers.
</p>

</aside>

</section>
<section >

<p>
Delete <code>new</code> ed objects in containers
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">awesomeFunction</span><span style="color: #99d1ce;">()</span>
<span class="linenr">1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">2: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">vector</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">Obj</span>*<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">v_obj</span>;
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">for</span> <span style="color: #33859e;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = <span style="color: #33859e; font-weight: bold;">0</span>; i &lt; <span style="color: #33859e; font-weight: bold;">42</span>; i++<span style="color: #33859e;">)</span>
<span class="linenr">4: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">5: </span>        v_obj.push_back<span style="color: #d26937;">(</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">Obj</span><span style="color: #d26937;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">ticking timebomb</span>
<span class="linenr">6: </span>        <span style="color: #245361;">// </span><span style="color: #245361;">more code...</span>
<span class="linenr">7: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">8: </span><span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">memory leak happens here!</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">awesomeFunction</span><span style="color: #99d1ce;">()</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">.. same code as before</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>    <span style="color: #195466; font-weight: bold;">for</span> <span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">auto</span> &amp;<span style="color: #599cab;">v</span> : v_obj<span style="color: #33859e;">)</span>
<span class="linenr"> 5: </span>    <span style="color: #33859e;">{</span>
<span class="linenr"> 6: </span>        <span style="color: #195466; font-weight: bold;">delete</span> v;
<span class="linenr"> 7: </span>    <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">no memory leaks!</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">}</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #245361;">// </span><span style="color: #245361;">or</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">manageFlights</span><span style="color: #99d1ce;">()</span>
<span class="linenr">13: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">14: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">vector</span><span style="color: #33859e;">&lt;</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">unique_ptr</span><span style="color: #d26937;">&lt;</span>Plane<span style="color: #d26937;">&gt;</span> <span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">airport</span>;
<span class="linenr">15: </span>    <span style="color: #195466; font-weight: bold;">for</span> <span style="color: #33859e;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = <span style="color: #33859e; font-weight: bold;">0</span>; i &lt; <span style="color: #33859e; font-weight: bold;">10</span>; i++<span style="color: #33859e;">)</span>
<span class="linenr">16: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">17: </span>        airport.push_back<span style="color: #d26937;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::make_unique<span style="color: #888ca6;">&lt;</span>Plane<span style="color: #888ca6;">&gt;()</span><span style="color: #d26937;">)</span>;
<span class="linenr">18: </span>        airport.at<span style="color: #d26937;">(</span>i<span style="color: #d26937;">)</span>-&gt;fuel = <span style="color: #33859e; font-weight: bold;">4000</span>;
<span class="linenr">19: </span>        <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; airport.at<span style="color: #d26937;">(</span>i<span style="color: #d26937;">)</span>-&gt;fuel &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">20: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">21: </span><span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">No memory leaks!</span>
</pre>
</div>

<aside class="notes">
<p>
More often than not, you will be creating objects on the <code>heap</code> regularly and you will be using your containers as usual. So you will, naturally, combine both your new objects in the containers, but there is a small problem here. Containers by themselves do handle their own memory and they do delete themselves once their are of no need, but that doesn't mean that they will handle data on the <code>heap</code>. That's why if you have collections that are filled with such objects, you have to manually delete them. Now there is some wiggle room and that is that we can use <b>smart pointer</b> to our advantage and not worry about memory allocation and deletion. Now there is some clearing up to do. Before <b>C++ 11</b>, we had only one type of smart pointer and that is the <code>auto_ptr</code>. Since then <code>auto_ptr</code> isn't all that smart and caused a lot of troubles. One of which is the fact that we couldn't use it with any container. It was so bad that the C++ standards committee actually forced a rule where the compiler will not allow the program to have an <code>auto_ptr</code> in any container. But after C++ 11, things changed and we have <code>uniquq_ptr</code>, which should be your default <b>goto</b> when dealing with smart pointers. Let's get back to our example. Now we have to general approaches to fix our code leak. One is to manually go over the container with a <code>for loop</code> and delete by hand what we have created. Or the other is to use the magical <code>unique_ptr</code> and let that handle everything. Generally, use the smart pointers that are at our disposal.
</p>

</aside>

</section>
<section >

<p>
How to <b><b>really</b></b> erase things from a container
</p>

<ul>
<li>dependent on specific container</li>
<li>erase-remove idiom</li>
<li>normal remove</li>

</ul>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #245361;">// </span><span style="color: #245361;">removes all elements with the value 5 from a vector</span>
<span class="linenr">1: </span>v.erase<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::remove<span style="color: #33859e;">(</span>v.begin<span style="color: #d26937;">()</span>, v.end<span style="color: #d26937;">()</span>, <span style="color: #33859e; font-weight: bold;">5</span><span style="color: #33859e;">)</span>, v.end<span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">2: </span><span style="color: #245361;">// </span><span style="color: #245361;">remove all elements with the value 42 from a list</span>
<span class="linenr">3: </span>c.remove<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">42</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">4: </span><span style="color: #245361;">// </span><span style="color: #245361;">remove all elements with the value 68.9 from a map</span>
<span class="linenr">5: </span>m.erase<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">68.9</span><span style="color: #99d1ce;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Why do we need to know that there are 3 types of containers? Many reasons, but one of them is, because this will help us utilize the removal of items in an efficient manner. Every type of container has it's own way to remove elements and there is not general approach, but here are some guidelines. If you have a <code>string</code>, <code>vector</code>, or a <code>deque</code> (i.e. a sequential container), then use the <b>erase-remove-idiom</b>. What is the <b>erase-remove-idiom</b>? It's a popular technique for these types of containers where we call the two methods <code>erase()</code> and <code>remove()</code> to delete something. We can see from the example how to use it. <b>Note</b>: that in order to use <code>remove()</code> we must include the <code>&lt;algorithm&gt;</code> library in our code, since the sequential containers don't have such a method.
</p>

<p>
For <b>lists</b>, the situation is different. Although the above will work, there is a better way. You should just use the built in <code>remove</code> method in the list class. In general here is another <b>rule as a bonus</b>: prefer the class specific methods of containers to the same methods in the <code>algorithm</code> file. This is much more efficient.
</p>

<p>
For <b>associative containers</b> however things are different. We should never use anything that has the word <b>remove</b> as a way to delete elements from the container. This will probably lead to data corruption and in-proper element removal. Also such container don't even have a method called <code>remove()</code>. Instead we should use the <code>erase()</code> method and it will work just fine.
</p>

<p>
In general the <b>erase-remove idiom</b> should work for most things, but with little experimenting you will get the hang of things.
</p>

</aside>

</section>
<section >

<p>
What about if we have a conditional?
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #245361;">// </span><span style="color: #245361;">removes all elements with the value 5 from a vector</span>
<span class="linenr">1: </span>v.erase<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::remove<span style="color: #33859e;">(</span>v.begin<span style="color: #d26937;">()</span>, v.end<span style="color: #d26937;">()</span>, <span style="color: #33859e; font-weight: bold;">5</span><span style="color: #33859e;">)</span>, v.end<span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">2: </span><span style="color: #245361;">// </span><span style="color: #245361;">remove all elements with the value 42 from a list</span>
<span class="linenr">3: </span>c.remove<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">42</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">4: </span><span style="color: #245361;">// </span><span style="color: #245361;">remove all elements with the value 68.9 from a map</span>
<span class="linenr">5: </span>m.erase<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">68.9</span><span style="color: #99d1ce;">)</span>;
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org49eae88">
<h2 id="org49eae88">Exercises</h2>

</section>
</section>
<section>
<section id="slide-org1bd0a89">
<h2 id="org1bd0a89">Resources</h2>
<div class="outline-text-2" id="text-org1bd0a89">
</div>
</section>
</section>
<section>
<section id="slide-org2e884ec">
<h3 id="org2e884ec">Templates</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/29298212/what-is-an-implicit-interface">Implicit Interface</a></li>
<li><a href="https://stackoverflow.com/questions/1881468/what-is-compile-time-polymorphism-and-why-does-it-only-apply-to-functions">Compile-time polymorphism</a></li>
<li><a href="http://advancedcpp.livejournal.com/728.html">Compile-time polymorphism 2</a></li>
<li><a href="https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html">Mixins</a></li>
<li><a href="https://stackoverflow.com/questions/18773367/what-are-mixins-as-a-concept">Mixins 2</a></li>
<li><a href="https://stackoverflow.com/questions/7085265/what-is-c-mixin-style">Mixins 3</a></li>
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Curiously_Recurring_Template_Pattern">Mixins 4</a></li>
<li><a href="http://www.thinkbottomup.com.au/site/blog/C%20%20_Mixins_-_Reuse_through_inheritance_is_good">Mixins 5</a></li>
<li><a href="https://yanniss.github.io/practical-fmtd.pdf">Mixins 6</a></li>
<li><a href="https://web.archive.org/web/20060619131004/http://blogs.msdn.com/slippman/archive/2004/08/11/212768.aspx">Typename why do we have it</a></li>
<li><a href="https://stackoverflow.com/questions/2023977/difference-of-keywords-typename-and-class-in-templates">Typename and class</a></li>
<li><a href="https://stackoverflow.com/questions/2023977/difference-of-keywords-typename-and-class-in-templates">Difference between typename and class</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
