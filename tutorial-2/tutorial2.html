<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Templates and STL</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Templates and STL</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-01-22 пн 11:12</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org3b421ed">Generics in C++</a></li>
<li><a href="#/slide-org680ecb1">Template programming</a></li>
<li><a href="#/slide-org4d37b48">The STL</a></li>
<li><a href="#/slide-orgb6e407d">Exercises</a></li>
<li><a href="#/slide-org9ee2aeb">Resources</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-org3b421ed">
<h2 id="org3b421ed">Generics in C++</h2>
<aside class="notes">
<p>
One of the things that C++ manages to do very well is to provide generic programming to us. The <b>STL</b> is one of the best functionalities that have been ever made in the language. <code>Vectors</code>, <code>lists</code>, <code>for_each</code>, and many many more containers are available to use to shorten our code, make it more understandable, and make it independent from types! The C++ template mechanism was also Turing complete (you can compute any computable value with it), which led to template meta programming. With this tutorial we will go over what templates can do, how we can use them (and when) and then we will concentrate on the STL.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org680ecb1">
<h2 id="org680ecb1">Template programming</h2>
<ul>
<li class="fragment roll-in">Templates</li>
<li class="fragment roll-in">Compile-time polymorphism</li>
<li class="fragment roll-in"><code>typename</code>, <code>class</code>, <code>typedef</code></li>
<li class="fragment roll-in">Template Meta Programming</li>

</ul>

</section>
</section>
<section>
<section id="slide-org940e54c">
<h3 id="org940e54c">Templates</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #d26937;">T</span> <span style="color: #599cab;">GetMax</span> <span style="color: #99d1ce;">(</span><span style="color: #d26937;">T</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">T</span> <span style="color: #599cab;">b</span><span style="color: #99d1ce;">)</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e;">(</span>a &gt; b ? a : b<span style="color: #33859e;">)</span>;
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span><span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">doProcessing</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">T</span>&amp; <span style="color: #599cab;">w</span><span style="color: #99d1ce;">)</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>w.size<span style="color: #d26937;">()</span> &gt; <span style="color: #33859e; font-weight: bold;">10</span> &amp;&amp; w != someObject<span style="color: #33859e;">)</span>
<span class="linenr">4: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">5: </span>        <span style="color: #d26937;">T</span> <span style="color: #599cab;">temp</span><span style="color: #d26937;">(</span>w<span style="color: #d26937;">)</span>;
<span class="linenr">6: </span>        temp.normalize<span style="color: #d26937;">()</span>;
<span class="linenr">7: </span>        temp.swap<span style="color: #d26937;">(</span>w<span style="color: #d26937;">)</span>;
<span class="linenr">8: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">9: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
There is a good chance that you will not be dealing with a lot of template code in C++ and that's okay. But it is still a good idea to be able to understand and write templates in C++. In fact, compared to Java or C#, C++ has more flexibility when it comes to writing such code (although this isn't always good). So what are templates? They are just something that can be substituted for something else during run-time. It allows us to greatly reuse code, abstracts us from dealing with types, but at the same time, it makes executables larger, and sometimes slower.
</p>

<p>
Okay so let's look at a template.
</p>

<p>
In the first piece of code, we have a template function that returns the larger of the two types. These types can be literally anything - they can by <code>int</code>, <code>double</code>, <code>char</code>, <code>someObject</code>, etc. As long as the type <code>T</code> has an implementation of <code>&gt;</code>, this will compile and this will run. In the second example we can see even clearer when we say that some template must support something. We are passing <code>w</code> by reference (so maybe it's an object). The parameter uses the <code>size()</code>, <code>normalize()</code>, and <code>swap()</code> functions (okay, it's an object). We also have the operator <code>!=</code> in use, and we also have a copy constructor. If we were to just substitute <code>T&amp; w</code> with <code>SpecificObject&amp; w</code>, we would not worry that <code>w</code> supports all of these functionalities, because we have explicitly stated what we are passing. But since we are using a template, we are <b>expecting</b> that <code>T</code> supports them. This is the meaning of an <b>implicit</b> interface. Writing templates means that we are dealing with implicit interfaces in the first place.
</p>

<p>
It's okay not to stress it that much when we are writing generic functions, which are designed to handle build-in types (such as <code>int</code> and <code>double</code>), but when we are working with user defined types, we have to be careful what the function is actually doing, and does it support the interface.
</p>

<p>
One thing to consider when dealing with implicit interfaces is that it's not important whether what the function we are using does what it has to do. This means that when we call <code>w.size()</code>, this might return some integer indicating the size of <code>w</code>, but it might not, it might not ever return a number! As long as the function call returns something that can be used with the <code>&gt;</code> operator, this code will compile! Maybe the function is defined in some base class where it is inherited, everything is valid as long as the next operator runs. The same is true for the <code>!=</code> operator. It can take a type <code>X</code> and a type <code>Y</code> and as long as <b><b>T</b></b> is convertable to <b><b>X</b></b> and <b><b>someObject</b></b> to <b><b>Y</b></b>, the statement will run. So we can say that implicit interfaces are just a set of valid expressions, which impose some constraints. So the constraint of the whole expression doesn't really matter of the types used in it as long as the final yielded result is compatible with <code>bool</code>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org6f4299e">
<h3 id="org6f4299e">Compile-time polymoprhism</h3>
<aside class="notes">
<p>
Okay we get what an implicit interface is. But next to this there is another very important aspect of templates and that is <b><b>compile-time polymorphism</b></b>. Sounds scary, it's not. You've most probably have used this and in the world of normal functions this is also known as <b>function overloading</b>. There is a debate whether this should also be referred to as polymorphism, but it is what it is. Now where do templates come along in this? Much similar to overloading, when we are declaring multiple templates, we can specify at some point in our code what the template will be (i.e. what type). Since we are telling the compiler the type, during compile time, the type of the template used will be mapped in the object file and will resolve at that time. In contrast to dynamic binding, where during runtime it is decided which function is called, the compiler knows based on the types we use what to substituted for when a function is called.
</p>

</aside>

</section>
<section >

</section>
</section>
<section>
<section id="slide-org38e4e20">
<h4 id="org38e4e20">The Mixin idiom</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MixinClass</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">T</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">code</span>
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MixinBase</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span> :
<span class="linenr"> 3: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">f</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span> <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"HELLO"</span> &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl; <span style="color: #33859e;">}</span>;
<span class="linenr"> 4: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Mixin</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">T</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">10: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">f</span><span style="color: #33859e;">()</span> 
<span class="linenr">11: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">12: </span>        <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"call from mixin f method"</span> &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">13: </span>        <span style="color: #33859e; font-weight: bold;">T</span>::f<span style="color: #d26937;">()</span>;
<span class="linenr">14: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">15: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">16: </span>
<span class="linenr">17: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">18: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Mixin2</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">T</span>
<span class="linenr">19: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">20: </span><span style="color: #195466; font-weight: bold;">public</span> :
<span class="linenr">21: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">g</span><span style="color: #33859e;">()</span> 
<span class="linenr">22: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">23: </span>        <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"call from mixin2 g method"</span> &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">24: </span>        <span style="color: #33859e; font-weight: bold;">T</span>::f<span style="color: #d26937;">()</span>;
<span class="linenr">25: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">26: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">27: </span>
<span class="linenr">28: </span><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span><span style="color: #99d1ce;">()</span>
<span class="linenr">29: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">30: </span>    <span style="color: #d26937;">Mixin2</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">Mixin</span> <span style="color: #d26937;">&lt;</span><span style="color: #d26937;">MixinBase</span><span style="color: #d26937;">&gt;</span> <span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">mix</span>;
<span class="linenr">31: </span>    mix.g<span style="color: #33859e;">()</span>;
<span class="linenr">32: </span>
<span class="linenr">33: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr">34: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Now that we know about implicit interfaces and the fact that template must support the interface in the method body, we can talk about one of the most useful concepts in C++, which is the <b><b>Mixin</b></b>.
</p>

<p>
Mixins are a great way to reuse code and overcome come implementational problems that <b>composition and delegation</b> and <b>inheritance-based-reuse</b> bring. From a syntactic point of view this is a <code>mixin</code>. This is a template class that inherits from the type of the template. Simple enough, but why is this important? Well, mixins are like putting all of the reusable code in the derived class (instead of the conventional way of putting the reusable code in the base class). Basically, mixins are small classes that implement a very specific functionality for another class, through a specified class that provides the specific features the functionality needs.More abstractly speaking, mixins are small fragments of a class that are intended to be composed with other classes. Let's say we are trying to model something, we start writing our code and implement all of our classes and hierarchies normally as we know, at which point we have several classes, orthogonal to each other (<code>decoupled</code>). We might have some common interface between those classes and at that point we inherit from that interface. We writing our explicit implementation of what we have inherited. Everything seems fine, but the problem with this design is that we do not have an easy way to combine our modeled classes with each other. This is where mixins come in play. They allow us to create primitive classes that are used as building blocks. We can plug in any class we want into them and get the functionality we desire, while keeping the classes orthogonal to each other.
</p>

<p>
From the example we can see how a mixin can be used to <b>"plug-in"</b> classes together and get some functionality out of them. The code works like this - we create an object that is combined from a base class that just outputs a string and two other mixin classes. At this point we can see how we are usgin multiple inheritance, i.e. inhereting from the template class. We can simply traverse the output of the program and see how using the <code>g()</code> method we get the output of the <code>Mixin2</code> class, which, then using the template <code>T</code> calls the <code>f()</code> method. Since that <code>T</code> is of type <code>Mixin</code>, we go to that class and execute <code>f()</code>. In that method call we also have another <code>f()</code>, but this time the <code>T</code> of the template is of type <code>MixinBase</code>. Sort of a long traversal, but nothing too complicated. This is how we use mixins in the simplest form. Now let's look at a more practical example.
</p>

<p>
Remember, don't use mixins unless your programs needs them. Although their versatility, they bring complexity to the whole structure.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org653aae4">
<h3 id="org653aae4"><code>typename</code>, <code>class</code>, <code>typedef</code></h3>
<aside class="notes">
<p>

</p>

</aside>

</section>
</section>
<section>
<section id="slide-org95d4fdc">
<h3 id="org95d4fdc">Meta Programming</h3>
<aside class="notes">
<p>

</p>

</aside>

</section>
</section>
<section>
<section id="slide-org4d37b48">
<h2 id="org4d37b48">The STL</h2>
<ul>
<li class="fragment roll-in">Vectors and strings</li>
<li class="fragment roll-in">Maps and sets</li>
<li class="fragment roll-in">Lambda functions</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgb6e407d">
<h2 id="orgb6e407d">Exercises</h2>

</section>
</section>
<section>
<section id="slide-org9ee2aeb">
<h2 id="org9ee2aeb">Resources</h2>
<div class="outline-text-2" id="text-org9ee2aeb">
</div>
</section>
</section>
<section>
<section id="slide-orgc1e0a5e">
<h3 id="orgc1e0a5e">Templates</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/29298212/what-is-an-implicit-interface">Implicit Interface</a></li>
<li><a href="https://stackoverflow.com/questions/1881468/what-is-compile-time-polymorphism-and-why-does-it-only-apply-to-functions">Compile-time polymorphism</a></li>
<li><a href="http://advancedcpp.livejournal.com/728.html">Compile-time polymorphism 2</a></li>
<li><a href="https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html">Mixins</a></li>
<li><a href="https://stackoverflow.com/questions/18773367/what-are-mixins-as-a-concept">Mixins 2</a></li>
<li><a href="https://stackoverflow.com/questions/7085265/what-is-c-mixin-style">Mixins 3</a></li>
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Curiously_Recurring_Template_Pattern">Mixins 4</a></li>
<li><a href="http://www.thinkbottomup.com.au/site/blog/C%20%20_Mixins_-_Reuse_through_inheritance_is_good">Mixins 5</a></li>
<li><a href="https://yanniss.github.io/practical-fmtd.pdf">Mixins 6</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
