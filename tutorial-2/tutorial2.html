<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Templates and STL</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Templates and STL</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-01-18 чт 18:58</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org4477f43">Generics in C++</a></li>
<li><a href="#/slide-orgc7c93dd">Template programming</a></li>
<li><a href="#/slide-org6265f6b">The STL</a></li>
<li><a href="#/slide-orgd1c09c8">Exercises</a></li>
<li><a href="#/slide-org28344e4">Resources</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-org4477f43">
<h2 id="org4477f43">Generics in C++</h2>
<aside class="notes">
<p>
One of the things that C++ manages to do very well is to provide generic programming to us. The <b>STL</b> is one of the best functionalities that have been ever made in the language. <code>Vectors</code>, <code>lists</code>, <code>for_each</code>, and many many more containers are available to use to shorten our code, make it more understandable, and make it independent from types! The C++ template mechanism was also Turing complete (you can compute any computable value with it), which led to template meta programming. With this tutorial we will go over what templates can do, how we can use them (and when) and then we will concentrate on the STL.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc7c93dd">
<h2 id="orgc7c93dd">Template programming</h2>
<ul>
<li class="fragment roll-in">Templates</li>
<li class="fragment roll-in">Compile-time polymorphism</li>
<li class="fragment roll-in"><code>typename</code>, <code>class</code>, <code>typedef</code></li>
<li class="fragment roll-in">Template Meta Programming</li>

</ul>

</section>
</section>
<section>
<section id="slide-org2153ada">
<h3 id="org2153ada">Templates</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #d26937;">T</span> <span style="color: #599cab;">GetMax</span> <span style="color: #99d1ce;">(</span><span style="color: #d26937;">T</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">Y</span> <span style="color: #599cab;">b</span><span style="color: #99d1ce;">)</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e;">(</span>a &gt; b ? a : b<span style="color: #33859e;">)</span>;x
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span><span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">doProcessing</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">T</span>&amp; <span style="color: #599cab;">w</span><span style="color: #99d1ce;">)</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>w.size<span style="color: #d26937;">()</span> &gt; <span style="color: #33859e; font-weight: bold;">10</span> &amp;&amp; w != someNastyWidget<span style="color: #33859e;">)</span>
<span class="linenr">4: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">5: </span>        <span style="color: #d26937;">T</span> <span style="color: #599cab;">temp</span><span style="color: #d26937;">(</span>w<span style="color: #d26937;">)</span>;
<span class="linenr">6: </span>        temp.normalize<span style="color: #d26937;">()</span>;
<span class="linenr">7: </span>        temp.swap<span style="color: #d26937;">(</span>w<span style="color: #d26937;">)</span>;
<span class="linenr">8: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">9: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
There is a good chance that you will not be dealing with a lot of template code in C++ and that's okay. But it is still a good idea to be able to understand and write templates in C++. In fact, compared to Java or C#, C++ has more flexibility when it comes to writing such code (although this isn't always good). So what are templates? They are just something that can be substituted for something else during run-time. It allows us to greatly reuse code, abstracts us from dealing with types, but at the same time, it makes executables larger, and sometimes slower.
</p>

<p>
Okay so let's look at a template.
</p>

<p>
In the first piece of code, we have a template function that returns the larger of the two types. These types can be literally anything - they can by <code>int</code>, <code>double</code>, <code>char</code>, <code>someobject</code>, etc. As long as the type <code>T</code> has an implementation of <code>&gt;</code>, this will compile and this will run. In the second example we can see even clearer when we say that some template must support something. We are passing <code>w</code> by reference (so maybe it's an object). The parameter uses the <code>size()</code>, <code>normalize()</code>, and <code>swap()</code> functions (okay, it's an object). We also have the operator <code>!=</code> in use, and we also have a copy constructor. If we were to just substitute <code>T&amp; w</code> with <code>SpecificObject&amp; w</code>, we would not worry that <code>w</code> supports all of these functionalities, because we have explicitly stated what we are passing. But since we are using a template, we are <b>expecting</b> that <code>T</code> supports them. This is the meaning of an <b>implicit</b> interface. Writing templates means that we are dealing with implicit interfaces in the first place.
</p>

<p>
It's okay not to stress it that much when we are writing generic functions, which are designed to handle build-in types (such as <code>int</code> and <code>double</code>), but when we are working with user defined types, we have to be careful what the function is actually doing, and does it support the interface.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org776b5fd">
<h3 id="org776b5fd">Compile-time polymoprhism</h3>
<aside class="notes">
<p>

</p>

</aside>

</section>
</section>
<section>
<section id="slide-org6265f6b">
<h2 id="org6265f6b">The STL</h2>
<ul>
<li class="fragment roll-in">Vectors and strings</li>
<li class="fragment roll-in">Maps and sets</li>
<li class="fragment roll-in"></li>

<li class="fragment roll-in">Lambda functions</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgd1c09c8">
<h2 id="orgd1c09c8">Exercises</h2>

</section>
</section>
<section>
<section id="slide-org28344e4">
<h2 id="org28344e4">Resources</h2>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
