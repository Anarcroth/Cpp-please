<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Templates and STL</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Templates and STL</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-01-19 пт 22:25</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org15e3fbb">Generics in C++</a></li>
<li><a href="#/slide-org347ff71">Template programming</a></li>
<li><a href="#/slide-orgdff3cf9">The STL</a></li>
<li><a href="#/slide-org23b24af">Exercises</a></li>
<li><a href="#/slide-orga16a0f3">Resources</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-org15e3fbb">
<h2 id="org15e3fbb">Generics in C++</h2>
<aside class="notes">
<p>
One of the things that C++ manages to do very well is to provide generic programming to us. The <b>STL</b> is one of the best functionalities that have been ever made in the language. <code>Vectors</code>, <code>lists</code>, <code>for_each</code>, and many many more containers are available to use to shorten our code, make it more understandable, and make it independent from types! The C++ template mechanism was also Turing complete (you can compute any computable value with it), which led to template meta programming. With this tutorial we will go over what templates can do, how we can use them (and when) and then we will concentrate on the STL.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org347ff71">
<h2 id="org347ff71">Template programming</h2>
<ul>
<li class="fragment roll-in">Templates</li>
<li class="fragment roll-in">Compile-time polymorphism</li>
<li class="fragment roll-in"><code>typename</code>, <code>class</code>, <code>typedef</code></li>
<li class="fragment roll-in">Template Meta Programming</li>

</ul>

</section>
</section>
<section>
<section id="slide-org1157cb0">
<h3 id="org1157cb0">Templates</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #d26937;">T</span> <span style="color: #599cab;">GetMax</span> <span style="color: #99d1ce;">(</span><span style="color: #d26937;">T</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">T</span> <span style="color: #599cab;">b</span><span style="color: #99d1ce;">)</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e;">(</span>a &gt; b ? a : b<span style="color: #33859e;">)</span>;
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span><span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">doProcessing</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">T</span>&amp; <span style="color: #599cab;">w</span><span style="color: #99d1ce;">)</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>w.size<span style="color: #d26937;">()</span> &gt; <span style="color: #33859e; font-weight: bold;">10</span> &amp;&amp; w != someObject<span style="color: #33859e;">)</span>
<span class="linenr">4: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">5: </span>        <span style="color: #d26937;">T</span> <span style="color: #599cab;">temp</span><span style="color: #d26937;">(</span>w<span style="color: #d26937;">)</span>;
<span class="linenr">6: </span>        temp.normalize<span style="color: #d26937;">()</span>;
<span class="linenr">7: </span>        temp.swap<span style="color: #d26937;">(</span>w<span style="color: #d26937;">)</span>;
<span class="linenr">8: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">9: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
There is a good chance that you will not be dealing with a lot of template code in C++ and that's okay. But it is still a good idea to be able to understand and write templates in C++. In fact, compared to Java or C#, C++ has more flexibility when it comes to writing such code (although this isn't always good). So what are templates? They are just something that can be substituted for something else during run-time. It allows us to greatly reuse code, abstracts us from dealing with types, but at the same time, it makes executables larger, and sometimes slower.
</p>

<p>
Okay so let's look at a template.
</p>

<p>
In the first piece of code, we have a template function that returns the larger of the two types. These types can be literally anything - they can by <code>int</code>, <code>double</code>, <code>char</code>, <code>someObject</code>, etc. As long as the type <code>T</code> has an implementation of <code>&gt;</code>, this will compile and this will run. In the second example we can see even clearer when we say that some template must support something. We are passing <code>w</code> by reference (so maybe it's an object). The parameter uses the <code>size()</code>, <code>normalize()</code>, and <code>swap()</code> functions (okay, it's an object). We also have the operator <code>!=</code> in use, and we also have a copy constructor. If we were to just substitute <code>T&amp; w</code> with <code>SpecificObject&amp; w</code>, we would not worry that <code>w</code> supports all of these functionalities, because we have explicitly stated what we are passing. But since we are using a template, we are <b>expecting</b> that <code>T</code> supports them. This is the meaning of an <b>implicit</b> interface. Writing templates means that we are dealing with implicit interfaces in the first place.
</p>

<p>
It's okay not to stress it that much when we are writing generic functions, which are designed to handle build-in types (such as <code>int</code> and <code>double</code>), but when we are working with user defined types, we have to be careful what the function is actually doing, and does it support the interface.
</p>

<p>
One thing to consider when dealing with implicit interfaces is that it's not important whether what the function we are using does what it has to do. This means that when we call <code>w.size()</code>, this might return some integer indicating the size of <code>w</code>, but it might not, it might not ever return a number! As long as the function call returns something that can be used with the <code>&gt;</code> operator, this code will compile! Maybe the function is defined in some base class where it is inherited, everything is valid as long as the next operator runs. The same is true for the <code>!=</code> operator. It can take a type <code>X</code> and a type <code>Y</code> and as long as <b><b>T</b></b> is convertable to <b><b>X</b></b> and <b><b>someObject</b></b> to <b><b>Y</b></b>, the statement will run. So we can say that implicit interfaces are just a set of valid expressions, which impose some constraints. So the constraint of the whole expression doesn't really matter of the types used in it as long as the final yielded result is compatible with <code>bool</code>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orga6fe709">
<h3 id="orga6fe709">Compile-time polymoprhism</h3>
<aside class="notes">
<p>
Okay we get what an implicit interface is. But next to this there is another very important aspect of templates and that is <b><b>compile-time polymorphism</b></b>. Sounds scary, it's not. You've most probably have used this and in the world of normal functions this is also known as <b>function overloading</b>. There is a debate whether this should also be referred to as polymorphism, but it is what it is. Now where do templates come along in this? Much similar to overloading, when we are declaring multiple templates, we can specify at some point in our code what the template will be (i.e. what type). Since we are telling the compiler the type, during compile time, the type of the template used will be mapped in the object file and will resolve at that time. In contrast to dynamic binding, where during runtime it is decided which function is called, the compiler knows based on the types we use what to substituted for when a function is called.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgdff3cf9">
<h2 id="orgdff3cf9">The STL</h2>
<ul>
<li class="fragment roll-in">Vectors and strings</li>
<li class="fragment roll-in">Maps and sets</li>
<li class="fragment roll-in">Lambda functions</li>

</ul>

</section>
</section>
<section>
<section id="slide-org23b24af">
<h2 id="org23b24af">Exercises</h2>

</section>
</section>
<section>
<section id="slide-orga16a0f3">
<h2 id="orga16a0f3">Resources</h2>
<div class="outline-text-2" id="text-orga16a0f3">
</div>
</section>
</section>
<section>
<section id="slide-org53dea6d">
<h3 id="org53dea6d">Templates</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/29298212/what-is-an-implicit-interface">Implicit Interface</a></li>
<li><a href="https://stackoverflow.com/questions/1881468/what-is-compile-time-polymorphism-and-why-does-it-only-apply-to-functions">Compile-time polymorphism</a></li>
<li><a href="http://advancedcpp.livejournal.com/728.html">Compile-time polymorphism 2</a></li>
<li><a href="https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html">Mixins</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
