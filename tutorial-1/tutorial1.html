<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>OOP and Inheritance in C++</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">OOP and Inheritance in C++</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-01-08 пн 17:57</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-orga7fc52f">The ++ in Cpp</a></li>
<li><a href="#/slide-orge0763a4">C with classes</a></li>
<li><a href="#/slide-org20c2dd4">References</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-orga7fc52f">
<h2 id="orga7fc52f">The ++ in Cpp</h2>
<ul>
<li>C with classes
<ul>
<li>Classes and Objects</li>
<li>Constructors and Operators</li>
<li>Designs</li>

</ul></li>
<li>Inheritance
<ul>
<li>Inheritance models</li>
<li>Multiple Inheritance</li>
<li>Virtual functions and destructors</li>

</ul></li>
<li>Templates
<ul>
<li>Understanding typename</li>
<li>Meta programming</li>

</ul></li>
<li>Resource Management</li>
<li>Good practices</li>
<li>STL</li>

</ul>

<aside class="notes">
<p>
When C++ first came out it wasn't all that different from C. Apart from having standard object orientation functionalities and inheritance capabilities, the two languages were more or less the same. But overtime C and C++ grew to become very different. In the previous tutorial we looked into how to structure out program in terms of files and how it executes. Now we will dive into the world of OOP in C++, we will revise what was though in the C++ course and will try to build upon that material by giving examples, by running code, and talking about practices for writing better C++. 
</p>

<p>
First we will cover classes. What the classes implement in the background, what to do with constructors, destructors, and operators. We will look over some designs on how to build our classes for maximum utility and efficiency. Then we will go over inheritance and polymorphism, with discussions over the different models, how to use multiple inheritance, what virtual tables are, how to use virtual functions, and so on.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orge0763a4">
<h2 id="orge0763a4">C with classes</h2>
<div class="outline-text-2" id="text-orge0763a4">
</div>
</section>
</section>
<section>
<section id="slide-orgac0d3b2">
<h3 id="orgac0d3b2">Classes and Objects</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Person</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">private</span>: <span style="color: #245361;">// </span><span style="color: #245361;">(Used by default if not specified explicitly) No one can see in here</span>
<span class="linenr"> 3: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">age</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
<span class="linenr"> 6: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">job</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #195466; font-weight: bold;">static</span> <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">Doctor</span> *<span style="color: #599cab;">d</span>;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">void</span> <span style="color: #599cab;">wave</span><span style="color: #33859e;">()</span>;
<span class="linenr">11: </span>
<span class="linenr">12: </span><span style="color: #195466; font-weight: bold;">protected</span>: <span style="color: #245361;">// </span><span style="color: #245361;">Can be seen only by class that is a child</span>
<span class="linenr">13: </span>           <span style="color: #245361;">// </span><span style="color: #245361;">Usually we don't have a use case for protected</span>
<span class="linenr">14: </span>    <span style="color: #d26937;">bool</span> <span style="color: #599cab;">is_married</span>;
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #195466; font-weight: bold;">public</span>: <span style="color: #245361;">// </span><span style="color: #245361;">Everyone can see this part</span>
<span class="linenr">17: </span>    <span style="color: #599cab;">Person</span><span style="color: #33859e;">()</span>;
<span class="linenr">18: </span>    <span style="color: #599cab;">Person</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span><span style="color: #33859e;">)</span>;
<span class="linenr">19: </span>    ~<span style="color: #599cab;">Person</span><span style="color: #33859e;">()</span>;
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">get_name</span><span style="color: #33859e;">()</span>;
<span class="linenr">22: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">get_job</span><span style="color: #33859e;">()</span>;
<span class="linenr">23: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">get_age</span><span style="color: #33859e;">()</span>;
<span class="linenr">24: </span>
<span class="linenr">25: </span>    <span style="color: #d26937;">double</span> <span style="color: #599cab;">calculate_salary</span><span style="color: #33859e;">()</span>;
<span class="linenr">26: </span>
<span class="linenr">27: </span>    <span style="color: #d26937;">bool</span> <span style="color: #599cab;">get_occupation</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> is_married; <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">implicit inline function</span>
<span class="linenr">28: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
This is a basic class. We can see the scopes of the class, what we can have as variables and functions. A quick note here - although we have 3 scopes, the ones we use the most are <code>private</code> and <code>public</code>, while <code>protected</code> is used in seldom cases, so we need not worry about it that much.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0cb26f7">
<h4 id="org0cb26f7">Initialization lists</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Library</span> 
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    ABEntry<span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">name</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">list</span><span style="color: #d26937;">&lt;</span>Books<span style="color: #d26937;">&gt;</span>&amp; <span style="color: #599cab;">books</span><span style="color: #33859e;">)</span>;
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr"> 5: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">theName</span>;
<span class="linenr"> 6: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">list</span><span style="color: #33859e;">&lt;</span>Books<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">books</span>;
<span class="linenr"> 7: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">addressNum</span>;
<span class="linenr"> 8: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #33859e; font-weight: bold;">Library</span>::<span style="color: #599cab;">Library</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">name</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">list</span><span style="color: #33859e;">&lt;</span>Books<span style="color: #33859e;">&gt;</span>&amp; <span style="color: #599cab;">books</span><span style="color: #99d1ce;">)</span>
<span class="linenr">11: </span><span style="color: #245361;">// </span><span style="color: #245361;">Initialization start righ here before the opening bracket</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">13: </span>    theName = name; <span style="color: #245361;">// </span><span style="color: #245361;">these are all assignments</span>
<span class="linenr">14: </span>    theBooks = books;
<span class="linenr">15: </span>    addressNum = <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr">16: </span><span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">This is OK but can be done better</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C"><span class="linenr">0: </span>Library::Library<span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">std</span>::string&amp; name, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">std</span>::list&lt;Books&gt;&amp; books<span style="color: #99d1ce;">)</span>
<span class="linenr">1: </span>: theName<span style="color: #99d1ce;">(</span>name<span style="color: #99d1ce;">)</span>, <span style="color: #245361;">// </span><span style="color: #245361;">These are all now initialized</span>
<span class="linenr">2: </span>  theBooks<span style="color: #99d1ce;">(</span>books<span style="color: #99d1ce;">)</span>, 
<span class="linenr">3: </span>  addressNum<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">0</span><span style="color: #99d1ce;">)</span>
<span class="linenr">4: </span><span style="color: #99d1ce;">{</span> <span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">Empty constructor body</span>
</pre>
</div>

<aside class="notes">
<p>
When we are initializing this object, we would write <code>Person p1</code>, but what would happen with its data members. Will they be initialized to zero or not? We can never be sure about this and sometimes they might be zero, sometimes they might be left <b>uninitialized</b>. If we take the risk and read something that is uninitialized, then we will get an undefined behavior. There are rules to remember when something is initialized to zero and when something is left uninitialized, but this all depends if you are writing the C part of C++ or the STL part and things just get way to complex. That is why we can take the safe approach and just <b>always</b> initialize our object when we create them. If we are just working with normal variables in a function, this would be like writing <code>int x = 0; double b; std::cin &gt;&gt; b; char* x = "pointer intialization"</code> and so on. For object, however, this tasks is left to the constructor. The rule is simple - make sure that everything is initialized when an object is created.
</p>

<p>
In the example we can see that the Library constructor makes 3 assignments to the data members. In C++, the <b>initialization</b> takes place <b>right before</b> we get into the constructor body! This means that in order to make sure that the variables are initialized, we have to put them into an <b>initialization list</b> (how intuitive!). There are several advantages to this approach. First we make sure that we won't have uninitialized data members and will avoid undefined behavior. Secondly, because we are assigning objects (the <code>string</code> and <code>list</code> members) we are avoiding calling their assignment constructors. In the previous code, where we assigned the variables, first we had to initialize the <code>string</code> and <code>list</code> variables, then we had to assign them the new values by calling a copy assignment operator. That's way too much work. But with the initialization list, not such thing needs to happen. The name and the phone are <b>copy-constructed</b> from the passed parameters. This means that only a copy constructor of the <code>string</code> and <code>list</code> is called in order to initialize the data members, and this operations (the copy constructor) is much more efficient than the previous code.
</p>

<p>
If we want to initialize the data members to nothing or we don't have any parameters to pass to the constructor, we can just call the initialization list and leave the brackets empty.
</p>

<p>
There is one little aspect we must note here and that is - we must write the order of our initialization list in the same order we declared our data members in our class. This is just hoe C++ works, we must first initialize <code>theName</code> and then <code>theBooks</code> and the <code>addressNum</code>. If we don't do that we will get an error and undefined behavior.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org86fdca2">
<h4 id="org86fdca2">Static non-local objects defined in different translation units</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">in the filesystem.cpp file</span>
<span class="linenr"> 1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">FileSystem</span>
<span class="linenr"> 2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 3: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 4: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">numDisks</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 6: </span><span style="color: #195466; font-weight: bold;">extern</span> <span style="color: #d26937;">FileSystem</span> <span style="color: #599cab;">tfs</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #245361;">// </span><span style="color: #245361;">in our .cpp file</span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Directory</span> 
<span class="linenr">10: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">12: </span>    Directory<span style="color: #33859e;">(</span><span style="color: #599cab;">params</span><span style="color: #33859e;">)</span>;
<span class="linenr">13: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #33859e; font-weight: bold;">Directory</span>::<span style="color: #599cab;">Directory</span><span style="color: #99d1ce;">(</span>params<span style="color: #99d1ce;">)</span>
<span class="linenr">16: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">17: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">disks</span> = tfs.numDisks<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">we use the tfs object,</span>
<span class="linenr">18: </span>                                        <span style="color: #245361;">// </span><span style="color: #245361;">but we cannot be sure</span>
<span class="linenr">19: </span>                                        <span style="color: #245361;">// </span><span style="color: #245361;">that it is initialized</span>
<span class="linenr">20: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">21: </span>
<span class="linenr">22: </span><span style="color: #d26937;">Directory</span> <span style="color: #599cab;">tempDir</span><span style="color: #99d1ce;">(</span>params<span style="color: #99d1ce;">)</span>;
</pre>
</div>

</section>
<section >

<p>
The solution:
</p>

<div class="org-src-container">

<pre  class="src src-C"><span class="linenr"> 0: </span>FileSystem&amp; tfs<span style="color: #99d1ce;">()</span>         <span style="color: #245361;">// </span><span style="color: #245361;">this replaces the tfs object; it could be</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>                         <span style="color: #245361;">// </span><span style="color: #245361;">static in the FileSystem class</span>
<span class="linenr"> 2: </span>    <span style="color: #195466; font-weight: bold;">static</span> <span style="color: #d26937;">FileSystem</span> <span style="color: #599cab;">fs</span>; <span style="color: #245361;">// </span><span style="color: #245361;">define and initialize a local static object</span>
<span class="linenr"> 3: </span>    <span style="color: #195466; font-weight: bold;">return</span> fs;            <span style="color: #245361;">// </span><span style="color: #245361;">return a reference to it</span>
<span class="linenr"> 4: </span><span style="color: #99d1ce;">}</span>
<span class="linenr"> 5: </span><span style="color: #d26937;">class</span> <span style="color: #599cab;">Directory</span> <span style="color: #99d1ce;">{</span> ... <span style="color: #99d1ce;">}</span>;                  <span style="color: #245361;">// </span><span style="color: #245361;">as before</span>
<span class="linenr"> 6: </span>Directory::Directory<span style="color: #99d1ce;">(</span> params <span style="color: #99d1ce;">)</span>            <span style="color: #245361;">// </span><span style="color: #245361;">as before, except references</span>
<span class="linenr"> 7: </span><span style="color: #99d1ce;">{</span>                                         <span style="color: #245361;">// </span><span style="color: #245361;">to tfs are</span>
<span class="linenr"> 8: </span>    std::size_t disks = tfs<span style="color: #33859e;">()</span>.numDisks<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">now to tfs()</span>
<span class="linenr"> 9: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>Directory&amp; tempDir<span style="color: #99d1ce;">()</span>               <span style="color: #245361;">// </span><span style="color: #245361;">this replaces the tempDir object; it</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">{</span>                                  <span style="color: #245361;">// </span><span style="color: #245361;">could be static in the Directory class</span>
<span class="linenr">13: </span>    <span style="color: #195466; font-weight: bold;">static</span> <span style="color: #d26937;">Directory</span> <span style="color: #599cab;">td</span><span style="color: #33859e;">(</span> params <span style="color: #33859e;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">define/initialize local static object</span>
<span class="linenr">14: </span>    <span style="color: #195466; font-weight: bold;">return</span> td;                     <span style="color: #245361;">// </span><span style="color: #245361;">return reference to it</span>
<span class="linenr">15: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
One final thing that is worth mentioning is the case when we have to initialize non-local static objects from different translation units. What that jumble of words means is that - if we have a static object (an object that has a duration from the beginning of its initialization till the end of the program) and if that object is non-local (it's in the global scope, namespace scope, or in the scope of an other class) and if it's in a translation unit (basically it's a single source file) how do we initialize it? The problem here is that if we use such a static non-local object, we can never ever be sure when it is initialized properly and we are down the road of undefined behavior. The way to overcome such situations is by writing a function that makes that static non-local object a static local object (basically implementing the <b>Singleton</b> design pattern. . . almost). We just need to write a small function in our code, where we define and initialize a static local object of what we need and return a reference to it. This way we make sure that every time the function to get the object is called, the object will <b>always</b> be initialized.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgf32a4dc">
<h3 id="orgf32a4dc">Constructors and Operators</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">Empty class</span>
<span class="linenr"> 1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">A</span> <span style="color: #99d1ce;">{}</span>;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">Empty class again</span>
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">A</span> 
<span class="linenr"> 5: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 6: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 7: </span>    <span style="color: #599cab;">A</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span>             <span style="color: #245361;">// </span><span style="color: #245361;">constructor</span>
<span class="linenr"> 8: </span>    <span style="color: #599cab;">A</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">A</span>&amp; <span style="color: #599cab;">rhs</span><span style="color: #33859e;">)</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">copy constructor</span>
<span class="linenr"> 9: </span>    ~<span style="color: #599cab;">A</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span>            <span style="color: #245361;">// </span><span style="color: #245361;">destructor</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #d26937;">A</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">A</span>&amp; <span style="color: #599cab;">rhs</span><span style="color: #33859e;">)</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">copy assingment operator</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
All of the classes we write have at least several constructors in them which will be either user defined or put in the class by the compiler. Sometimes we don't have to explicitly tell C++ what kind of constructors we want, because our program doesn't requite such functionality, but sometimes we have to implement our own constructors and operators (<b>operator overloading</b>). It's a good thing to know that the compiler is implementing instead of us when we are not writing the constructors ourselves.
</p>

<p>
Let's take this example for instance. Here we have a class that has nothing in it and we have a class that has four constructors implemented. There is virtually no difference between writing the empty class without constructors and the one with the 3 ctors and one operator implemented. The 3 cotrs and 1 operator that we will always have by default are - a default constructor, default destructor, copy constructor, and a copy assignment operator. In general there isn't much difference between what you will write as an implementation and what the compiler will write for there things, but keep in mind that in some specific cases you will be forced to write your own constructors. This will be the case when you have some constants and/or some references in your class. Why references? Because when you are copying an instance and you have a pointer in it, you would want to copy what the pointer points to (its content) and not the pointer only. And the case for <code>const</code> is that you would want to keep <b>const correctness</b> when copying. This is not a problem if our class has normal data members.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span><span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">NamedObject</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">4: </span>    <span style="color: #599cab;">NamedObject</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">name</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">T</span>&amp; <span style="color: #599cab;">value</span><span style="color: #33859e;">)</span>;
<span class="linenr">5: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">6: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">nameValue</span>;
<span class="linenr">7: </span>    <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">T</span> <span style="color: #599cab;">objectValue</span>;
<span class="linenr">8: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
In this case when we have a reference, we just have to make sure that we are implementing a <b>deep</b> copy when we are writing the constructor or operator. But if our class has a <code>const</code> then we are in trouble. Because we cannot change the value of the initial object we want to re-assign, we cannot implement a proper copy assignment operator. In the case with the constant data member, a default copy assignment operator will not be implemented, and if we were to implement one of our own, we would not copy the <code>const</code> data members.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orge0665c6">
<h3 id="orge0665c6">Designs</h3>
<div class="outline-text-3" id="text-orge0665c6">
</div>
</section>
</section>
<section>
<section id="slide-org064c720">
<h4 id="org064c720">Write OOP classes</h4>

</section>
</section>
<section>
<section id="slide-org2e3c7d0">
<h4 id="org2e3c7d0">Treat class design as type design</h4>
<ul>
<li class="fragment roll-in">How should objects of your new type be created and destroyed?</li>
<li class="fragment roll-in">How should object initialization differ from object assignment?</li>
<li class="fragment roll-in">What are the restrictions on legal values for your new type?</li>
<li class="fragment roll-in">What operators and functions make sense for the new type?</li>
<li class="fragment roll-in">What standard functions should be disallowed?</li>
<li class="fragment roll-in">Who should have access to the members of your new type?</li>
<li class="fragment roll-in">Is a new type really what you need?</li>

</ul>

<aside class="notes">
<p>
One of the things that will happen when you are writing your FDS project is that you won't have an idea what to do in the beginning and how to start. Hence you will hesitate how to build your classes and what to do with them.
</p>

<p>
Writing classes isn't easy, because in C++ we are not creating only a class, but we are also creating a <b>user type</b>. This means that we have to take care of what that type must to do and what it must <b>not</b> do. That's why we can ask ourselves the following question in order to get a better grip of the classes we are writing. In consequence we will get a better understanding of the program we are writing.
</p>

<p>
<b>How should objects of your new type be created and destroyed?</b> - How this is done influences the design of your class’s constructors and destructor, as well as its memory allocation and deallocation functions.
</p>

<p>
<b>How should object intialization differ from object assignment?</b> - The answer to this question determines the behavior of and the differences between your constructors and your assignment operators. It’s important not to confuse initialization with assignment, because they correspond to different function calls.
</p>

<p>
<b>What are the restrictions on legal values for your new type?</b> - Usually, only some combinations of values for a class’s data members are valid. Those combinations determine the invariants your class will have to maintain. The invariants determine the error checking you’ll have to do inside your member functions, especially your constructors, assignment operators, and “setter” functions. It may also affect the exceptions your functions throw and, on the off chance you use them, your functions’ exception specifications.
</p>

<p>
<b>What operators and functions make sense for the new type?</b> - The answer to this question determines which functions you’ll declare for your class. Some functions will be member functions, but some will not.
</p>

<p>
<b>What standard functions should be disallowed?</b> - Those are the ones you’ll need to declare private.
</p>

<p>
<b>Who should have access to the members of your new type?</b> - This question helps you determine which members are public, which are protected, and which are private. It also helps you determine which classes and/or functions should be friends, as well as whether it makes sense to nest one class inside another.
</p>

<p>
<b>Is a new type really what you need?</b> If you’re defining a new derived class only so you can add functionality to an existing class, perhaps you’d better achieve your goals by simply defining one or more non-member functions or templates.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgf57ff61">
<h4 id="orgf57ff61">Prefer pass-by-reference-to-const to pass-by-value</h4>

</section>
</section>
<section>
<section id="slide-org20c2dd4">
<h2 id="org20c2dd4">References</h2>
<ul>
<li><a href="http://www.cplusplus.com/articles/y8hv0pDG/">Copy constructors, assignment operators, and exception safe assignment</a></li>
<li><a href="http://www.drdobbs.com/the-problem-with-const-data-members/184403306">The Problem with const Data Members</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/copy_assignment">Copy assignment</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
