<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>C++ a more in depth look into the language</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">C++ a more in depth look into the language</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-01-10 ср 20:43</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org30fa48e">Who am I?</a></li>
<li><a href="#/slide-org9612fa9">What we are going to cover</a></li>
<li><a href="#/slide-orgcbf67ea">File structure</a></li>
<li><a href="#/slide-org7ffa50e">The ++ in Cpp</a></li>
<li><a href="#/slide-org17f86b8">C with classes</a></li>
<li><a href="#/slide-orgade3b95">Inheritance</a></li>
<li><a href="#/slide-org6d28ab4">References</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-org30fa48e">
<h2 id="org30fa48e">Who am I?</h2>
<ul>
<li>Martin Nestorov</li>
<li>Junior 2nd sem.</li>
<li>I like to type . . . a lot</li>
<li>email: mdn150@aubg.edu</li>
<li>Twitter: @mnestorov</li>

</ul>

</section>
</section>
<section>
<section id="slide-org3ef57fd">
<h3 id="org3ef57fd">Why I chose to make these small tutorials</h3>
<ul>
<li>People seem to have some problems with the transition from C++ to FDS.</li>
<li>I want to help!</li>
<li>I want to also learn!</li>

</ul>

<aside class="notes">
<p>
Over the course of the past several years I found a certain love for C++, but instead of just reading about the language and doing some small experiments with it, I wanted to share my knowledge and to get better at it. Seeing how some students struggle with C++ in the beginning courses, I decided that I can help out. That way not only am I learning more in-depth concepts, but also I am making the lives of students easier (hopefully).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org560484d">
<h3 id="org560484d">How to look at C++</h3>
<p>
C++ as <b>four</b> sub-languages
</p>
<ul>
<li>C</li>
<li>OOP</li>
<li>STL</li>
<li>Templates</li>

</ul>

<aside class="notes">
<p>
There is an old joke about C++ - "How do you shoot yourself in the foot? In C you just shoot yourself in the foot. In C++ you accidentally create a dozen instances of yourself and shoot them all in the foot. Providing emergency medical assistance is impossible since you can't tell which are bitwise copies and which are just pointing at others and saying, "That's me, over there."
</p>

<p>
C++ can sometimes be vary annoying, because we have absolutely no idea how it works and what it does. The fact that having very similar syntax for wildly different things doesn't help either. So instead of just banging our heads until bleeding sets in, we can try to understand a little bit better what is happening with this language and (hopefully) try to minimize <b><b>undefined</b></b> behavior. In fact C++ is that special language where if you don't know that you are doing, the language re-enforces that by acting in a way where it doesn't know what it might do. That's pretty scary. That's why I will try to minimize this effect with these tutorials and help you out to make better C++ programs and to introduce effective methods or writing C++ code.
</p>

<p>
C++ can be generally divided into four sub-categories or sub-languages. It's a daunting task to go over all of these aspects and trying to teach everything, mainly because I can't! But instead I will try to cover some topics that haven't been covered in depth in the C++ lectures and are somewhat elude to the students. Now our list seems like this
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org9612fa9">
<h2 id="org9612fa9">What we are going to cover</h2>
<ul>
<li>File structure</li>
<li>OOP</li>
<li>Inheritance</li>
<li>Templates</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgcbf67ea">
<h2 id="orgcbf67ea">File structure</h2>
<ul>
<li>Advantages:
<ul>
<li>Better code organization</li>
<li>Faster compiling</li>
<li>Separation of <b>implementation</b> from <b>interface</b></li>

</ul></li>

<li>Disadvantages:
<ul>
<li>More complicated structure</li>

</ul></li>

</ul>

<aside class="notes">
<p>
It has come to my attention that many people, while writing their homeworks, neglect the advantages of structuring their <b><b>source</b></b> files. This is most noticeable when they are writing the first 3 FDS homeworks or their FDS project. Being able to properly manage your project into several files and to navigate between them in an optimal and cohesive way will minimize your C++ suffering (and coding experience in general).
</p>

<p>
Now most of you already know this, but there are several great advantages to separating your <b>implementation</b> (cpp) files from your <b>interface</b> (h) files. One advantage is that this will bring code clarity to your program. Instead of navigating through one big <b>400</b> line <code>Source.cpp</code> file, and wondering where that one definition of that object is and then going back to the <code>main()</code> method to fix one line, you will have a nicely structured system. Every class will have it's own implementation and interface file, thus minimizing code searching and optimizing code writing! But that's not all. This separation will allow you to compile your programs even faster. That is, every <b>source</b> file is compiled on its own. When you make a small change in your original 400 line monstrosity, you have to wait for all of that code to <b><b>re-compile</b></b>, but if you have the files separated, you just have to re-compile only the changes files, making waiting time much smaller (naturally this effect can be seen when compiling large programs, while small ones won't have such noticeable impact on time). And lastly, we also gain the benefit of implementation from interface separation.
</p>

<p>
But what we are sacrificing for these benefits is that we are increasing our project complexity. This shouldn't scare us that much, but we do have to keep this in mind - <b><b>We have to limit ourselves not to over layer our program</b></b>.
</p>

<p>
Since most of you are working with Visual Studio, here is how your structure looks like now: Picture 1
</p>

<p>
And here is how you would want it to look: Picture 2
</p>

<p>
Now I am not going to tell you how to add files and where to put them, I will just show you how to properly implement header and source files and how to avoid collisions and also how to stop writing those damn "xfz.h" files.
</p>

<p>
First things first.
What's the difference between headers and sources? Apart from the obvious name difference, header files are considered to be the <b>interface</b> part of the source code, that is, the place where we explain what the program does, but <b>not</b> how it does it. The source (cpp) files are the <b>implementation</b> part, this is where we explain <b>how</b> we implement the interface. Keeping them separate allows us to keep a clean directory and structure and to separate our logic from our implementation.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org5703c9c">
<h3 id="org5703c9c">How to work with headers?</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">iostream</span><span style="color: #99d1ce;">&gt;</span> <span style="color: #245361;">//</span><span style="color: #245361;">header we always include</span>
<span class="linenr"> 1: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"awesomeclass1.h"</span>
<span class="linenr"> 2: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"awesomeclass2.h"</span>
<span class="linenr"> 3: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"awesomeclass3.h"</span> <span style="color: #245361;">// </span><span style="color: #245361;">our own class headers</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span><span style="color: #99d1ce;">()</span>
<span class="linenr"> 6: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 7: </span>    <span style="color: #d26937;">awesomeclass1</span> <span style="color: #599cab;">ac</span>;
<span class="linenr"> 8: </span>    <span style="color: #d26937;">awesomeclass2</span> <span style="color: #599cab;">ac2</span>;
<span class="linenr"> 9: </span>    <span style="color: #d26937;">awesomeclass3</span> <span style="color: #599cab;">ac3</span>;
<span class="linenr">10: </span>
<span class="linenr">11: </span>    ac.do_something<span style="color: #33859e;">(</span>ac2<span style="color: #33859e;">)</span>;
<span class="linenr">12: </span>
<span class="linenr">13: </span>    ac3 = ac;
<span class="linenr">14: </span>
<span class="linenr">15: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr">16: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
So what are header files and what do they do?
</p>

<p>
Header files, usually ending with the <code>*.h</code> file extension (can be also <code>*.hxx</code>, <code>*.hpp</code>, or nothing at all), are code files that are <b><b>included</b></b> in our source files. We can look at header files as code that only serves as the interface to our classes. That is, it holds a declaration which we later on implement and/or include in our source files. Although we will talk about header files and how we <code>#include</code> them later on, what we can say now is that for every header file that is included, the contents of that file are put in the place of the <code>#include</code> keyword. What we can expect header files to do is to hold <b>declarations</b> inside of them. They just tell us what we are going to implement, but not <b>how</b> we are going to implement it (that's the job of the source files).
</p>

<p>
<b><b>NOTE:</b></b> that for the <code>iostream</code> we used angle brackets and for our classes we used quotes. This just means that the header file <b>iostream</b> comes with the compiler and that the linker should look in the system directories for the definition. The quotes indicate that we are providing the header file and that the linker should look at the build directory.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgaa1f9b6">
<h3 id="orgaa1f9b6">Header guards</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">x.h</span>
<span class="linenr"> 1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">x</span> <span style="color: #99d1ce;">{</span> . . . <span style="color: #99d1ce;">}</span>;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">a.h</span>
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">a</span> <span style="color: #99d1ce;">{</span> <span style="color: #d26937;">X</span> <span style="color: #599cab;">x</span> . . . <span style="color: #99d1ce;">}</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #245361;">// </span><span style="color: #245361;">b.h</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">b</span> <span style="color: #99d1ce;">{</span> <span style="color: #d26937;">X</span> <span style="color: #599cab;">x</span> . . . <span style="color: #99d1ce;">}</span>;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #245361;">// </span><span style="color: #245361;">source.cpp</span>
<span class="linenr">10: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"a.h"</span> <span style="color: #245361;">// </span><span style="color: #245361;">include x.h for the first time</span>
<span class="linenr">11: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"b.h"</span> <span style="color: #245361;">// </span><span style="color: #245361;">error! include x.h again!</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #245361;">// </span><span style="color: #245361;">x.h</span>
<span class="linenr">1: </span><span style="color: #c23127;">#if</span><span style="color: #c23127;">n</span><span style="color: #c23127;">def</span> __X_H_INCLUDED__
<span class="linenr">2: </span><span style="color: #c23127;">#define</span> <span style="color: #599cab;">__X_H_INCLUDED__</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">x</span> <span style="color: #99d1ce;">{</span> . . . <span style="color: #99d1ce;">}</span>;
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #c23127;">#endif</span>
</pre>
</div>

<aside class="notes">
<p>
Because we are going to be using a lot of headers in our program, we would need to include all of them. But because these files are actually copied when we <b>include</b> them, we would have several problems. One would be the code duplication. Another one will be the multiple declarations of classes and functions. To overcome this problem we would need to <b>guard</b> our header files in order not to use them more than once in our program. That is why we use the directives <code>#ifndef</code>, <code>#define</code>, and <code>#endif</code>. When we wrap our header file around with these directives, we ensure that the preprocessor will not copy a single file more than once into the source file.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0ce3729">
<h3 id="org0ce3729">Declarations vs Definitions</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">declarations</span>
<span class="linenr"> 1: </span><span style="color: #195466; font-weight: bold;">extern</span> <span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>;
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">extern</span> <span style="color: #d26937;">char</span> <span style="color: #599cab;">b</span>;
<span class="linenr"> 3: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">foo</span>; <span style="color: #245361;">// </span><span style="color: #245361;">extern not allowed for user types</span>
<span class="linenr"> 4: </span><span style="color: #d26937;">double</span> <span style="color: #599cab;">sum</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">double</span>, <span style="color: #d26937;">int</span><span style="color: #99d1ce;">)</span>;  <span style="color: #245361;">// </span><span style="color: #245361;">no need for extern</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #245361;">// </span><span style="color: #245361;">definitions</span>
<span class="linenr"> 7: </span><span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>; <span style="color: #245361;">// </span><span style="color: #245361;">the implementation of a</span>
<span class="linenr"> 8: </span><span style="color: #d26937;">char</span> <span style="color: #599cab;">c</span>; <span style="color: #245361;">// </span><span style="color: #245361;">the implementation of c</span>
<span class="linenr"> 9: </span><span style="color: #d26937;">double</span> <span style="color: #599cab;">div</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">double</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span><span style="color: #99d1ce;">)</span> <span style="color: #99d1ce;">{</span> <span style="color: #195466; font-weight: bold;">return</span> a / x; <span style="color: #99d1ce;">}</span>
<span class="linenr">10: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">foo</span> <span style="color: #99d1ce;">{</span> . . . <span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
I want to take some time now to revisit two old concepts before we continue - namely I want to talk about <b>declarations</b> and <b>definitions</b>. Here we will mention the role of the <b>compiler</b> and <b>linker</b> briefly, but we will cover them later on. Now a <b>declaration</b> introduces an identifier and its type, be that type of a variable, object, or a function. Basically we are saying to the compiler that there is something with this name and this type, but we are not specifying <b>how</b> this specific thing is implemented. This is what the <b>compiler</b> needs in order to make a reference to that declaration. We can imagine the situation where we have a function which we want to use in multiple files in our program, it's just a very useful function, but we don't want to provide the implementation of the function in every source file. That's why we just declare the function, the compiler sees the declaration, makes a reference to it without the need to know its implementation, and then when we build the final executable, the linker links every reference of the declared function to its implementation. If you remember from the C++ course, a function prototype is a declaration.
</p>

<p>
A <b>definition</b> in C++ is when we a define something in its complete form. This means that we need to both declare something and define it at the same time. We actually implement that specific identifier we have declared. When we write functions and give them a function body at the same time, that is a form of definition. When we write <code>int x;</code> we are both declaring and defining the variable <code>x</code>. This means that we are telling the compiler that there is a variable <code>x</code> of type <code>int</code> that is in the global scope in the current source file. It's important to note that giving this variable a value is not necessary in order to define it. But in the examples we have this specific keyword <code>extern</code> that is associated with declarations. What <code>extern</code> does is that it marks the variable and tells the compiler that this is only a declaration and that a definition will be found somewhere else. In general we use <code>extern</code> when we want to declare global variables in header files and <b>define</b> them in some source file.
</p>

<p>
We can <b>declare</b> something as much as we like in as many files as we want, but we can only <b>define</b> something only <b>once</b>. Often when we get errors telling us that something is undefined (this is at linker time), what that means is that we have something declared, but we have not defined its implementation anywhere and we get a <b>missing symbols error</b>. On the other hand when we have multiple definitions of the same thing, the linker is confused as to which specific definition we want and we get a <b>duplicate symbols error</b>.
</p>

<p>
Okay now let us go back to header files.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc364f81">
<h3 id="orgc364f81">How and when to use headers</h3>
<p>
<code>class A</code> ==&gt; (uses) ==&gt; <code>class B</code> 
</p>

<ul>
<li>do nothing if: A makes no references at all to B</li>
<li>do nothing if: The only reference to B is in a friend declaration</li>
<li>forward declare B if: A contains a B pointer or reference: <code>B* b</code>;</li>
<li>forward declare B if: one or more functions has a B <b>object/pointer/reference</b> as a parameter, or as a return type: <code>B MyFunction(B myb)</code>;</li>
<li><code>#include "b.h"</code> if: B is a parent class of A</li>
<li><code>#include "b.h"</code> if: A contains a B object: <code>B b</code>;</li>

</ul>


</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #c23127;">#if</span><span style="color: #c23127;">n</span><span style="color: #c23127;">def</span> __MY_CLASS_H_INCLUDED__
<span class="linenr"> 1: </span><span style="color: #c23127;">#define</span> <span style="color: #599cab;">__MY_CLASS_H_INCLUDED__</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">Forward declare dependencies</span>
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">F</span>;
<span class="linenr"> 5: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">B</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #245361;">// </span><span style="color: #245361;">Include dependencies</span>
<span class="linenr"> 8: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">map</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 9: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"c.h"</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #245361;">// </span><span style="color: #245361;">Our current class</span>
<span class="linenr">12: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MyClass</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">c</span>
<span class="linenr">13: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">14: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">15: </span>  <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">map</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">int</span>, <span style="color: #d26937;">char</span><span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">matrix</span>;  <span style="color: #245361;">// </span><span style="color: #245361;">a map object that is required by our class</span>
<span class="linenr">16: </span>  <span style="color: #d26937;">F</span>* <span style="color: #599cab;">f</span>;                        <span style="color: #245361;">// </span><span style="color: #245361;">F pointer, so forward declare F</span>
<span class="linenr">17: </span>  <span style="color: #d26937;">void</span> <span style="color: #599cab;">Func</span><span style="color: #33859e;">(</span><span style="color: #d26937;">B</span>&amp; <span style="color: #599cab;">b</span><span style="color: #33859e;">)</span>;             <span style="color: #245361;">// </span><span style="color: #245361;">B reference, so forward declare B</span>
<span class="linenr">18: </span>
<span class="linenr">19: </span>  <span style="color: #195466; font-weight: bold;">friend</span> <span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MyFriend</span>;       <span style="color: #245361;">// </span><span style="color: #245361;">friend declaration is not a dependency</span>
<span class="linenr">20: </span>                               <span style="color: #245361;">// </span><span style="color: #245361;">don't do anything about MyFriend</span>
<span class="linenr">21: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">22: </span><span style="color: #c23127;">#endif</span>
</pre>
</div>

<aside class="notes">
<p>
At this point, after we are revised what declarations and definitions are, we can talk about how to use headers and in which situations this is a viable option. The very short answer is - use header files when you have a class, a grouping of functions that do similar things, or a grouping of global variables. In general this approach is not bad and will frailly well for you, but we shouldn't stop here. That's just the surface of it, to dig deeper we have to understand in which situations we can use header files and when to use forward declarations.
</p>

<p>
Let's imagine that we will be writing a lot of classes, where there will be a lot of dependencies. So when we talk about header files and using multiple classes we are also talking about dependencies between classes (this may also mean just a grouping of functions, but for simplicity reasons, we will refer to a header file as being a single class that does one thing). As an example, a derived class will always be dependent of its parent class, which means that we must be aware of the parent class at compile time, so we can use the derived class (such a case will be when we have a <b>public</b> inheritance between two classes). There are two general forms of dependencies - one is, that there will be things that can be <b>forward declared</b>, and the other is, that things need to be <code>#include</code>-ed. Let's take an example with the following. Image we have class <code>A</code>, which uses class <code>B</code>. This makes A dependent on B. To decide if we need to <b>forward declare</b> or to include A depends on what the interaction between the two classes is.
</p>

<p>
Some explanation is required here. First of we are protecting our class with the header guards. Then we are forward declaring two classes <code>F</code> and <code>B</code>. This means that we are telling the compiler that there is a user type class called <b>F</b> and <b>B</b> and that the implementation of the classes are somewhere else. This allows us to access the methods and variables of <b>F</b> and <b>B</b> without needing to specify their implementation. Forward declarations can be useful, because they can reduce compilation time. If we just want to access and use one or two functions from a class, instead of including the whole class (and copying its contents to the current file) we can just forward declare it and save ourselves some time.
</p>

<p>
In general we want to remember this simple rule - prefer forward declarations to includes, in order to save compilation time and circular dependency issues. The benefits to these rules is that we are encapsulating the classes we use as much as possible, because the classes that use our classes don't need to know how they work. This means that if we restrict our use of includes and think about how the dependencies of the classes interact, we are writing encapsulated and decoupled code.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgcb0f496">
<h3 id="orgcb0f496">Circular Dependencies</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #245361;">// </span><span style="color: #245361;">b.h</span>
<span class="linenr">1: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"a.h"</span>
<span class="linenr">2: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">B</span> <span style="color: #99d1ce;">{</span> <span style="color: #d26937;">A</span>* <span style="color: #599cab;">a</span>; <span style="color: #99d1ce;">}</span>;
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #245361;">// </span><span style="color: #245361;">a.h</span>
<span class="linenr">5: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"b.h"</span>
<span class="linenr">6: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">B</span> <span style="color: #99d1ce;">{</span> <span style="color: #d26937;">B</span>* <span style="color: #599cab;">b</span>; <span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
I mentioned at some point about circular dependencies, but they are something that is very common when we are writing OOP code. In this example we see a circular dependency. If we were to just include both header files, we would be stuck in loop, trying to figure out which class to include first, giving us a compilation error. In order to overcome this (and keep in mind that there is nothing wrong with such circular dependencies) we can just forward declare one of the two classes and include the other so we can break from this cycle. Now before you ask "what about the situation where we have explicit object declarations instead of pointers to objects?", let's just say that such a situation is <b>impossible</b>. Not that you can't write such a program, but there is an inherit design flaw to such code, it's virtually impossible to make such a code work, and there is a clear flaw in logic if you find yourself in such a situation. The other question you might have is - well when should we use pointers to objects? This totally depends on your program. For instance, if we have a <code>class Car</code> and a <code>class Wheel</code>, it's logical for the <b>Car</b> to include the <b>Wheel</b> class, but the <b>Wheel</b> class only needs a pointer to the Car object (it doesn't need the whole Car).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org7ffa50e">
<h2 id="org7ffa50e">The ++ in Cpp</h2>
<ul>
<li>C with classes
<ul>
<li>Classes and Objects</li>
<li>Constructors and Operators</li>
<li>Designs</li>

</ul></li>
<li>Inheritance
<ul>
<li>Inheritance models</li>
<li>Multiple Inheritance</li>
<li>Virtual functions and destructors</li>

</ul></li>

<li>Templates
<ul>
<li>Understanding typename</li>
<li>Meta programming</li>

</ul></li>
<li>Resource Management</li>
<li>Good practices
<ul>
<li>Postpone writing objects as much as possible</li>

</ul></li>
<li>STL</li>

</ul>

<aside class="notes">
<p>
When C++ first came out it wasn't all that different from C. Apart from having standard object orientation functionalities and inheritance capabilities, the two languages were more or less the same. But overtime C and C++ grew to become very different. In the previous tutorial we looked into how to structure out program in terms of files and how it executes. Now we will dive into the world of OOP in C++, we will revise what was though in the C++ course and will try to build upon that material by giving examples, by running code, and talking about practices for writing better C++. 
</p>

<p>
First we will cover classes. What the classes implement in the background, what to do with constructors, destructors, and operators. We will look over some designs on how to build our classes for maximum utility and efficiency. Then we will go over inheritance and polymorphism, with discussions over the different models, how to use multiple inheritance, what virtual tables are, how to use virtual functions, and so on.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org17f86b8">
<h2 id="org17f86b8">C with classes</h2>
<div class="outline-text-2" id="text-org17f86b8">
</div>
</section>
</section>
<section>
<section id="slide-org66f8c62">
<h3 id="org66f8c62">Classes and Objects</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Person</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">private</span>: <span style="color: #245361;">// </span><span style="color: #245361;">(Used by default if not specified explicitly) No one can see in here</span>
<span class="linenr"> 3: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">age</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
<span class="linenr"> 6: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">job</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #195466; font-weight: bold;">static</span> <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">Doctor</span> *<span style="color: #599cab;">d</span>;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">void</span> <span style="color: #599cab;">wave</span><span style="color: #33859e;">()</span>;
<span class="linenr">11: </span>
<span class="linenr">12: </span><span style="color: #195466; font-weight: bold;">protected</span>: <span style="color: #245361;">// </span><span style="color: #245361;">Can be seen only by class that is a child</span>
<span class="linenr">13: </span>           <span style="color: #245361;">// </span><span style="color: #245361;">Usually we don't have a use case for protected</span>
<span class="linenr">14: </span>    <span style="color: #d26937;">bool</span> <span style="color: #599cab;">is_married</span>;
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #195466; font-weight: bold;">public</span>: <span style="color: #245361;">// </span><span style="color: #245361;">Everyone can see this part</span>
<span class="linenr">17: </span>    <span style="color: #599cab;">Person</span><span style="color: #33859e;">()</span>;
<span class="linenr">18: </span>    <span style="color: #599cab;">Person</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span><span style="color: #33859e;">)</span>;
<span class="linenr">19: </span>    ~<span style="color: #599cab;">Person</span><span style="color: #33859e;">()</span>;
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">get_name</span><span style="color: #33859e;">()</span>;
<span class="linenr">22: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">get_job</span><span style="color: #33859e;">()</span>;
<span class="linenr">23: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">get_age</span><span style="color: #33859e;">()</span>;
<span class="linenr">24: </span>
<span class="linenr">25: </span>    <span style="color: #d26937;">double</span> <span style="color: #599cab;">calculate_salary</span><span style="color: #33859e;">()</span>;
<span class="linenr">26: </span>
<span class="linenr">27: </span>    <span style="color: #d26937;">bool</span> <span style="color: #599cab;">get_occupation</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> is_married; <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">implicit inline function</span>
<span class="linenr">28: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
This is a basic class. We can see the scopes of the class and what we can have as variables and functions in the different places. A quick note here - although we have 3 scopes, the ones we use the most are <code>private</code> and <code>public</code>, while <code>protected</code> is used in seldom cases, so we need not worry about it that much.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org7227837">
<h4 id="org7227837">Initialization lists</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Library</span> 
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #599cab;">Library</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">name</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">list</span><span style="color: #d26937;">&lt;</span>Books<span style="color: #d26937;">&gt;</span>&amp; <span style="color: #599cab;">books</span><span style="color: #33859e;">)</span>;
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr"> 5: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">theName</span>;
<span class="linenr"> 6: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">list</span><span style="color: #33859e;">&lt;</span>Books<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">books</span>;
<span class="linenr"> 7: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">addressNum</span>;
<span class="linenr"> 8: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #33859e; font-weight: bold;">Library</span>::<span style="color: #599cab;">Library</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">name</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">list</span><span style="color: #33859e;">&lt;</span>Books<span style="color: #33859e;">&gt;</span>&amp; <span style="color: #599cab;">books</span><span style="color: #99d1ce;">)</span>
<span class="linenr">11: </span><span style="color: #245361;">// </span><span style="color: #245361;">&lt;- Initialization start right here before the opening bracket</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">13: </span>    theName = name; <span style="color: #245361;">// </span><span style="color: #245361;">these are all assignments</span>
<span class="linenr">14: </span>    theBooks = books;
<span class="linenr">15: </span>    addressNum = <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr">16: </span><span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">This is OK but can be done better</span>
</pre>
</div>

</section>
<section >

<p>
Constructor with initialization list
</p>

<div class="org-src-container">

<pre  class="src src-C"><span class="linenr">0: </span>Library::Library<span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">std</span>::string&amp; name, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">std</span>::list&lt;Books&gt;&amp; books<span style="color: #99d1ce;">)</span>
<span class="linenr">1: </span>: theName<span style="color: #99d1ce;">(</span>name<span style="color: #99d1ce;">)</span>, <span style="color: #245361;">// </span><span style="color: #245361;">These are all now initialized</span>
<span class="linenr">2: </span>  theBooks<span style="color: #99d1ce;">(</span>books<span style="color: #99d1ce;">)</span>, 
<span class="linenr">3: </span>  addressNum<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">0</span><span style="color: #99d1ce;">)</span>
<span class="linenr">4: </span><span style="color: #99d1ce;">{</span> <span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">Empty constructor body</span>
</pre>
</div>

<aside class="notes">
<p>
When we are initializing this object, we would write <code>Person p1;</code>, but what would happen with its data members. Will they be initialized to zero or not? We can never be sure about this and sometimes they might be <b>zero</b>, sometimes they might be left <b>uninitialized</b>. If we take the risk and read something that is uninitialized, then we will get undefined behavior. There are rules to remember when something is initialized to zero and when something is left uninitialized, but this all depends if you are writing the C part of C++ or the STL part, and things just get way to complicated. That is why we can take the safe approach and just <b>always</b> initialize our object when we create them. If we are just working with normal variables in a function, this would be like writing <code>int x = 0; double b; std::cin &gt;&gt; b; char* x = "pointer intialization"</code> and so on. For objects, however, this tasks is left to the constructor. The rule is simple - make sure that everything is initialized when an object is created.
</p>

<p>
In the example we can see that the Library constructor makes 3 assignments to the data members. In C++, the <b>initialization</b> takes place <b>right before</b> we get into the constructor body! This means that in order to make sure that the variables are initialized, we have to put them into an <b>initialization list</b> (how intuitive!). There are several advantages to this approach. First we make sure that we won't have uninitialized data members and will avoid undefined behavior. Secondly, because we are assigning objects (the <code>string</code> and <code>list</code> members) we are avoiding calling their assignment constructors. In the previous code, where we assigned the variables, first we had to initialize the <code>string</code> and <code>list</code> variables, then we had to assign them the new values by calling a copy assignment operator. That's way too much work. But with the initialization list, not such thing needs to happen. The name and the phone are <b>copy-constructed</b> from the passed parameters. This means that only a copy constructor of the <code>string</code> and <code>list</code> is called in order to initialize the data members, and this operations (the copy constructor) is much more efficient than the previous code.
</p>

<p>
If we want to initialize the data members to nothing or we don't have any parameters to pass to the constructor, we can just call the initialization list and leave the brackets empty.
</p>

<p>
There is one little aspect we must note here and that is - we must write the order of our initialization list in the <b>same order</b> we declared our data members in our class. This is just how C++ works, we must first initialize <code>theName</code> and then <code>theBooks</code> and then <code>addressNum</code>. If we don't do that we will get an error.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org85604e9">
<h4 id="org85604e9">Static non-local objects defined in different translation units</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">in the filesystem.cpp file</span>
<span class="linenr"> 1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">FileSystem</span>
<span class="linenr"> 2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 3: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 4: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">numDisks</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 6: </span><span style="color: #195466; font-weight: bold;">extern</span> <span style="color: #d26937;">FileSystem</span> <span style="color: #599cab;">tfs</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #245361;">// </span><span style="color: #245361;">in our .cpp file</span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Directory</span> 
<span class="linenr">10: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">12: </span>    Directory<span style="color: #33859e;">(</span><span style="color: #599cab;">params</span><span style="color: #33859e;">)</span>;
<span class="linenr">13: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #33859e; font-weight: bold;">Directory</span>::<span style="color: #599cab;">Directory</span><span style="color: #99d1ce;">(</span>params<span style="color: #99d1ce;">)</span>
<span class="linenr">16: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">17: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">disks</span> = tfs.numDisks<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">we use the tfs object,</span>
<span class="linenr">18: </span>                                        <span style="color: #245361;">// </span><span style="color: #245361;">but we cannot be sure</span>
<span class="linenr">19: </span>                                        <span style="color: #245361;">// </span><span style="color: #245361;">that it is initialized</span>
<span class="linenr">20: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">21: </span>
<span class="linenr">22: </span><span style="color: #d26937;">Directory</span> <span style="color: #599cab;">tempDir</span><span style="color: #99d1ce;">(</span>params<span style="color: #99d1ce;">)</span>;
</pre>
</div>

</section>
<section >

<p>
The solution:
</p>

<div class="org-src-container">

<pre  class="src src-C"><span class="linenr"> 0: </span>FileSystem&amp; tfs<span style="color: #99d1ce;">()</span>         <span style="color: #245361;">// </span><span style="color: #245361;">this replaces the tfs object; it could be</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>                         <span style="color: #245361;">// </span><span style="color: #245361;">static in the FileSystem class</span>
<span class="linenr"> 2: </span>    <span style="color: #195466; font-weight: bold;">static</span> <span style="color: #d26937;">FileSystem</span> <span style="color: #599cab;">fs</span>; <span style="color: #245361;">// </span><span style="color: #245361;">define and initialize a local static object</span>
<span class="linenr"> 3: </span>    <span style="color: #195466; font-weight: bold;">return</span> fs;            <span style="color: #245361;">// </span><span style="color: #245361;">return a reference to it</span>
<span class="linenr"> 4: </span><span style="color: #99d1ce;">}</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #d26937;">class</span> <span style="color: #599cab;">Directory</span> <span style="color: #99d1ce;">{</span> ... <span style="color: #99d1ce;">}</span>;  
<span class="linenr"> 7: </span>                <span style="color: #245361;">// </span><span style="color: #245361;">as before</span>
<span class="linenr"> 8: </span>Directory::Directory<span style="color: #99d1ce;">(</span>params<span style="color: #99d1ce;">)</span>              <span style="color: #245361;">// </span><span style="color: #245361;">as before, except references</span>
<span class="linenr"> 9: </span><span style="color: #99d1ce;">{</span>                                         <span style="color: #245361;">// </span><span style="color: #245361;">to tfs are</span>
<span class="linenr">10: </span>    std::size_t disks = tfs<span style="color: #33859e;">()</span>.numDisks<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">now to tfs()</span>
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">12: </span>
<span class="linenr">13: </span>Directory&amp; tempDir<span style="color: #99d1ce;">()</span>               <span style="color: #245361;">// </span><span style="color: #245361;">this replaces the tempDir object; it</span>
<span class="linenr">14: </span><span style="color: #99d1ce;">{</span>                                  <span style="color: #245361;">// </span><span style="color: #245361;">could be static in the Directory class</span>
<span class="linenr">15: </span>    <span style="color: #195466; font-weight: bold;">static</span> <span style="color: #d26937;">Directory</span> <span style="color: #599cab;">td</span><span style="color: #33859e;">(</span> params <span style="color: #33859e;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">define/initialize local static object</span>
<span class="linenr">16: </span>    <span style="color: #195466; font-weight: bold;">return</span> td;                     <span style="color: #245361;">// </span><span style="color: #245361;">return reference to it</span>
<span class="linenr">17: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
One final thing that is worth mentioning is the case when we have to <b>initialize non-local static objects from different translation units</b>. What that jumble of words means is that - if we have a <b>static object</b> (an object that has a duration from the beginning of its initialization till the end of the program) and if that object is <b>non-local</b> (it's in the global scope, namespace scope, or in the scope of an other class) and if it's in a <b>translation unit</b> (basically it's a single source file) how do we initialize it? The problem here is that if we use such a static non-local object, we can <b>never ever</b> be sure when it is initialized properly and we are down the road of undefined behavior. The way to overcome such situations is by writing a function that makes that static non-local object a static local object (basically implementing the <b>Singleton</b> design pattern. . . almost). We just need to write a small function in our code, where we define and initialize a static local object of what we need and return a reference to it. This way we make sure that every time the function to get the object is called, the object will <b>always</b> be initialized.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org46b3b81">
<h3 id="org46b3b81">Constructors and Operators</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">Empty class</span>
<span class="linenr"> 1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">A</span> <span style="color: #99d1ce;">{}</span>;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">Empty class again</span>
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">A</span> 
<span class="linenr"> 5: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 6: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 7: </span>    <span style="color: #599cab;">A</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span>             <span style="color: #245361;">// </span><span style="color: #245361;">constructor</span>
<span class="linenr"> 8: </span>    <span style="color: #599cab;">A</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">A</span>&amp; <span style="color: #599cab;">rhs</span><span style="color: #33859e;">)</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">copy constructor</span>
<span class="linenr"> 9: </span>    ~<span style="color: #599cab;">A</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span>            <span style="color: #245361;">// </span><span style="color: #245361;">destructor</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #d26937;">A</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">A</span>&amp; <span style="color: #599cab;">rhs</span><span style="color: #33859e;">)</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">copy assingment operator</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
All of the classes we write have at least several constructors in them which will be either user defined or put in the class by the compiler. Sometimes we don't have to explicitly tell C++ what kind of constructors we want, because our program doesn't requite such functionality, but sometimes we have to implement our own constructors and operators (<b>operator overloading</b>). It's a good thing to know what the compiler is implementing instead of us when we are not writing the constructors ourselves.
</p>

<p>
Let's take this example for instance. Here we have a class that has nothing in it and we have a class that has four constructors implemented. There is virtually no difference between writing the empty class without constructors and the one with the 3 ctors and one operator implemented. The 3 cotrs and 1 operator that we will always have by default are - a default constructor, default destructor, copy constructor, and a copy assignment operator. In general there isn't much difference between what you will write as an implementation and what the compiler will write for there things, but keep in mind that in some specific cases you will be forced to write your own constructors. This will be the case when you have some constants and/or some references in your class. Why references? Because when you are copying an instance and you have a pointer in it, you would want to copy what the pointer points to (its content) and not the pointer only. And the case for <code>const</code> is that you would want to keep <b>const correctness</b> when copying. This is not a problem if our class has normal data members.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span><span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">NamedObject</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">4: </span>    <span style="color: #599cab;">NamedObject</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">name</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">T</span>&amp; <span style="color: #599cab;">value</span><span style="color: #33859e;">)</span>;
<span class="linenr">5: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">6: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">nameValue</span>;
<span class="linenr">7: </span>    <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">T</span> <span style="color: #599cab;">objectValue</span>;
<span class="linenr">8: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
In this case when we have a reference, we just have to make sure that we are implementing a <b>deep</b> copy when we are writing the constructor or operator. But if our class has a <code>const</code> then we are in trouble. Because we cannot change the value of the initial object we want to re-assign, we cannot implement a proper copy assignment operator. In the case with the constant data member, a default copy assignment operator will not be implemented, and if we were to implement one of our own, we would not copy the <code>const</code> data members.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc66466c">
<h3 id="orgc66466c">Designs</h3>
<div class="outline-text-3" id="text-orgc66466c">
</div>
</section>
</section>
<section>
<section id="slide-org138ad30">
<h4 id="org138ad30">Write OOP classes</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">AccessLevels</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">get_read_write</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> readWrite; <span style="color: #33859e;">}</span>
<span class="linenr"> 4: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">get_read_only</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> readOnly; <span style="color: #33859e;">}</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">set_read_write</span><span style="color: #33859e;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">value</span><span style="color: #33859e;">)</span> <span style="color: #33859e;">{</span> readWrite = value; <span style="color: #33859e;">}</span>
<span class="linenr"> 7: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">set_write_only</span><span style="color: #33859e;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">value</span><span style="color: #33859e;">)</span> <span style="color: #33859e;">{</span> writeOnly = value; <span style="color: #33859e;">}</span>
<span class="linenr"> 8: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr"> 9: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">no_access</span>;    <span style="color: #245361;">// </span><span style="color: #245361;">no access to this </span>
<span class="linenr">10: </span>                      <span style="color: #245361;">// </span><span style="color: #245361;">(maybe it's used as an internal constant)</span>
<span class="linenr">11: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">read_only</span>;    <span style="color: #245361;">// </span><span style="color: #245361;">only read access</span>
<span class="linenr">12: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">read_write</span>;   <span style="color: #245361;">// </span><span style="color: #245361;">read and write access</span>
<span class="linenr">13: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">write_only</span>;   <span style="color: #245361;">// </span><span style="color: #245361;">write only access</span>
<span class="linenr">14: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
Although C++ gives us a lot of flexibility with what we can put into a class and under what type of scope, there have been several great designs that usually make our work much easier and allows us to quickly create our classes. This doesn't mean that we have to neglect what we are actually writing, but for most of the time we can follow these conventions.
</p>

<p>
First of - declare your data members as private (not even protected). Okay so why do this? First off, by making our data members private we are limiting the access to them, we can only <b>get</b> them and <b>change</b> them only through functions. This allows us for finer control over our data (REGAIN CONTROL OVER YOU DATA) and will also follow some consistency when writing classes. We won't need to bag our heads whether we are chaining something or we are writing to something or whatever. The general rule is - every data member should be hidden, or - show only as much as you need. This means that some of our data members won't even need <code>getters</code> and <code>setters</code>, thus reducing our chances of bugs and lines of code. The last, and biggest, benefit to hide your data is <b>encapsulation</b>. This brings a lot of flexibility of implementation to the table and we should strive to make our classes as flexible and encapsulated as possible. A rule we can remember about this is - the more a class is used, the more it needs to be encapsulated. The same rules apply for <code>protected</code> data members. It might seem that they are encapsulated on first glance, but think about this - if we are to remove a <b>protected</b> data member, we are going to break and <b>undefined</b> amount of inherited classes, which is always more than what we will break if we just had that member as <b>private</b>. Seldom are the situations where <code>protected</code> will save the day.
</p>

<p>
In order to access are already <code>private</code> variables, we must rely on getters and setters. These are small and fast functions that do what their name suggests. It's usually a good practice to make you getters <code>const</code>, this way you are ensuring yourself that the variable won't change upon retrieval. As a reminder - not all data members need such functions to them!
</p>

<p>
Another thing that is worth mentioning about how to write classes is - do not over complicate them with functions that they <b>don't</b> necessarily need. This means that if a class needs helper functions, it's not necessary to put those functions as class methods. Although our intuition tells us that we need to encapsulate everything, this doesn't always mean - put everything into a class. Let's take a this source file for instance (<code>./src/robot_and_mines.cpp</code>). This is a little robot that goes through a maze, based on commands given by the user. To load the maze we use a function that reads a text file. The question is - since we are loading something specific that the robot will do, i.e. go through a maze, should that loading function be part of the robot class? Well maybe, it's not wrong to think that a robot might have the functionality to load its course. But at the same time maybe it's not such a good idea, because this increases the <b>size</b> of our class, we have another state to worry about, and if we were to extend this program even further, we might need to remove this function, since it will be getting in the way. So instead of making this function a class method or a friend function, just use it as a standalone thing that just helps the class. If we have multiple functions that are not really class specific, but are very helpful, we can just put them in a standalone <code>header</code> file or a <code>namespace</code> and used them from there. The takeaway is this - prefer to write non-member and non-friend functions to member functions (do not bloat your classes).
</p>

</aside>

</section>
<section >

<p>
Use inline functions
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Person</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">age</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> theAge; <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">implicit inline request</span>
<span class="linenr"> 4: </span>                                       <span style="color: #245361;">// </span><span style="color: #245361;">defined in class definition</span>
<span class="linenr"> 5: </span>    <span style="color: #195466; font-weight: bold;">friend</span> <span style="color: #d26937;">job</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> currJob; <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">friend functions can</span>
<span class="linenr"> 6: </span>                                           <span style="color: #245361;">// </span><span style="color: #245361;">also be inline</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr"> 8: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">theAge</span>;
<span class="linenr"> 9: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">template</span><span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>                             <span style="color: #245361;">// </span><span style="color: #245361;">an explicit inline</span>
<span class="linenr">12: </span><span style="color: #195466; font-weight: bold;">inline</span> <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">T</span>&amp; <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #599cab;">max</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">T</span>&amp; <span style="color: #599cab;">a</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">T</span>&amp; <span style="color: #599cab;">b</span><span style="color: #99d1ce;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">request: std::max is</span>
<span class="linenr">13: </span><span style="color: #99d1ce;">{</span> <span style="color: #195466; font-weight: bold;">return</span> a &lt; b ? b : a; <span style="color: #99d1ce;">}</span>                        <span style="color: #245361;">// </span><span style="color: #245361;">preceded by &#8220;inline&#8221;</span>
</pre>
</div>

<aside class="notes">
<p>
Inlining functions are one of the greatest ideas ever - they allows us to write simple and fast code! Well what does this exactly mean? Inline functions are those that are either specifically written in the class body or are marked as <code>inline</code>. This removes the function call and replaces it with the body of the function directly. This reduces the work of the compiler to jump to function definitions and in general, optimizes our performance. Another optimization is that if we have a code stretch that doesn't have function calls, the compiler might optimize this section, and if we inline out functions we might promote such compiler optimizations. Great for us! But there is a "but" in this whole situation - using too much <code>inline</code> functions will bloat our object file making much bigger executable. On machines that don't have a lot of memory won't handle this very well. <b>Inlined</b> code can lead to additional paging and <b>reduced</b> cache hit rate, and all of the negatives that accompanying this. But if the code we inline is small enough, this will lead to smaller code for the function in comparison to the code generated for the function call, which will <b>increase</b> cache hit ratio and will make object files <b>smaller</b>. So we must be careful what we inline and what we don't (duh).
</p>

<p>
We have to keep in mind that <b>inlining</b> is a request to the compiler and not a command. We can have to approaches, one is to make <b>implicit inline requests</b> by inserting the body of the function in our class definition. These functions are usually member functions, but they can also be friend functions.
</p>

<p>
Okay so when should we use inline functions? Well the thing is that the compiler will decide which functions to inline in reality. Inlining <b>in general</b> is a compile time thing (some build environments execute inlining  during linking and some even during runtime, but the standard is during compilation). This means that we should put out <code>inlines</code> in header files. Let's look at another aspect of inlining and that is the fact that the compiler decides when a function should be inlined. Well in general, a function that has too complicated logic, like loops, recursion, and so on, won't be a good candidate. Also unless a virtual function is trivial simple, it too won't be inlined by the compiler. All of this depends on the build environment and on the compiler you are using, but luckily for us, we will get warnings when a inline function might not be suitable, so that is a good indicator whether we are doing something correct. A good approach is to inline <b>nothing</b> in the beginning, then go over your code again and see what can be optimized further.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgadfd178">
<h4 id="orgadfd178">Treat class design as type design</h4>
<ul>
<li class="fragment roll-in">How should objects of your new type be created and destroyed?</li>
<li class="fragment roll-in">How should object initialization differ from object assignment?</li>
<li class="fragment roll-in">What are the restrictions on legal values for your new type?</li>
<li class="fragment roll-in">What operators and functions make sense for the new type?</li>
<li class="fragment roll-in">What standard functions should be disallowed?</li>
<li class="fragment roll-in">Who should have access to the members of your new type?</li>
<li class="fragment roll-in">Is a new type really what you need?</li>

</ul>

<aside class="notes">
<p>
One of the things that will happen when you are writing your FDS project is that you won't have an idea what to do in the beginning and how to start. Hence you will hesitate how to build your classes and what to do with them.
</p>

<p>
Writing classes isn't easy, because in C++ we are not creating only a class, but we are also creating a <b>user type</b>. This means that we have to take care of what that type must to do and what it must <b>not</b> do. That's why we can ask ourselves the following question in order to get a better grip of the classes we are writing. In consequence we will get a better understanding of the program we are writing.
</p>

<p>
<b>How should objects of your new type be created and destroyed?</b> - How this is done influences the design of your class’s constructors and destructor, as well as its memory allocation and deallocation functions.
</p>

<p>
<b>How should object intialization differ from object assignment?</b> - The answer to this question determines the behavior of and the differences between your constructors and your assignment operators. It’s important not to confuse initialization with assignment, because they correspond to different function calls.
</p>

<p>
<b>What are the restrictions on legal values for your new type?</b> - Usually, only some combinations of values for a class’s data members are valid. Those combinations determine the invariants your class will have to maintain. The invariants determine the error checking you’ll have to do inside your member functions, especially your constructors, assignment operators, and “setter” functions. It may also affect the exceptions your functions throw and, on the off chance you use them, your functions’ exception specifications.
</p>

<p>
<b>What operators and functions make sense for the new type?</b> - The answer to this question determines which functions you’ll declare for your class. Some functions will be member functions, but some will not.
</p>

<p>
<b>What standard functions should be disallowed?</b> - Those are the ones you’ll need to declare private.
</p>

<p>
<b>Who should have access to the members of your new type?</b> - This question helps you determine which members are public, which are protected, and which are private. It also helps you determine which classes and/or functions should be friends, as well as whether it makes sense to nest one class inside another.
</p>

<p>
<b>Is a new type really what you need?</b> If you’re defining a new derived class only so you can add functionality to an existing class, perhaps you’d better achieve your goals by simply defining one or more non-member functions or templates.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org6a64186">
<h4 id="org6a64186">Prefer pass-by-reference-to-const to pass-by-value</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Window</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;     <span style="color: #245361;">// </span><span style="color: #245361;">return name of window</span>
<span class="linenr"> 4: </span>    <span style="color: #195466; font-weight: bold;">virtual</span> <span style="color: #d26937;">void</span> <span style="color: #599cab;">display</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>; <span style="color: #245361;">// </span><span style="color: #245361;">draw window and contents</span>
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">WindowWithScrollBars</span>: <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">Window</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">10: </span>    <span style="color: #195466; font-weight: bold;">virtual</span> <span style="color: #d26937;">void</span> <span style="color: #599cab;">display</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #245361;">// </span><span style="color: #245361;">the bad functoin</span>
<span class="linenr">14: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">printNameAndDisplay</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">Window</span> <span style="color: #599cab;">w</span><span style="color: #99d1ce;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">Bad! Parameter might be sliced!</span>
<span class="linenr">15: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">16: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; w.name<span style="color: #33859e;">()</span>;
<span class="linenr">17: </span>    w.display<span style="color: #33859e;">()</span>;
<span class="linenr">18: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">19: </span>
<span class="linenr">20: </span><span style="color: #245361;">// </span><span style="color: #245361;">the correct function</span>
<span class="linenr">21: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">printNameAndDisplay</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">Window</span>&amp; <span style="color: #599cab;">w</span><span style="color: #99d1ce;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">Correct! Parameter won't be sliced!</span>
<span class="linenr">22: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">23: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; w.name<span style="color: #33859e;">()</span>;
<span class="linenr">24: </span>w.display<span style="color: #33859e;">()</span>;
<span class="linenr">25: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span><span style="color: #245361;">// </span><span style="color: #245361;">the call</span>
<span class="linenr">28: </span><span style="color: #d26937;">WindowWithScrollBars</span> <span style="color: #599cab;">wwsb</span>;
<span class="linenr">29: </span>printNameAndDisplay<span style="color: #99d1ce;">(</span>wwsb<span style="color: #99d1ce;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Most of you are aware of what <b>pass-by-value</b> and <b>pass-by-reference</b> is, but here we will just discuss a few more advantages to using passing of references to <code>const</code>. One thing that happens when we are passing objects (and more specifically, <b>inherited</b> / <b>derived</b> objects from a base class) by value is that we are at the risk of <b>slicing</b> off the derived part of the object in the function call. What this means is that if we have a <code>class A</code> which inherits <code>class B</code>, and we pass an object of <code>type A</code> to a function by value (the function parameter accepts <code>type B</code>), the <b>A</b> part of that object will not be passed, and only the <b>B</b> part will remain. Okay maybe that sounds too complicated, let's revise. By passing something by value we are copying it and the function is using the copy. In the case of inherited classes, when we are passing a derived object by value the <b>copy constructor</b> of the class is called to make a copy - naturally. But when the object has a base class, the base class is copied first. If the parameter of the function is of the base class type, only the base class during the copying will be left, and the derived part will be omitted. That is why it's a better idea to pass-by-reference-to-const.
</p>

<p>
Under the compiler, <b>references</b> are passed as pointers, so we are technically just passing a pointer. That is why if we have a build-in type like <code>int</code> it is more efficient to pass by value. Also we can say that the STL <b>iterators</b> and <b>function objects</b> are also good to pass-by-value, because they have been specifically build to be more optimal to copy than to be passed as a reference (as a pointer).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgade3b95">
<h2 id="orgade3b95">Inheritance</h2>
<aside class="notes">
<p>
Let's talk about inheritance. It is one of the central ideas behind OOP and C++ gives us a lot of freedom to express ourselves through this way. Being able to have single and multiple inheritance, then each link can be public, private, or protected. Then we can have virtual or non-virtual linking. Member functions can also be virtual, or non-virtual, or pure virtual. These are a lot of state to think about and we have to make sure that we understand exactly how these things work together. We are going to talk about public and private inheritance, difference between inheritance of interface and of implementation, how and when to use virtual functions, when to use multiple inheritance, 
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org570db95">
<h3 id="org570db95">Inheritance models</h3>
<ul>
<li>is-a (<code>public</code>)</li>
<li>has-a (<code>private</code>)</li>
<li>is-implemented-in-terms-of (<code>private</code>)</li>

</ul>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Person</span> <span style="color: #99d1ce;">{</span> <span style="color: #99d1ce;">}</span>;
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Student</span>: <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">Person</span> <span style="color: #99d1ce;">{</span> <span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
There are several inheritance models we can use. The same way we can have <code>public</code>, <code>private</code>, and <code>protected</code>, we can have the same model of inheritance between classes. But the thing here is that all of these mean wildly different things.
</p>

<p>
Let's start with <code>public</code> inheritance. If there is something that you absolutely <b>must</b> remember is this : public inheritance <b>means</b> <b><b>is a</b></b>. This means that every time you write <code>class A : public B</code> you are saying to the compiler (and to other readers of code) that <code>class A</code> <b><b>is a</b></b> type of <code>class B</code> but <b>not vice versa</b>. <b><b>A</b></b> is just a more specialized form of <b><b>B</b></b> and <b>anywhere</b> B is used, A can be used respectively without a problem, but if you use a B in the place where A is needed, things won't work. This is the whole idea behind <code>public</code> inheritance.
</p>

<p>
If we take our example, we can clearly say that a every <code>Student</code> is a <code>Person</code>, but not every person is a student. This means that every data member and member function is <code>Person</code> can be used in <code>Student</code> and be correct, but we cannot do the reverse thing. This is intuitive enough and there isn't much to confuse us. 
</p>

<p>
<b>Note:</b> <code>Private</code> inheritance on the other hand means something completely different and we are going to look at it in just a minute. <code>Protected</code> inheritance is something that doesn't really have a concept behind it (or at least the same way <code>private</code> and <code>public</code> have) so we will just not talk about it.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Bird</span>
<span class="linenr">1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">3: </span>    <span style="color: #195466; font-weight: bold;">virtual</span> <span style="color: #d26937;">void</span> <span style="color: #599cab;">fly</span><span style="color: #33859e;">()</span>;
<span class="linenr">4: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Penguin</span>: <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">Bird</span>
<span class="linenr">7: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">8: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
Let's look at a simple example to get a taste for <code>public</code> inheritance. Here we can see that the class Penguin is a Bird. So far so good. But wait a minute. Penguins cannot fly, so we have a problem. We have to change something to make <b>public inheritance</b> work.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Bird</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">FlyingBird</span>: <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">Bird</span> 
<span class="linenr"> 5: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 6: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 7: </span>    <span style="color: #195466; font-weight: bold;">virtual</span> <span style="color: #d26937;">void</span> <span style="color: #599cab;">fly</span><span style="color: #33859e;">()</span>;
<span class="linenr"> 8: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Penguin</span>: <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">Bird</span> 
<span class="linenr">11: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
Here we fix the problem&#x2026; kind of. OK but what if the program we are writing doesn't really need a <code>fly()</code> method or that we don't have the conception of implementing something that can fly. Does that mean that our original design was correct? Maybe it was. It all depends on what we have to do. This goes for show how our perception of things can easily misguide us. In general in software design there isn't one right way to do things, but we have to think about how we implement things. I want to stress the point that until now, most of us are used to make associations between real life objects without really thinking about them. But when it comes to implementing part of life into a program, we have to be vary judicious on how we do that. When I say that <b>public</b> inheritance means that <code>class A</code> is a <code>class B</code> completely, this means <b>completely</b>, we cannot close our eyes to just one thing and ignore it.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgdfaa23b">
<h3 id="orgdfaa23b">Multiple inheritance</h3>

</section>
</section>
<section>
<section id="slide-org13edc8a">
<h3 id="org13edc8a">Virtual functions and destructors</h3>

</section>
</section>
<section>
<section id="slide-org6d28ab4">
<h2 id="org6d28ab4">References</h2>
<div class="outline-text-2" id="text-org6d28ab4">
</div>
</section>
</section>
<section>
<section id="slide-org12cc546">
<h3 id="org12cc546">File Structure</h3>
<ul>
<li><a href="http://www.cplusplus.com/forum/articles/10627/">How to use header files</a></li>
<li><a href="http://www.learncpp.com/cpp-tutorial/19-header-files/">Header files</a></li>
<li><a href="https://stackoverflow.com/questions/333889/why-have-header-files-and-cpp-files">Why do we have header and cpp files</a></li>
<li><a href="https://www.cprogramming.com/declare_vs_define.html">Declaration vs Definition</a></li>
<li><a href="https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration">Difference between declaration and definition</a></li>
<li><a href="http://aszt.inf.elte.hu/~gsd/halado_cpp/ch09s03.html">The PIMPL idiom</a></li>
<li><a href="https://stackoverflow.com/questions/4757565/what-are-forward-declarations-in-c">Forward declarations</a></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgfea0c02">
<h3 id="orgfea0c02">Classes and Objects</h3>
<ul>
<li><a href="http://www.cplusplus.com/articles/y8hv0pDG/">Copy constructors, assignment operators, and exception safe assignment</a></li>
<li><a href="http://www.drdobbs.com/the-problem-with-const-data-members/184403306">The Problem with const Data Members</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/copy_assignment">Copy assignment</a></li>
<li><a href="http://www.bogotobogo.com/cplusplus/functors.php">Functions / Function Objects</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
