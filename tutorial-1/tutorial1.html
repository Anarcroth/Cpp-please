<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>OOP and Inheritance in C++</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">OOP and Inheritance in C++</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-01-08 пн 19:21</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-orgf8753bc">The ++ in Cpp</a></li>
<li><a href="#/slide-orgaedd945">C with classes</a></li>
<li><a href="#/slide-org90e6f26">References</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-orgf8753bc">
<h2 id="orgf8753bc">The ++ in Cpp</h2>
<ul>
<li>C with classes
<ul>
<li>Classes and Objects</li>
<li>Constructors and Operators</li>
<li>Designs</li>

</ul></li>
<li>Inheritance
<ul>
<li>Inheritance models</li>
<li>Multiple Inheritance</li>
<li>Virtual functions and destructors</li>

</ul></li>
<li>Templates
<ul>
<li>Understanding typename</li>
<li>Meta programming</li>

</ul></li>
<li>Resource Management</li>
<li>Good practices</li>
<li>STL</li>

</ul>

<aside class="notes">
<p>
When C++ first came out it wasn't all that different from C. Apart from having standard object orientation functionalities and inheritance capabilities, the two languages were more or less the same. But overtime C and C++ grew to become very different. In the previous tutorial we looked into how to structure out program in terms of files and how it executes. Now we will dive into the world of OOP in C++, we will revise what was though in the C++ course and will try to build upon that material by giving examples, by running code, and talking about practices for writing better C++. 
</p>

<p>
First we will cover classes. What the classes implement in the background, what to do with constructors, destructors, and operators. We will look over some designs on how to build our classes for maximum utility and efficiency. Then we will go over inheritance and polymorphism, with discussions over the different models, how to use multiple inheritance, what virtual tables are, how to use virtual functions, and so on.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgaedd945">
<h2 id="orgaedd945">C with classes</h2>
<div class="outline-text-2" id="text-orgaedd945">
</div>
</section>
</section>
<section>
<section id="slide-org9f7170a">
<h3 id="org9f7170a">Classes and Objects</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Person</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">private</span>: <span style="color: #245361;">// </span><span style="color: #245361;">(Used by default if not specified explicitly) No one can see in here</span>
<span class="linenr"> 3: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">age</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
<span class="linenr"> 6: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">job</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #195466; font-weight: bold;">static</span> <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">Doctor</span> *<span style="color: #599cab;">d</span>;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">void</span> <span style="color: #599cab;">wave</span><span style="color: #33859e;">()</span>;
<span class="linenr">11: </span>
<span class="linenr">12: </span><span style="color: #195466; font-weight: bold;">protected</span>: <span style="color: #245361;">// </span><span style="color: #245361;">Can be seen only by class that is a child</span>
<span class="linenr">13: </span>           <span style="color: #245361;">// </span><span style="color: #245361;">Usually we don't have a use case for protected</span>
<span class="linenr">14: </span>    <span style="color: #d26937;">bool</span> <span style="color: #599cab;">is_married</span>;
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #195466; font-weight: bold;">public</span>: <span style="color: #245361;">// </span><span style="color: #245361;">Everyone can see this part</span>
<span class="linenr">17: </span>    <span style="color: #599cab;">Person</span><span style="color: #33859e;">()</span>;
<span class="linenr">18: </span>    <span style="color: #599cab;">Person</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span><span style="color: #33859e;">)</span>;
<span class="linenr">19: </span>    ~<span style="color: #599cab;">Person</span><span style="color: #33859e;">()</span>;
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">get_name</span><span style="color: #33859e;">()</span>;
<span class="linenr">22: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">get_job</span><span style="color: #33859e;">()</span>;
<span class="linenr">23: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">get_age</span><span style="color: #33859e;">()</span>;
<span class="linenr">24: </span>
<span class="linenr">25: </span>    <span style="color: #d26937;">double</span> <span style="color: #599cab;">calculate_salary</span><span style="color: #33859e;">()</span>;
<span class="linenr">26: </span>
<span class="linenr">27: </span>    <span style="color: #d26937;">bool</span> <span style="color: #599cab;">get_occupation</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> is_married; <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">implicit inline function</span>
<span class="linenr">28: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
This is a basic class. We can see the scopes of the class, what we can have as variables and functions. A quick note here - although we have 3 scopes, the ones we use the most are <code>private</code> and <code>public</code>, while <code>protected</code> is used in seldom cases, so we need not worry about it that much.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org3e18e04">
<h4 id="org3e18e04">Initialization lists</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Library</span> 
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    ABEntry<span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">name</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">list</span><span style="color: #d26937;">&lt;</span>Books<span style="color: #d26937;">&gt;</span>&amp; <span style="color: #599cab;">books</span><span style="color: #33859e;">)</span>;
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr"> 5: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">theName</span>;
<span class="linenr"> 6: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">list</span><span style="color: #33859e;">&lt;</span>Books<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">books</span>;
<span class="linenr"> 7: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">addressNum</span>;
<span class="linenr"> 8: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #33859e; font-weight: bold;">Library</span>::<span style="color: #599cab;">Library</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">name</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">list</span><span style="color: #33859e;">&lt;</span>Books<span style="color: #33859e;">&gt;</span>&amp; <span style="color: #599cab;">books</span><span style="color: #99d1ce;">)</span>
<span class="linenr">11: </span><span style="color: #245361;">// </span><span style="color: #245361;">Initialization start righ here before the opening bracket</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">13: </span>    theName = name; <span style="color: #245361;">// </span><span style="color: #245361;">these are all assignments</span>
<span class="linenr">14: </span>    theBooks = books;
<span class="linenr">15: </span>    addressNum = <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr">16: </span><span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">This is OK but can be done better</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C"><span class="linenr">0: </span>Library::Library<span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">std</span>::string&amp; name, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">std</span>::list&lt;Books&gt;&amp; books<span style="color: #99d1ce;">)</span>
<span class="linenr">1: </span>: theName<span style="color: #99d1ce;">(</span>name<span style="color: #99d1ce;">)</span>, <span style="color: #245361;">// </span><span style="color: #245361;">These are all now initialized</span>
<span class="linenr">2: </span>  theBooks<span style="color: #99d1ce;">(</span>books<span style="color: #99d1ce;">)</span>, 
<span class="linenr">3: </span>  addressNum<span style="color: #99d1ce;">(</span><span style="color: #33859e; font-weight: bold;">0</span><span style="color: #99d1ce;">)</span>
<span class="linenr">4: </span><span style="color: #99d1ce;">{</span> <span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">Empty constructor body</span>
</pre>
</div>

<aside class="notes">
<p>
When we are initializing this object, we would write <code>Person p1</code>, but what would happen with its data members. Will they be initialized to zero or not? We can never be sure about this and sometimes they might be zero, sometimes they might be left <b>uninitialized</b>. If we take the risk and read something that is uninitialized, then we will get an undefined behavior. There are rules to remember when something is initialized to zero and when something is left uninitialized, but this all depends if you are writing the C part of C++ or the STL part and things just get way to complex. That is why we can take the safe approach and just <b>always</b> initialize our object when we create them. If we are just working with normal variables in a function, this would be like writing <code>int x = 0; double b; std::cin &gt;&gt; b; char* x = "pointer intialization"</code> and so on. For object, however, this tasks is left to the constructor. The rule is simple - make sure that everything is initialized when an object is created.
</p>

<p>
In the example we can see that the Library constructor makes 3 assignments to the data members. In C++, the <b>initialization</b> takes place <b>right before</b> we get into the constructor body! This means that in order to make sure that the variables are initialized, we have to put them into an <b>initialization list</b> (how intuitive!). There are several advantages to this approach. First we make sure that we won't have uninitialized data members and will avoid undefined behavior. Secondly, because we are assigning objects (the <code>string</code> and <code>list</code> members) we are avoiding calling their assignment constructors. In the previous code, where we assigned the variables, first we had to initialize the <code>string</code> and <code>list</code> variables, then we had to assign them the new values by calling a copy assignment operator. That's way too much work. But with the initialization list, not such thing needs to happen. The name and the phone are <b>copy-constructed</b> from the passed parameters. This means that only a copy constructor of the <code>string</code> and <code>list</code> is called in order to initialize the data members, and this operations (the copy constructor) is much more efficient than the previous code.
</p>

<p>
If we want to initialize the data members to nothing or we don't have any parameters to pass to the constructor, we can just call the initialization list and leave the brackets empty.
</p>

<p>
There is one little aspect we must note here and that is - we must write the order of our initialization list in the same order we declared our data members in our class. This is just hoe C++ works, we must first initialize <code>theName</code> and then <code>theBooks</code> and the <code>addressNum</code>. If we don't do that we will get an error and undefined behavior.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org4273bba">
<h4 id="org4273bba">Static non-local objects defined in different translation units</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">in the filesystem.cpp file</span>
<span class="linenr"> 1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">FileSystem</span>
<span class="linenr"> 2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 3: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 4: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">numDisks</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 6: </span><span style="color: #195466; font-weight: bold;">extern</span> <span style="color: #d26937;">FileSystem</span> <span style="color: #599cab;">tfs</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #245361;">// </span><span style="color: #245361;">in our .cpp file</span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Directory</span> 
<span class="linenr">10: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">12: </span>    Directory<span style="color: #33859e;">(</span><span style="color: #599cab;">params</span><span style="color: #33859e;">)</span>;
<span class="linenr">13: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #33859e; font-weight: bold;">Directory</span>::<span style="color: #599cab;">Directory</span><span style="color: #99d1ce;">(</span>params<span style="color: #99d1ce;">)</span>
<span class="linenr">16: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">17: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">disks</span> = tfs.numDisks<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">we use the tfs object,</span>
<span class="linenr">18: </span>                                        <span style="color: #245361;">// </span><span style="color: #245361;">but we cannot be sure</span>
<span class="linenr">19: </span>                                        <span style="color: #245361;">// </span><span style="color: #245361;">that it is initialized</span>
<span class="linenr">20: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">21: </span>
<span class="linenr">22: </span><span style="color: #d26937;">Directory</span> <span style="color: #599cab;">tempDir</span><span style="color: #99d1ce;">(</span>params<span style="color: #99d1ce;">)</span>;
</pre>
</div>

</section>
<section >

<p>
The solution:
</p>

<div class="org-src-container">

<pre  class="src src-C"><span class="linenr"> 0: </span>FileSystem&amp; tfs<span style="color: #99d1ce;">()</span>         <span style="color: #245361;">// </span><span style="color: #245361;">this replaces the tfs object; it could be</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>                         <span style="color: #245361;">// </span><span style="color: #245361;">static in the FileSystem class</span>
<span class="linenr"> 2: </span>    <span style="color: #195466; font-weight: bold;">static</span> <span style="color: #d26937;">FileSystem</span> <span style="color: #599cab;">fs</span>; <span style="color: #245361;">// </span><span style="color: #245361;">define and initialize a local static object</span>
<span class="linenr"> 3: </span>    <span style="color: #195466; font-weight: bold;">return</span> fs;            <span style="color: #245361;">// </span><span style="color: #245361;">return a reference to it</span>
<span class="linenr"> 4: </span><span style="color: #99d1ce;">}</span>
<span class="linenr"> 5: </span><span style="color: #d26937;">class</span> <span style="color: #599cab;">Directory</span> <span style="color: #99d1ce;">{</span> ... <span style="color: #99d1ce;">}</span>;                  <span style="color: #245361;">// </span><span style="color: #245361;">as before</span>
<span class="linenr"> 6: </span>Directory::Directory<span style="color: #99d1ce;">(</span> params <span style="color: #99d1ce;">)</span>            <span style="color: #245361;">// </span><span style="color: #245361;">as before, except references</span>
<span class="linenr"> 7: </span><span style="color: #99d1ce;">{</span>                                         <span style="color: #245361;">// </span><span style="color: #245361;">to tfs are</span>
<span class="linenr"> 8: </span>    std::size_t disks = tfs<span style="color: #33859e;">()</span>.numDisks<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">now to tfs()</span>
<span class="linenr"> 9: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>Directory&amp; tempDir<span style="color: #99d1ce;">()</span>               <span style="color: #245361;">// </span><span style="color: #245361;">this replaces the tempDir object; it</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">{</span>                                  <span style="color: #245361;">// </span><span style="color: #245361;">could be static in the Directory class</span>
<span class="linenr">13: </span>    <span style="color: #195466; font-weight: bold;">static</span> <span style="color: #d26937;">Directory</span> <span style="color: #599cab;">td</span><span style="color: #33859e;">(</span> params <span style="color: #33859e;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">define/initialize local static object</span>
<span class="linenr">14: </span>    <span style="color: #195466; font-weight: bold;">return</span> td;                     <span style="color: #245361;">// </span><span style="color: #245361;">return reference to it</span>
<span class="linenr">15: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
One final thing that is worth mentioning is the case when we have to initialize non-local static objects from different translation units. What that jumble of words means is that - if we have a static object (an object that has a duration from the beginning of its initialization till the end of the program) and if that object is non-local (it's in the global scope, namespace scope, or in the scope of an other class) and if it's in a translation unit (basically it's a single source file) how do we initialize it? The problem here is that if we use such a static non-local object, we can never ever be sure when it is initialized properly and we are down the road of undefined behavior. The way to overcome such situations is by writing a function that makes that static non-local object a static local object (basically implementing the <b>Singleton</b> design pattern. . . almost). We just need to write a small function in our code, where we define and initialize a static local object of what we need and return a reference to it. This way we make sure that every time the function to get the object is called, the object will <b>always</b> be initialized.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org2a05bd2">
<h3 id="org2a05bd2">Constructors and Operators</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">Empty class</span>
<span class="linenr"> 1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">A</span> <span style="color: #99d1ce;">{}</span>;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">Empty class again</span>
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">A</span> 
<span class="linenr"> 5: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 6: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 7: </span>    <span style="color: #599cab;">A</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span>             <span style="color: #245361;">// </span><span style="color: #245361;">constructor</span>
<span class="linenr"> 8: </span>    <span style="color: #599cab;">A</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">A</span>&amp; <span style="color: #599cab;">rhs</span><span style="color: #33859e;">)</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">copy constructor</span>
<span class="linenr"> 9: </span>    ~<span style="color: #599cab;">A</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span>            <span style="color: #245361;">// </span><span style="color: #245361;">destructor</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #d26937;">A</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">A</span>&amp; <span style="color: #599cab;">rhs</span><span style="color: #33859e;">)</span> <span style="color: #33859e;">{</span>...<span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">copy assingment operator</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
All of the classes we write have at least several constructors in them which will be either user defined or put in the class by the compiler. Sometimes we don't have to explicitly tell C++ what kind of constructors we want, because our program doesn't requite such functionality, but sometimes we have to implement our own constructors and operators (<b>operator overloading</b>). It's a good thing to know that the compiler is implementing instead of us when we are not writing the constructors ourselves.
</p>

<p>
Let's take this example for instance. Here we have a class that has nothing in it and we have a class that has four constructors implemented. There is virtually no difference between writing the empty class without constructors and the one with the 3 ctors and one operator implemented. The 3 cotrs and 1 operator that we will always have by default are - a default constructor, default destructor, copy constructor, and a copy assignment operator. In general there isn't much difference between what you will write as an implementation and what the compiler will write for there things, but keep in mind that in some specific cases you will be forced to write your own constructors. This will be the case when you have some constants and/or some references in your class. Why references? Because when you are copying an instance and you have a pointer in it, you would want to copy what the pointer points to (its content) and not the pointer only. And the case for <code>const</code> is that you would want to keep <b>const correctness</b> when copying. This is not a problem if our class has normal data members.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #195466; font-weight: bold;">template</span><span style="color: #99d1ce;">&lt;</span><span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr">1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">NamedObject</span>
<span class="linenr">2: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">3: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">4: </span>    <span style="color: #599cab;">NamedObject</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">name</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">T</span>&amp; <span style="color: #599cab;">value</span><span style="color: #33859e;">)</span>;
<span class="linenr">5: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">6: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">nameValue</span>;
<span class="linenr">7: </span>    <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">T</span> <span style="color: #599cab;">objectValue</span>;
<span class="linenr">8: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
In this case when we have a reference, we just have to make sure that we are implementing a <b>deep</b> copy when we are writing the constructor or operator. But if our class has a <code>const</code> then we are in trouble. Because we cannot change the value of the initial object we want to re-assign, we cannot implement a proper copy assignment operator. In the case with the constant data member, a default copy assignment operator will not be implemented, and if we were to implement one of our own, we would not copy the <code>const</code> data members.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org7c57d52">
<h3 id="org7c57d52">Designs</h3>
<div class="outline-text-3" id="text-org7c57d52">
</div>
</section>
</section>
<section>
<section id="slide-orga79eec0">
<h4 id="orga79eec0">Write OOP classes</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">AccessLevels</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">get_read_write</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> readWrite; <span style="color: #33859e;">}</span>
<span class="linenr"> 4: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">get_read_only</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> readOnly; <span style="color: #33859e;">}</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">set_read_write</span><span style="color: #33859e;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">value</span><span style="color: #33859e;">)</span> <span style="color: #33859e;">{</span> readWrite = value; <span style="color: #33859e;">}</span>
<span class="linenr"> 7: </span>    <span style="color: #d26937;">void</span> <span style="color: #599cab;">set_write_only</span><span style="color: #33859e;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">value</span><span style="color: #33859e;">)</span> <span style="color: #33859e;">{</span> writeOnly = value; <span style="color: #33859e;">}</span>
<span class="linenr"> 8: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr"> 9: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">no_access</span>;    <span style="color: #245361;">// </span><span style="color: #245361;">no access to this </span>
<span class="linenr">10: </span>                     <span style="color: #245361;">// </span><span style="color: #245361;">(maybe it's used as an internal constant)</span>
<span class="linenr">11: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">read_only</span>;    <span style="color: #245361;">// </span><span style="color: #245361;">only read access</span>
<span class="linenr">12: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">read_write</span>;   <span style="color: #245361;">// </span><span style="color: #245361;">read and write access</span>
<span class="linenr">13: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">write_only</span>;   <span style="color: #245361;">// </span><span style="color: #245361;">write only access</span>
<span class="linenr">14: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
Although C++ gives us a lot of flexibility with what we can put into a class and under what type of scope, there have been several great designs that usually make our work much easier and allows us to quickly create our classes. This doesn't mean that we have to neglect what we are actually writing, but for most of the time we can follow these conventions.
</p>

<p>
First of - declare your data members as private (not even protected). Okay so why do this? First off, by making our data members private we are limiting the access to them, we can only <b>get</b> them and <b>change</b> them only through functions. This allows us for finer control over our data (REGAIN CONTROL OVER YOU DATA) and will also follow some consistency when writing classes. We won't need to bag our heads whether we are chaining something or we are writing to something or whatever. The general rule is - every data member should be hidden, or - show only as much as you need. This means that some of our data members won't even need <code>getters</code> and <code>setters</code>, thus reducing our chances of bugs and lines of code. The last, and biggest, benefit to hide your data is <b>encapsulation</b>. This brings a lot of flexibility of implementation to the table and we should strive to make our classes as flexible and encapsulated as possible. A rule we can remember about this is - the more a class is used, the more it needs to be encapsulated. The same rules apply for <code>protected</code> data members. It might seem that they are encapsulated on first glance, but think about this - if we are to remove a <b>protected</b> data member, we are going to break and <b>undefined</b> amount of inherited classes, which is always more than what we will break if we just had that member as <b>private</b>. Seldom are the situations where <code>protected</code> will save the day.
</p>

<p>
In order to access are already <code>private</code> variables, we must rely on getters and setters. These are small and fast functions that do what their name suggests. It's usually a good practice to make you getters <code>const</code>, this way you are ensuring yourself that the variable won't change upon retrieval. As a reminder - not all data members need such functions to them!
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org21c2436">
<h4 id="org21c2436">Treat class design as type design</h4>
<ul>
<li class="fragment roll-in">How should objects of your new type be created and destroyed?</li>
<li class="fragment roll-in">How should object initialization differ from object assignment?</li>
<li class="fragment roll-in">What are the restrictions on legal values for your new type?</li>
<li class="fragment roll-in">What operators and functions make sense for the new type?</li>
<li class="fragment roll-in">What standard functions should be disallowed?</li>
<li class="fragment roll-in">Who should have access to the members of your new type?</li>
<li class="fragment roll-in">Is a new type really what you need?</li>

</ul>

<aside class="notes">
<p>
One of the things that will happen when you are writing your FDS project is that you won't have an idea what to do in the beginning and how to start. Hence you will hesitate how to build your classes and what to do with them.
</p>

<p>
Writing classes isn't easy, because in C++ we are not creating only a class, but we are also creating a <b>user type</b>. This means that we have to take care of what that type must to do and what it must <b>not</b> do. That's why we can ask ourselves the following question in order to get a better grip of the classes we are writing. In consequence we will get a better understanding of the program we are writing.
</p>

<p>
<b>How should objects of your new type be created and destroyed?</b> - How this is done influences the design of your class’s constructors and destructor, as well as its memory allocation and deallocation functions.
</p>

<p>
<b>How should object intialization differ from object assignment?</b> - The answer to this question determines the behavior of and the differences between your constructors and your assignment operators. It’s important not to confuse initialization with assignment, because they correspond to different function calls.
</p>

<p>
<b>What are the restrictions on legal values for your new type?</b> - Usually, only some combinations of values for a class’s data members are valid. Those combinations determine the invariants your class will have to maintain. The invariants determine the error checking you’ll have to do inside your member functions, especially your constructors, assignment operators, and “setter” functions. It may also affect the exceptions your functions throw and, on the off chance you use them, your functions’ exception specifications.
</p>

<p>
<b>What operators and functions make sense for the new type?</b> - The answer to this question determines which functions you’ll declare for your class. Some functions will be member functions, but some will not.
</p>

<p>
<b>What standard functions should be disallowed?</b> - Those are the ones you’ll need to declare private.
</p>

<p>
<b>Who should have access to the members of your new type?</b> - This question helps you determine which members are public, which are protected, and which are private. It also helps you determine which classes and/or functions should be friends, as well as whether it makes sense to nest one class inside another.
</p>

<p>
<b>Is a new type really what you need?</b> If you’re defining a new derived class only so you can add functionality to an existing class, perhaps you’d better achieve your goals by simply defining one or more non-member functions or templates.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org780f16e">
<h4 id="org780f16e">Prefer pass-by-reference-to-const to pass-by-value</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">Window</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;     <span style="color: #245361;">// </span><span style="color: #245361;">return name of window</span>
<span class="linenr"> 4: </span>    <span style="color: #195466; font-weight: bold;">virtual</span> <span style="color: #d26937;">void</span> <span style="color: #599cab;">display</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>; <span style="color: #245361;">// </span><span style="color: #245361;">draw window and contents</span>
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">WindowWithScrollBars</span>: <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">Window</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">10: </span>    <span style="color: #195466; font-weight: bold;">virtual</span> <span style="color: #d26937;">void</span> <span style="color: #599cab;">display</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #245361;">// </span><span style="color: #245361;">the bad functoin</span>
<span class="linenr">14: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">printNameAndDisplay</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">Window</span> <span style="color: #599cab;">w</span><span style="color: #99d1ce;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">Bad! Parameter might be sliced!</span>
<span class="linenr">15: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">16: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; w.name<span style="color: #33859e;">()</span>;
<span class="linenr">17: </span>    w.display<span style="color: #33859e;">()</span>;
<span class="linenr">18: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">19: </span>
<span class="linenr">20: </span><span style="color: #245361;">// </span><span style="color: #245361;">the correct function</span>
<span class="linenr">21: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">printNameAndDisplay</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">Window</span>&amp; <span style="color: #599cab;">w</span><span style="color: #99d1ce;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">Correct! Parameter won't be sliced!</span>
<span class="linenr">22: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">23: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; w.name<span style="color: #33859e;">()</span>;
<span class="linenr">24: </span>w.display<span style="color: #33859e;">()</span>;
<span class="linenr">25: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span><span style="color: #245361;">// </span><span style="color: #245361;">the call</span>
<span class="linenr">28: </span><span style="color: #d26937;">WindowWithScrollBars</span> <span style="color: #599cab;">wwsb</span>;
<span class="linenr">29: </span>printNameAndDisplay<span style="color: #99d1ce;">(</span>wwsb<span style="color: #99d1ce;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Most of you are aware of what <b>pass-by-value</b> and <b>pass-by-reference</b> is, but here we will just discuss a few more advantages to using passing of references to <code>const</code>. One thing that happens when we are passing objects (and more specifically, <b>inherited</b> / <b>derived</b> objects from a base class) by value is that we are at the risk of <b>slicing</b> off the derived part of the object in the function call. What this means is that if we have a <code>class A</code> which inherits <code>class B</code>, and we pass an object of <code>type A</code> to a function by value (the function parameter accepts <code>type B</code>), the <b>A</b> part of that object will not be passed, and only the <b>B</b> part will remain. Okay maybe that sounds too complicated, let's revise. By passing something by value we are copying it and the function is using the copy. In the case of inherited classes, when we are passing a derived object by value the <b>copy constructor</b> of the class is called to make a copy - naturally. But when the object has a base class, the base class is copied first. If the parameter of the function is of the base class type, only the base class during the copying will be left, and the derived part will be omitted. That is why it's a better idea to pass-by-reference-to-const.
</p>

<p>
Under the compiler, <b>references</b> are passed as pointers, so we are technically just passing a pointer. That is why if we have a build-in type like <code>int</code> it is more efficient to pass by value. Also we can say that the STL <b>iterators</b> and <b>function objects</b> are also good to pass-by-value, because they have been specifically build to be more optimal to copy than to be passed as a reference (as a pointer).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org90e6f26">
<h2 id="org90e6f26">References</h2>
<ul>
<li><a href="http://www.cplusplus.com/articles/y8hv0pDG/">Copy constructors, assignment operators, and exception safe assignment</a></li>
<li><a href="http://www.drdobbs.com/the-problem-with-const-data-members/184403306">The Problem with const Data Members</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/copy_assignment">Copy assignment</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
