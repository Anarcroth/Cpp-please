<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Resource Management and Good practices</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../css/reveal.css"/>

<link rel="stylesheet" href="../css/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../css/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Resource Management and Good practices</h1><h2 class="author">Martin Nestorov</h2>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-orgfc5fa83">How to manage memory</a></li>
<li><a href="#/slide-orgf0289bd">General good practices</a></li>
<li><a href="#/slide-org5114fe9">Exercises</a></li>
<li><a href="#/slide-orge701b8a">Resources</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-orgfc5fa83">
<h2 id="orgfc5fa83">How to manage memory</h2>
<aside class="notes">
<p>
When we first learn C++ for the first time we have way too many things going on so we are usually told not to worry about memory management (or we are not even aware that such a thing exists in the language). This is normal, since the language itself is hard enough to learn so we push thins topic for another time. But that time usually comes way too late and we don't have the discipline to think in therms of memory management. Luckily for us, we are writing modern C++, which means that there are a lot of tools deisgn to help us out with this task and to make it much more easy, than it was back in '89.
</p>

<p>
In C++ we have several resources we can manage, where we are not only limited to some dynamically allocated object. We care for files, database connections, mutexes, GUIs, sockets, etc. This means that having memory leaks is just one of our problems, but being unable to connect to a databse, or corrupt the contents of a file, because we are not careful enough is a whole other story. Here we will try to look at how we can use the STL to our advantage and manage resources manually.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org119170c">
<h3 id="org119170c">RAII</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">without RAII</span>
<span class="linenr"> 1: </span><span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">handle</span>=createNewResource<span style="color: #99d1ce;">()</span>;
<span class="linenr"> 2: </span>handle-&gt;performInvalidOperation<span style="color: #99d1ce;">()</span>;  <span style="color: #245361;">// </span><span style="color: #245361;">this will throw an excpetion</span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">some code</span>
<span class="linenr"> 4: </span>deleteResource<span style="color: #99d1ce;">(</span>handle<span style="color: #99d1ce;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">resource leek never cleaned!</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #245361;">// </span><span style="color: #245361;">with RAII</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">SomeResource</span> <span style="color: #99d1ce;">{</span>
<span class="linenr"> 8: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 9: </span>   <span style="color: #599cab;">SomeResource</span><span style="color: #33859e;">(</span><span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">rawRes_</span><span style="color: #33859e;">)</span> : rawRes<span style="color: #33859e;">(</span>rawRes_<span style="color: #33859e;">)</span> <span style="color: #33859e;">{}</span>;
<span class="linenr">10: </span>   ~<span style="color: #599cab;">SomeResource</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">delete</span> rawRes; <span style="color: #33859e;">}</span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">12: </span>   <span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">rawRes</span>;
<span class="linenr">13: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #d26937;">SomeResource</span> <span style="color: #599cab;">handle</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">createNewResource</span><span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">16: </span>handle-&gt;performInvalidOperation<span style="color: #99d1ce;">()</span>;
</pre>
</div>

<aside class="notes">
<p>
In C++ we have this magical idiom called <b><b>RAII</b></b>, or <b>Resource Acquisition Is Initialization</b>. This binds the life cycle of a resource that must be acquired before use, to the lifetime of an object. Again, we are not just talking about pieces of memory, but sockets, database connections, file descriptors, mutexes, things that are considered as a resources, are bounded to an object. Then, functions are able to access that resource (through the object), use it, and when it is no longer needed, the object manages the state of the resource, and closes it appropriately. You might also see this idiom as <b>Scope-Bound Resource Management</b>. The important thing here is that even when we get an exception during some constructor, the already created base objects are also released in reverse order of initialization. We are both managing resource leaks and exception safety!! C++ provides us with some ready-made solutions to this principle. <code>vector</code>, <code>string</code>, and <code>thread</code> manage their resources on their own so we don't have to worry about them, but we also have <code>unique_ptr</code> and <code>shared_ptr</code> where we can manage resources and not worry about their releasing and exceptions.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org1c0e464">
<h3 id="org1c0e464">When to use <code>new</code> and <code>delete</code></h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">int</span> * <span style="color: #599cab;">ipt</span> = <span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">int</span>;
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"ipt = "</span> &lt;&lt; ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 3: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 4: </span>*ipt = <span style="color: #33859e; font-weight: bold;">1000</span>;
<span class="linenr"> 5: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">delete</span> ipt;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"ipt = "</span> &lt;&lt; ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">10: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl
</pre>
</div>

<aside class="notes">
<p>
When do we actually have to use <code>new</code> and <code>delete</code>? It's so tempting to just say <b>never</b> and move on to the rest of the topics, but this is not exactly true. It's <b>almost</b> true. First let's look at what <code>new</code> and <code>delete</code> do. <code>new</code> is the keyword we use in C++ that allocates a piece of memory in the <b>local store</b> and has a pointer to that piece of anonymous data. <code>delete</code> on the other hand does the opposite and removes the contents of a cell of memory. So let's look at an example. Here we just allocate an integer to the free store and then we read the pointer address and the address contents. The question is what would happen after the <code>delete</code> call? Would we have to same contents or would we get the same number again? The answer is - we would get <b><b>undefined</b></b> behavior. After you call delete, you can still use the pointer for other things, but never ever try to see what it points to, since we will go down the valley of <b>undefined</b> behavior.
</p>

<p>
So using <code>new</code> and <code>delete</code> can lead to peril if we are not careful, so what are our other options?
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org3d491b8">
<h3 id="org3d491b8">A pass by over garbage collection</h3>
<ul>
<li class="fragment roll-in">Weak references</li>
<li class="fragment roll-in">Reference counting</li>
<li class="fragment roll-in">Rule of five</li>

</ul>

<aside class="notes">
<p>
Let's just go over some interesting and important notes about garbage collection and memory management before we continue with the main topics. Why doesn't C++ have a garbage collector like <code>Java</code> or <code>C#</code> or some other languages? Well it's not impossible and there are some implementations of a C++ garbage collector, but it's not something that is used widely in the C++ sphere. There are a lot of reasons why this is so, time constraints, agreements between the C++ implementation group, implementation problems in general, etc. The thing with garbage collection is that it's a pretty heavy process and it isn't as simple as pushing everything into smart pointers and calling it a day. C++ is above all efficient, it gives us a lot of room to make whatever we like. The garbage collection we have is the explicit one we can achieve through smart pointers, but there isn't a thing like the <code>Java</code> or <code>C#</code> collector (an implicit GC) (As a side note, I have included a link to a <b>C++ GC</b> if you still want to try it out). So the question here is - how do smart pointers work in C++. Everybody is talking about them, they do have great functionalities, but how are they actually helpful?
</p>

<p>
In order to understand these concept we need to cover several topics. Let's start with <b>weak references</b>. In general, abstracting ourselves from C++, a <b>weak reference</b> is a pointer that does not protect the content that pointer points to from a garbage collector. If we have a chain of references to an object and even if one of those references are weak, the whole chain is considered to be weak and can be collected at any moment. Now there are several layers of weak references and we can find them in implementations in <code>Java</code>, <code>C#</code>, <code>python</code>, etc. In general, there are two types of GC - <b>tracing</b> and <b>reference counting</b>. We are going to look only <b>reference counting</b> since it's relevant to us.
</p>

</aside>

<aside class="notes">
<p>
Now <b><b>reference counting</b></b> is a technique where we count the number of references, handlers, and pointers to a certain object, memory block, file, and in general - any resource. Once the number of references reaches <b>0</b>, that resource is collected and destroyed. An interesting aspect of this is that when we destroy an object that is no longer referenced by anything, if that object holds a references to another object, after the destruction of the de-referenced object, the other referenced object have their reference count decremented. So there is also a technique where we can add the no longer referenced objects to a list, which we regularly (and by we I mean the GC) visit and destroy some objects from it. All of these processes require constant updating. There are several advantages to this technique, although it being simple - for one, it's very responsive as it doesn't waste any time in de-allocating space for us, thus making it adequate for systems with limited memory. Also the performance of this doesn't go down as the memory is freed. The problem to all of this is that this algorithm takes up memory spaces for the counts, it is not the most efficient method, that is why it's so simple, and it also can't prevent <b>reference cycles</b>. A <b>reference cycle</b> is just an object that refers to itself <b>directly</b> or <b>indirectly</b>. This means that their reference count is going to be always above zero. Here <b>weak references</b> come in handy since they can break such a chain.
</p>

<p>
(In this whole segment I managed to re-use the word "reference" 20 times&#x2026;geez, talk about DRY)
</p>

</aside>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">utility</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">resource</span> 
<span class="linenr"> 3: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 4: </span>  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">foo</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span>  <span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">10: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">()</span> : p<span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #d26937;">{}</span><span style="color: #33859e;">}</span> <span style="color: #33859e;">{</span> <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">default ctor</span>
<span class="linenr">11: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">foo</span>&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> : p<span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #d26937;">{</span>*<span style="color: #888ca6;">(</span>other.p<span style="color: #888ca6;">)</span><span style="color: #d26937;">}</span><span style="color: #33859e;">}</span> <span style="color: #33859e;">{</span> <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">copy ctor</span>
<span class="linenr">12: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">(</span><span style="color: #d26937;">foo</span>&amp;&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> : p<span style="color: #33859e;">{</span>other.p<span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">move ctor</span>
<span class="linenr">13: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">14: </span>      other.p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">15: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #d26937;">foo</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">foo</span>&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">assignment operator</span>
<span class="linenr">18: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">19: </span>      <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #d26937;">(</span>&amp;other != <span style="color: #195466; font-weight: bold;">this</span><span style="color: #d26937;">)</span> <span style="color: #d26937;">{</span>
<span class="linenr">20: </span>        <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">21: </span>        p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">22: </span>        p = <span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #888ca6;">{</span>*<span style="color: #2aa889;">(</span>other.p<span style="color: #2aa889;">)</span><span style="color: #888ca6;">}</span>;
<span class="linenr">23: </span>      <span style="color: #d26937;">}</span>
<span class="linenr">24: </span>      <span style="color: #195466; font-weight: bold;">return</span> *<span style="color: #195466; font-weight: bold;">this</span>;
<span class="linenr">25: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span>    <span style="color: #d26937;">foo</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #d26937;">foo</span>&amp;&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">move assignment operator</span>
<span class="linenr">28: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">29: </span>      <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #d26937;">(</span>&amp;other != <span style="color: #195466; font-weight: bold;">this</span><span style="color: #d26937;">)</span> <span style="color: #d26937;">{</span>
<span class="linenr">30: </span>        <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">31: </span>        p = other.p;
<span class="linenr">32: </span>        other.p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">33: </span>      <span style="color: #d26937;">}</span>
<span class="linenr">34: </span>      <span style="color: #195466; font-weight: bold;">return</span> *<span style="color: #195466; font-weight: bold;">this</span>;
<span class="linenr">35: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">36: </span>
<span class="linenr">37: </span>    ~<span style="color: #599cab;">foo</span><span style="color: #33859e;">()</span> <span style="color: #245361;">// </span><span style="color: #245361;">destructor</span>
<span class="linenr">38: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">39: </span>      <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">40: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">41: </span>
<span class="linenr">42: </span>  <span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">43: </span>    <span style="color: #d26937;">resource</span>* <span style="color: #599cab;">p</span>;
<span class="linenr">44: </span><span style="color: #99d1ce;">}</span>;
</pre>
</div>


<aside class="notes">
<p>
And finally let's talk about the <b>rule of five</b>. These are just a set of rules for building <b>exception safe</b> and <b>resource managing</b> code in C++. The first three rules can be summed up like this. If a class needs to have a user-defined destructor, or copy constructor, or copy assignment operator, then it most probably needs all three. Because we are handling resources in our classes, we will be working with references and pointers, which means that the default implementations of the constructors and destructor will not suffice for us, and we will need to implement them on our own (tutorial 1 covers briefly the topic of writing such custom implementations). The last two rules are also related to this. If we have these custom implementations in our code base, we must also implement a <b><b>move</b></b> constructor and a <b><b>move assignment operator</b></b>. Now we must acknowledge what a <b>move</b> constructor and <b>move assignment operator</b> is. Well basically, they are two new additions we have since <b>C++ 11</b>. They allow us to perform move semantics in C++ in a more efficient way (there are links to references for <b>move</b> s for those who are interested).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgbb6f817">
<h3 id="orgbb6f817">Using the STL to our advantage</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">memory</span><span style="color: #99d1ce;">&gt;</span> <span style="color: #245361;">// </span><span style="color: #245361;">holds smart pointers</span>
<span class="linenr">1: </span>
<span class="linenr">2: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">unique_ptr</span><span style="color: #99d1ce;">&lt;</span>Object<span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">obj</span>; <span style="color: #245361;">// </span><span style="color: #245361;">holds a pointer to var obj</span>
<span class="linenr">3: </span>
</pre>
</div>

<aside class="notes">
<p>
In the previous section I mentioned that we can use smart pointers to our advantage to handle heap memory and resources. Before we had to write out own memory management classes that worked likes smart pointers, when C++ 11 first came out, we had <code>auto_ptr</code>, which tried to do that. But it was somewhat impaired to several functionalities like copying and assigning. Since then, <code>auto_ptr</code> is deprecated and we use either <code>unique_ptr</code> or <code>share_ptr</code>. Now I want to get this out of the way, when working with smart pointers, <b>unique</b> is the standard and <b>shared</b> is the exception.
</p>

<p>
So how does a <code>unique_ptr</code> look like? Well, it's basically using any other STL container, where we define what we want inside of it and then we declare our variable.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgf0289bd">
<h2 id="orgf0289bd">General good practices</h2>
<div class="outline-text-2" id="text-orgf0289bd">
</div>
</section>
</section>
<section>
<section id="slide-orgc5934e4">
<h3 id="orgc5934e4">Use <code>const</code>, <code>enums</code>, and <code>inline</code></h3>
</section>
</section>
<section>
<section id="slide-orgdc4836b">
<h3 id="orgdc4836b">Make full copies of objects</h3>
</section>
</section>
<section>
<section id="slide-org807f082">
<h3 id="org807f082">Postpone variable definitions</h3>

</section>
</section>
<section>
<section id="slide-org5114fe9">
<h2 id="org5114fe9">Exercises</h2>

</section>
</section>
<section>
<section id="slide-orge701b8a">
<h2 id="orge701b8a">Resources</h2>
<div class="outline-text-2" id="text-orge701b8a">
</div>
</section>
</section>
<section>
<section id="slide-orgab2b0c2">
<h3 id="orgab2b0c2">Memory Management</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii">RAII</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/raii">RAII 2</a></li>
<li><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Wiki RAII</a></li>
<li><a href="https://stackoverflow.com/questions/147130/why-doesnt-c-have-a-garbage-collector">Why don't we have a GC in C++</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/113177/why-do-languages-such-as-c-and-c-not-have-garbage-collection-while-java-does">Why no GC in C++</a></li>
<li><a href="http://hboehm.info/gc/">Garbage collector for C++</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reference_counting#reference_cycle">Reference counting</a></li>
<li><a href="https://en.wikipedia.org/wiki/Weak_reference">Weak references</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rule_of_three_(C++_programming)">Rule of 3</a></li>
<li><a href="https://cpppatterns.com/patterns/rule-of-five.html">Rule of 5</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/rule_of_three">Rule of 3/5/0</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/dd293665.aspx">Move constructor and assignment operator</a></li>
<li><a href="https://blog.smartbear.com/c-plus-plus/c11-tutorial-introducing-the-move-constructor-and-the-move-assignment-operator/">C++ 11 move</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/move_constructor">Move constructors</a></li>
<li><a href="https://visualstudiomagazine.com/articles/2012/10/19/circular-references.aspx">Circular references</a></li>
<li><a href="https://mortoray.com/2012/01/08/what-is-reference-counting/">What is reference counting</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="../js/head.min.js"></script>
<script src="../js/reveal.js"></script>

<script>
 // Full list of configuration options available here:
 // https://github.com/hakimel/reveal.js#configuration
 Reveal.initialize({

     controls: true,
     progress: true,
     history: true,
     center: true,
     slideNumber: 'c',
     rollingLinks: true,
     keyboard: true,
     overview: true,
     width: 1920,
     height: 1080,
     margin: 0.00,
     maxScale: 2.00,

     theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
     transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
     transitionSpeed: 'default',
     multiplex: {
         secret: '', // null if client
         id: '', // id, obtained from socket.io server
         url: '' // Location of socket.io server
     },

     // Optional libraries used to extend on reveal.js
     dependencies: [
         { src: '../js/classList.js', condition: function() { return !document.body.classList; } },
         { src: '../js/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
         { src: '../js/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
         { src: '../js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
         { src: '../js/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
 });
</script>
</body>
</html>
