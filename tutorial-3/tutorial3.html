<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Resource Management and Good practices</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Resource Management and Good practices</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-02-14 Wed 09:28</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-orga92c841">How to manage memory</a></li>
<li><a href="#/slide-org44792de">General good practices</a></li>
<li><a href="#/slide-orga336db8">Resources</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-orga92c841">
<h2 id="orga92c841">How to manage memory</h2>
<aside class="notes">
<p>
When we learn C++ for the first time we have way too many things going on, so we are usually told not to worry about memory management (or we are not even aware that such a thing exists in the language). This is normal, since the language itself is hard enough to learn so we push this topic for another time. But that time usually comes way too late and we don't have the discipline to think in therms of memory management. Luckily for us, we are writing modern C++, which means that there are a lot of tools designed to help us out with this task and to make it easier, than it was back in '89.
</p>

<p>
In C++ we have several resources we can manage, where we are not only limited to some dynamically allocated object. We <b>care</b> for files, database connections, mutexes, GUIs, sockets, etc. This means that having memory leaks is just one of our problems, but being unable to connect to a database, or corrupt the contents of a file, because we are not careful enough, is a whole other story. So first we are going to look at several principles about memory management, how we can allocate memory manually, and then we will move to the STL, where we will take advantage of managing resources automatically.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org65a1be1">
<h3 id="org65a1be1">RAII</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">without RAII</span>
<span class="linenr"> 1: </span><span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">handle</span>=createNewResource<span style="color: #99d1ce;">()</span>;
<span class="linenr"> 2: </span>handle-&gt;performInvalidOperation<span style="color: #99d1ce;">()</span>;  <span style="color: #245361;">// </span><span style="color: #245361;">this will throw an excpetion</span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">some code</span>
<span class="linenr"> 4: </span>deleteResource<span style="color: #99d1ce;">(</span>handle<span style="color: #99d1ce;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">resource leek never cleaned!</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #245361;">// </span><span style="color: #245361;">with RAII</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">SomeResource</span> <span style="color: #99d1ce;">{</span>
<span class="linenr"> 8: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 9: </span>   <span style="color: #599cab;">SomeResource</span><span style="color: #33859e;">(</span><span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">rawRes_</span><span style="color: #33859e;">)</span> : rawRes<span style="color: #33859e;">(</span>rawRes_<span style="color: #33859e;">)</span> <span style="color: #33859e;">{}</span>;
<span class="linenr">10: </span>   ~<span style="color: #599cab;">SomeResource</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">delete</span> rawRes; <span style="color: #33859e;">}</span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">12: </span>   <span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">rawRes</span>;
<span class="linenr">13: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #d26937;">SomeResource</span> <span style="color: #599cab;">handle</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">createNewResource</span><span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">16: </span>handle-&gt;performInvalidOperation<span style="color: #99d1ce;">()</span>;
</pre>
</div>

<aside class="notes">
<p>
In C++ we have this magical idiom called <b><b>RAII</b></b>, or <b>Resource Acquisition Is Initialization</b>. This binds the life cycle of a resource that must be acquired before use, to the lifetime of an object. Again, we are not just talking about pieces of memory, but sockets, database connections, file descriptors, mutexes, things that are considered as a resources. All of these things are <b>bounded</b> to an object. Then, functions are able to access that resource (through the object), use it, and when it is no longer needed, the object manages the state of the resource, and closes it appropriately. You might also see this idiom as <b>Scope-Bound Resource Management</b>. The important thing here is that even when we get an exception during some constructor (or some operator), the already created base objects are also released in <b>reverse order</b> of initialization (going through the inheritance hierarchy). We are both managing resource leaks and exception safety!! C++ provides us with some ready-made solutions to this principle. <code>vector</code>, <code>string</code>, and <code>thread</code> manage their resources on their own so we don't have to worry about them, but we also have <code>unique_ptr</code> and <code>shared_ptr</code> where we can manage resources and not worry about their releasing and when exceptions occur.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org8153fd7">
<h3 id="org8153fd7">When to use <code>new</code> and <code>delete</code></h3>
<div class="org-src-container">

<pre  class="src src-C++"><span style="color: #d26937;">int</span> * <span style="color: #599cab;">ipt</span> = <span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">int</span>;

<span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"ipt = "</span> &lt;&lt; ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
*ipt = <span style="color: #33859e; font-weight: bold;">1000</span>;
<span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;

<span style="color: #195466; font-weight: bold;">delete</span> ipt;
<span style="color: #245361;">// </span><span style="color: #245361;">what happens now?</span>
<span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"ipt = "</span> &lt;&lt; ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl
</pre>
</div>

<aside class="notes">
<p>
When do we <b>actually</b> have to use <code>new</code> and <code>delete</code>? It's so tempting to just say <b>never</b> and move on to the rest of the topics, but this is not exactly true. But it's <b>almost</b> true. First let's look at what <code>new</code> and <code>delete</code> do. <code>new</code> is the keyword we use in C++ that allocates a piece of memory in the <b>local store</b> and has a pointer to that piece of <b>anonymous</b> data. <code>delete</code> on the other hand does the opposite and <b>de-allocates</b> the contents to some space of memory. So let's look at an example. Here we just allocate an integer to the free store and then we read the pointer address and the address contents. The question is what would happen after the <code>delete</code> call? Would we have to same contents or would we get the same number again? Is it possible that we will have 0 as a value or something random? The answer is - we would get <b><b>undefined</b></b> behavior. After you call delete, that memory is de-allocated and we are leaving it to the computer to decide when and how to manage it on its own. The value might remain, or it might be chnaged immediate, we can <b>never</b> know. You can still use the pointer for other things, but never ever try to see what it points to, since we will go down the valley of <b>undefined</b> behavior. The problem with this is that there is nothing stopping us from calling <code>delete</code> multiple times. We also have to be careful when we are working with <b>array</b> since they need some <b>extra</b> syntax for deletion. On top of that we must never forget to do this operation.
</p>

<p>
So using <code>new</code> and <code>delete</code> can lead to peril if we are not careful, so what are our other options?
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org1f94f35">
<h3 id="org1f94f35">A pass by over garbage collection</h3>
<ul>
<li class="fragment roll-in">Weak references</li>
<li class="fragment roll-in">Reference counting</li>
<li class="fragment roll-in">Rule of five</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgcd068ea">
<h4 id="orgcd068ea">Weak references</h4>
<aside class="notes">
<p>
Let's just go over some interesting and important notes about <b>garbage collection</b> and memory management before we continue with the main topics. Why doesn't C++ have a garbage collector like <code>Java</code> or <code>C#</code> or some other languages? Well it's not impossible and there are some implementations of a C++ garbage collector, but it's not something that is used widely in the C++ sphere. There are a lot of reasons why this is so, time constraints, agreements between the C++ implementation group, implementation problems in general, etc. The thing with garbage collection is that it's a pretty <b>heavy</b> process and it isn't as simple as pushing everything into smart pointers and calling it a day. C++ is above all <b>efficient</b>, it gives us a lot of room to do whatever we like. The garbage collection we have is the explicit one we can achieve through smart pointers, but there isn't a thing like the <code>Java</code> or <code>C#</code> collector (an <b>implicit</b> GC) (As a side note, I have included a link to a <b>C++ GC</b> if you still want to try it out). So the question here is - how do we work with the explicit garbage collection, i.e. <b>how do smart pointers work</b> in C++. Everybody is talking about them, they do have great functionalities, but how are they actually helpful?
</p>

<p>
In order to understand these concept we need to cover several topics. Let's start with <b>weak references</b>. In general, abstracting ourselves from C++, a <b>weak reference</b> is a pointer that does not protect the content that pointer points to from a garbage collector. If we have a chain of references to an object and even if <b>one</b> of those references are weak, the whole chain is considered to be <b>weak</b> and can be collected at any moment. Now there are several layers of weak references and we can find them in implementations in <code>Java</code>, <code>C#</code>, <code>python</code>, etc. In general, there are two types of GC - <b>tracing</b> and <b>reference counting</b> ones. We are going to look only <b>reference counting</b> since it's relevant to us.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org118559e">
<h4 id="org118559e">Reference counting</h4>
<aside class="notes">
<p>
Now <b><b>reference counting</b></b> is a technique where we count the <b>number</b> of references, handlers, and pointers to a certain object, memory block, file, and in general - any resource. Once the number of references reaches <b>0</b>, that resource is collected and destroyed. An interesting aspect of this is that, when we destroy an object that is no longer referenced by anything, if that object holds a references to another object, after the destruction of the <b>de-referenced</b> object, the other <b>subsequently referenced</b> object has its reference count decremented. So there is also another technique, where we can add the <b>no-longer-referenced-objects</b> to a list, which we regularly (and by we I mean the GC) visit and destroy some objects from it. All of these processes require constant updating. There are several advantages to reference counting, although it being simple - for one, it's very responsive as it <b>doesn't</b> waste any time in de-allocating space for us, thus making it adequate for systems with limited memory. Also the performance of this doesn't go down as the memory is freed. The problem to all of this is that this algorithm takes up memory spaces for the counts, it is not the most efficient method, that is why it's so simple, and it also can't prevent <b>reference cycles</b>. A <b>reference cycle</b> is just an object that refers to itself <b>directly</b> or <b>indirectly</b>. This means that their reference count is going to be always above zero. Here <b>weak references</b> come in handy since they can break such a chain.
</p>

<p>
(In this whole segment I managed to re-use the word "reference" 20 times&#x2026;geez, talk about DRY)
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org55cae3c">
<h4 id="org55cae3c">Rule of five</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">utility</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">resource</span>
<span class="linenr"> 3: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 4: </span>  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">foo</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span>  <span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">10: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">()</span> : p<span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #d26937;">{}</span><span style="color: #33859e;">}</span> <span style="color: #33859e;">{</span> <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">default ctor</span>
<span class="linenr">11: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">foo</span>&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> : p<span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #d26937;">{</span>*<span style="color: #888ca6;">(</span>other.p<span style="color: #888ca6;">)</span><span style="color: #d26937;">}</span><span style="color: #33859e;">}</span> <span style="color: #33859e;">{</span> <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">copy ctor</span>
<span class="linenr">12: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">(</span><span style="color: #d26937;">foo</span>&amp;&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> : p<span style="color: #33859e;">{</span>other.p<span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">move ctor</span>
<span class="linenr">13: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">14: </span>      other.p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">15: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #d26937;">foo</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">foo</span>&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">assignment operator</span>
<span class="linenr">18: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">19: </span>      <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #d26937;">(</span>&amp;other != <span style="color: #195466; font-weight: bold;">this</span><span style="color: #d26937;">)</span> <span style="color: #d26937;">{</span>
<span class="linenr">20: </span>        <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">21: </span>        p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">22: </span>        p = <span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #888ca6;">{</span>*<span style="color: #2aa889;">(</span>other.p<span style="color: #2aa889;">)</span><span style="color: #888ca6;">}</span>;
<span class="linenr">23: </span>      <span style="color: #d26937;">}</span>
<span class="linenr">24: </span>      <span style="color: #195466; font-weight: bold;">return</span> *<span style="color: #195466; font-weight: bold;">this</span>;
<span class="linenr">25: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span>    <span style="color: #d26937;">foo</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #d26937;">foo</span>&amp;&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">move assignment operator</span>
<span class="linenr">28: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">29: </span>      <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #d26937;">(</span>&amp;other != <span style="color: #195466; font-weight: bold;">this</span><span style="color: #d26937;">)</span> <span style="color: #d26937;">{</span>
<span class="linenr">30: </span>        <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">31: </span>        p = other.p;
<span class="linenr">32: </span>        other.p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">33: </span>      <span style="color: #d26937;">}</span>
<span class="linenr">34: </span>      <span style="color: #195466; font-weight: bold;">return</span> *<span style="color: #195466; font-weight: bold;">this</span>;
<span class="linenr">35: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">36: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">rest of class . . .</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">cont.</span>
<span class="linenr">1: </span>
<span class="linenr">2: </span>    ~<span style="color: #599cab;">foo</span><span style="color: #99d1ce;">()</span> <span style="color: #245361;">// </span><span style="color: #245361;">destructor</span>
<span class="linenr">3: </span>    <span style="color: #99d1ce;">{</span>
<span class="linenr">4: </span>      <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">5: </span>    <span style="color: #99d1ce;">}</span>
<span class="linenr">6: </span>
<span class="linenr">7: </span>  <span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">8: </span>    <span style="color: #d26937;">resource</span>* <span style="color: #599cab;">p</span>;
<span class="linenr">9: </span><span style="color: #091f2e; background-color: #99d1ce;">}</span>;
</pre>
</div>


<aside class="notes">
<p>
And finally let's talk about the <b>rule of five</b>. These are just a set of rules for building <b>exception safe</b> and <b>properly resource managed</b> code in C++. The first <b>three</b> rules can be summed up like this. If a class needs to have a user-defined <b>destructor</b>, or <b>copy constructor</b>, or <b>copy assignment operator</b>, then it most probably needs <b>all</b> three. Because we are handling resources in our classes, we will be working with references and pointers, which means that the default implementations of the constructors and destructor will not suffice for us, and we will need to implement them on our own (tutorial 1 covers briefly the topic of writing such custom implementations). The last two rules are also related to this. If we have these custom implementations in our code base, we must also implement a <b><b>move</b></b> constructor and a <b><b>move assignment operator</b></b>. Now we must acknowledge what a <b>move</b> constructor and <b>move assignment operator</b> is. Well basically, they are two new additions we have since <b>C++ 11</b>. They allow us to perform move semantics in C++ in a more efficient way.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org15b7c15">
<h3 id="org15b7c15">Using the STL to our advantage</h3>
<ul>
<li class="fragment roll-in"><code>unique_ptr</code></li>
<li class="fragment roll-in"><code>shared_ptr</code></li>
<li class="fragment roll-in"><code>weak_ptr</code></li>

</ul>

</section>
<section >

<p>
<code>unique_ptr</code>
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">foo</span> <span style="color: #99d1ce;">()</span>
<span class="linenr">1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">2: </span>    <span style="color: #d26937;">unique_ptr</span><span style="color: #33859e;">&lt;</span>Thing<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">p</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">Thing</span><span style="color: #d26937;">()</span><span style="color: #33859e;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">p owns the Thing</span>
<span class="linenr">3: </span>    p-&gt;do_something<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">tell the thing to do something</span>
<span class="linenr">4: </span>    defrangulate<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">might throw an exception</span>
<span class="linenr">5: </span><span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">p gets destroyed; destructor deletes the Thing</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #d26937;">unique_ptr</span><span style="color: #99d1ce;">&lt;</span>Thing<span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">p1</span> <span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">Thing</span><span style="color: #99d1ce;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">p1 owns the Thing</span>
<span class="linenr">1: </span><span style="color: #d26937;">unique_ptr</span><span style="color: #99d1ce;">&lt;</span>Thing<span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">p2</span><span style="color: #99d1ce;">(</span>p1<span style="color: #99d1ce;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">error - copy construction is not allowed.</span>
<span class="linenr">2: </span><span style="color: #d26937;">unique_ptr</span><span style="color: #99d1ce;">&lt;</span>Thing<span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">p3</span>; <span style="color: #245361;">// </span><span style="color: #245361;">an empty unique_ptr;</span>
<span class="linenr">3: </span>p3 = p1; <span style="color: #245361;">// </span><span style="color: #245361;">error, copy assignment is not allowed</span>
</pre>
</div>

<aside class="notes">
<p>
In the previous section I mentioned that we can use <b>smart pointers</b> to our advantage to handle heap memory and resources. Before we had to write out own memory management classes that worked likes smart pointers, when <b>C++ 11</b> first came out, we had <code>auto_ptr</code>, which tried to do that. But it was somewhat impaired to several functionalities like copying and assigning. Since then, <code>auto_ptr</code> is <b>deprecated</b> and instead we have 3 other types of smart pointers - <code>unique_ptr</code>, <code>weak_ptr</code>, and <code>share_ptr</code>. Now I want to get this out of the way, when working with smart pointers, <b>unique</b> is the standard and <b>shared</b> is the exception. Since both of them have different implementations, usually we are in need of having a pointer that is unique to a piece of memory, seldom will we need to distribute our resources over many pointers. That's why it's better to prefer <code>unique_ptr</code> to <code>shared_ptr</code>.
</p>

<p>
Because these two smart pointers are the most common ones, we can take a look at how they work.
</p>

<p>
So how does a <code>unique_ptr</code> look like? Well, it's basically using any other STL container, where we define a <code>T</code> inside of it and then we declare our variable. There are several big advantages to using this pointer. First, it has <b>zero</b> overhead. Because it has the <code>T*</code> implementation and being able to take in anything, it means that it points to anything and the moment that pointer goes out of scope, the pointer and the pointed data gets destroyed. <code>unique_ptr</code> allows us to manage resources without worrying about how they get released and how they get deleted when the time comes. The syntax is the same as using a raw pointer, so we don't have to worry about that. Also, the word <b>"unique"</b> isn't arbitrary. This pointer can <b>"own"</b> only one object, which means that we can avoid collisions, where multiple pointers can access one piece of data and leave it dangling afterwards. This means that we <b>cannot</b> <b>copy</b> nor <b>assign</b> one unique pointer to another (things like copy constructors and assignment operators are disallowed for this type).
</p>

</aside>

</section>
<section >

<p>
<code>shared_ptr</code>
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">foo</span><span style="color: #99d1ce;">()</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">the new is in the shared_ptr constructor expression:</span>
<span class="linenr"> 3: </span>    <span style="color: #d26937;">shared_ptr</span><span style="color: #33859e;">&lt;</span>Thing<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">p1</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">Thing</span><span style="color: #33859e;">)</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #d26937;">shared_ptr</span><span style="color: #33859e;">&lt;</span>Thing<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">p2</span> = p1; <span style="color: #245361;">// </span><span style="color: #245361;">p1 and p2 now share ownership of the Thing</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #d26937;">shared_ptr</span><span style="color: #33859e;">&lt;</span>Thing<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">p3</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">Thing</span><span style="color: #33859e;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">another Thing</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    p1 = find_some_thing<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">p1 may no longer point to first Thing</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>    do_something_with<span style="color: #33859e;">(</span>p2<span style="color: #33859e;">)</span>;
<span class="linenr">12: </span>
<span class="linenr">13: </span>    p3-&gt;defrangulate<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">call a member function like built-in pointer</span>
<span class="linenr">14: </span>
<span class="linenr">15: </span>    cout &lt;&lt; *p2 &lt;&lt; endl; <span style="color: #245361;">// </span><span style="color: #245361;">dereference like built-in pointer</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">reset with a member function or assignment to nullptr:</span>
<span class="linenr">18: </span>    p1.reset<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">decrement count, delete if last</span>
<span class="linenr">19: </span>    p2 = <span style="color: #33859e; font-weight: bold;">nullptr</span>; <span style="color: #245361;">// </span><span style="color: #245361;">convert nullptr to an empty shared_ptr, and decrement count;</span>
<span class="linenr">20: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Now that we know what so unique about <code>unique_ptr</code>, we can talk about <b>shared pointers</b>. The syntax and basic functionality of a <code>shared_ptr</code> are the same as any other smart pointer, but there are some implementation differences. For one, we can have multiple pointers that can share the same object on the free store (hence the name <b>shared</b>). Using the powers of reference counting, depending on how many references there are to the specific object, C++ can determine when to delete that memory space. This is how it works - once a pointer get out of scope or gets assigned to a <code>nullptr</code>, the total reference count gets decremented. If the number reaches <b>zero</b>, the object gets deleted. If we are to get into the situation of a <b>reference cycle</b>, the smart <code>shared_ptr</code> got us covered by using the so called <code>weak_ptr</code>. These <b>weak pointers</b> are used only as observers to the actual object and <b>do not</b> affect its lifetime. Because of this, the shared state between the objects is known to C++, the reference counts don't get confused and we get proper object deletion when the count is at 0.
</p>

<p>
From the above code we can trace how the shared pointer managed and shares the resource it points to. We can decrement the counter manually or through <code>nullptr</code> assignment.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org44792de">
<h2 id="org44792de">General good practices</h2>
<div class="outline-text-2" id="text-org44792de">
</div>
</section>
</section>
<section>
<section id="slide-org69ade16">
<h3 id="org69ade16">Use <code>const</code> whenever possible</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">char</span> <span style="color: #599cab;">greeting</span><span style="color: #99d1ce;">[]</span> = <span style="color: #2aa889;">"Hello"</span>; <span style="color: #245361;">// </span><span style="color: #245361;">basic C string</span>
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #d26937;">char</span> *<span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">no const pointer</span>
<span class="linenr"> 3: </span>                    <span style="color: #245361;">// </span><span style="color: #245361;">no const data</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">char</span> *<span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">no const pointer</span>
<span class="linenr"> 6: </span>                          <span style="color: #245361;">// </span><span style="color: #245361;">const data</span>
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #d26937;">char</span> * <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">const pointer</span>
<span class="linenr"> 9: </span>                           <span style="color: #245361;">// </span><span style="color: #245361;">no const data</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">char</span> * <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">const pointer</span>
<span class="linenr">12: </span>                                 <span style="color: #245361;">// </span><span style="color: #245361;">const data</span>
</pre>
</div>

<aside class="notes">
<p>
We have already talked about the advantages of <b>pass-by-reference-to-const</b> before and we are aware of its benefits. But we can generalize this rule to integrate <code>const</code> in more than just function calls. We know what <code>const</code> does - it tells the compiler that a specific implementation <b>cannot</b> change over the course of the program. Such reinforcement is not only about telling the compiler that, but it also help us follow good semantics in our code. Such constraints also help us to minimize bugs, which might accumulate if we are not careful how we are changing the state of our objects. Outside of classes, <code>const</code> can be used to declare global and namespace variables. In classes we can create both <b>static</b> and <b>non-static</b> constant data members. The problem with this keyword is that it has confusing syntax when it comes to pointers. Because we can declare a pointer to be <code>const</code>, we can declare the data the pointer points to be <code>const</code>, or make both the pointer and the pointed contents constant. So when we put <code>const</code> <b>before</b> the asterisk in a definition, we are telling the compiler that the data contents are constant, but the pointer can change its "pointing". If we put the keyword <b>after</b> the asterisk, the pointer itself will point to only one place and cannot be changed, but the data can be (so we can change the data through another pointer and the constant pointer will still point to the same memory location). Finally we can make them both constants, which just halts a specific part of memory that cannot be changed. <b>Tip:</b> it might be helpful, when reading pointer declarations, to start from right to left, since when you say it out loud it would sound natural.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">TextBlock</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">char</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #33859e;">[]</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">position</span><span style="color: #33859e;">)</span> <span style="color: #195466; font-weight: bold;">const</span>
<span class="linenr"> 4: </span>    <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> text<span style="color: #d26937;">[</span>position<span style="color: #d26937;">]</span>; <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">operator[] for const objects</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #d26937;">char</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #33859e;">[]</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">position</span><span style="color: #33859e;">)</span>
<span class="linenr"> 7: </span>    <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> text<span style="color: #d26937;">[</span>position<span style="color: #d26937;">]</span>; <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">operator[] for non-const objects</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">10: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">text</span>;
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #d26937;">TextBlock</span> <span style="color: #599cab;">tb</span><span style="color: #99d1ce;">(</span><span style="color: #2aa889;">"Hello"</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">14: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; tb<span style="color: #99d1ce;">[</span><span style="color: #33859e; font-weight: bold;">0</span><span style="color: #99d1ce;">]</span>; <span style="color: #245361;">// </span><span style="color: #245361;">calls non-const TextBlock::operator[]</span>
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">TextBlock</span> <span style="color: #599cab;">ctb</span><span style="color: #99d1ce;">(</span><span style="color: #2aa889;">"World"</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">17: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; ctb<span style="color: #99d1ce;">[</span><span style="color: #33859e; font-weight: bold;">0</span><span style="color: #99d1ce;">]</span>; <span style="color: #245361;">// </span><span style="color: #245361;">calls const TextBlock::operator[]</span>
</pre>
</div>

<aside class="notes">
<p>
Apart from making data members constant, we can also look at constant member functions. The two benefits we get is that we are creating an interface that is telling us what should be what, thus making it easier to understand. The second part is that they will allows us to work with constant objects, thus making our work, by passing by objects by reference to <code>const</code> much, easier. There is another thing about constant member functions, and that is that they can differ only on their constness, allowing us overload them based only on that.
</p>

<p>
Now we should take some time to talk about the two different types of constness we can have in C++. There is <b>bitwise (logical) constness</b> and <b>logical constness</b>. To be bitwise const means that, inside a constant member function, we are not allowed to change <b><b>any</b></b> of the class data members. Basically this corresponds to the C++ understanding what <code>const</code> is. The compiler just searches in the function body for any assignment operators that might change some <b>non-static</b> state in the object. But bitwise constness doesn't always do what it might seem to do. If we have a pointer that points to something and the function is <code>const</code>, the data that the pointer points to can still be changed. This means that we can write our functions <code>const</code> all we want, but that doesn't guarantee that <b><b>all</b></b> of the data will remain unchanged. This leads us to the notion of <b>logical constness</b>. This means that const member functions can change the values of data members as long as the change is <b>unseen</b> from the user perspective. In general it's a good idea to prefer logical over bitwise constness.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">CTextBlock</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">length</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr"> 6: </span>    <span style="color: #d26937;">char</span> *<span style="color: #599cab;">pText</span>;
<span class="linenr"> 7: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">textLength</span>;
<span class="linenr"> 8: </span>    <span style="color: #d26937;">bool</span> <span style="color: #599cab;">lengthIsValid</span>;
<span class="linenr"> 9: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #33859e; font-weight: bold;">CTextBlock</span>::<span style="color: #599cab;">length</span><span style="color: #99d1ce;">()</span> <span style="color: #195466; font-weight: bold;">const</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">13: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span><span style="color: #c23127;">!</span>lengthIsValid<span style="color: #33859e;">)</span>
<span class="linenr">14: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">15: </span>        <span style="color: #245361;">// </span><span style="color: #245361;">error!</span>
<span class="linenr">16: </span>        textLength = <span style="color: #33859e; font-weight: bold;">std</span>::strlen<span style="color: #d26937;">(</span>pText<span style="color: #d26937;">)</span>;
<span class="linenr">17: </span>        lengthIsValid = <span style="color: #33859e; font-weight: bold;">true</span>;
<span class="linenr">18: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">19: </span>    <span style="color: #195466; font-weight: bold;">return</span> lengthIsValid;
<span class="linenr">20: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">CTextBlock</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">length</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr"> 6: </span>    <span style="color: #d26937;">char</span> *<span style="color: #599cab;">pText</span>;
<span class="linenr"> 7: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">mutable allows us to change the values</span>
<span class="linenr"> 8: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">even in const functions</span>
<span class="linenr"> 9: </span>    <span style="color: #195466; font-weight: bold;">mutable</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">textLength</span>;
<span class="linenr">10: </span>    <span style="color: #195466; font-weight: bold;">mutable</span> <span style="color: #d26937;">bool</span> <span style="color: #599cab;">lengthIsValid</span>;
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #33859e; font-weight: bold;">CTextBlock</span>::<span style="color: #599cab;">length</span><span style="color: #99d1ce;">()</span> <span style="color: #195466; font-weight: bold;">const</span>
<span class="linenr">14: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">15: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span><span style="color: #c23127;">!</span>lengthIsValid<span style="color: #33859e;">)</span>
<span class="linenr">16: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">17: </span>        <span style="color: #245361;">// </span><span style="color: #245361;">valid calls</span>
<span class="linenr">18: </span>        textLength = <span style="color: #33859e; font-weight: bold;">std</span>::strlen<span style="color: #d26937;">(</span>pText<span style="color: #d26937;">)</span>;
<span class="linenr">19: </span>        lengthIsValid = <span style="color: #33859e; font-weight: bold;">true</span>;
<span class="linenr">20: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">21: </span>    <span style="color: #195466; font-weight: bold;">return</span> lengthIsValid;
<span class="linenr">22: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Let's take this example - we want to cache the length of the string we have, which means that inside of the <code>length()</code> function we need to make an assignment, but at the same time the function should be constant (as per good conventions). In this situation, we can see that if we want to save some internal state of the object, we must violate the bitwise constness of the function, that's why we can overcome this by applying the logical constness, and use the <code>mutable</code> keyword. It allows us to change the state of a data member even in situations where we have a <code>const</code> function. This is what logical constness looks like, because the user has on idea we are changing the internal state of the object, but at the same time, we are following the logic of what we want to do, that is - to save some cached state.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0537bc5">
<h3 id="org0537bc5">Postpone variable definitions</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">encryptPassword</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">password</span><span style="color: #99d1ce;">)</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #d26937;">string</span> <span style="color: #599cab;">encrypted</span>;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>password.length<span style="color: #d26937;">()</span> &lt; MinimumPasswordLength<span style="color: #33859e;">)</span>
<span class="linenr"> 5: </span>    <span style="color: #33859e;">{</span>
<span class="linenr"> 6: </span>        <span style="color: #195466; font-weight: bold;">throw</span> logic_error<span style="color: #d26937;">(</span><span style="color: #2aa889;">"Password is too short"</span><span style="color: #d26937;">)</span>;
<span class="linenr"> 7: </span>    <span style="color: #33859e;">}</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">work</span>
<span class="linenr">10: </span>    <span style="color: #195466; font-weight: bold;">return</span> encrypted;
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">encryptPassword</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">password</span><span style="color: #99d1ce;">)</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>password.length<span style="color: #d26937;">()</span> &lt; MinimumPasswordLength<span style="color: #33859e;">)</span>
<span class="linenr"> 3: </span>    <span style="color: #33859e;">{</span>
<span class="linenr"> 4: </span>        <span style="color: #195466; font-weight: bold;">throw</span> <span style="color: #d26937;">logic_error</span><span style="color: #d26937;">(</span><span style="color: #2aa889;">"Password is too short"</span><span style="color: #d26937;">)</span>;
<span class="linenr"> 5: </span>    <span style="color: #33859e;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #d26937;">string</span> <span style="color: #599cab;">encrypted</span>;
<span class="linenr"> 8: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">work</span>
<span class="linenr"> 9: </span>    <span style="color: #195466; font-weight: bold;">return</span> encrypted;
<span class="linenr">10: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">encryptPassword</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">password</span><span style="color: #99d1ce;">)</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">import std and check length as above</span>
<span class="linenr"> 3: </span>    <span style="color: #d26937;">string</span> <span style="color: #599cab;">encrypted</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">default-construct encrypted</span>
<span class="linenr"> 6: </span>    encrypted = password;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">assign to encrypted</span>
<span class="linenr"> 9: </span>    encrypt<span style="color: #33859e;">(</span>encrypted<span style="color: #33859e;">)</span>;
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #195466; font-weight: bold;">return</span> encrypted;
<span class="linenr">12: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">encryptPassword</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">password</span><span style="color: #99d1ce;">)</span>
<span class="linenr">1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">2: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">define and initialize via copy</span>
<span class="linenr">3: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">constructor</span>
<span class="linenr">4: </span>    <span style="color: #d26937;">string</span> <span style="color: #599cab;">encrypted</span><span style="color: #33859e;">(</span>password<span style="color: #33859e;">)</span>;
<span class="linenr">5: </span>
<span class="linenr">6: </span>    encrypt<span style="color: #33859e;">(</span>encrypted<span style="color: #33859e;">)</span>;
<span class="linenr">7: </span>    <span style="color: #195466; font-weight: bold;">return</span> encrypted;
<span class="linenr">8: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This might seem intuitive at first, but there are real benefits to postponing your declarations and initialization <b>as much as possible</b>. Because we are dealing with the overhead of constructing and destructing every object in our scope, being able to <b>"tighten-up"</b> our program can lead to better optimizations. We can fall in the cases, where we might think we are using a certain variable, because our compiler is not complaining about it, but take for instance the examples. We can see that the construction of the string object happens before the test case. If the <code>try-catch</code> block throws, the string was created for no apparent reason. If we refactor the code, it will create the string only when it is really needed, instead of preemptively allocating it. We can even further improve this code by assigning it a value as we are defining it. If we first define it and then assign a value, we are calling the default constructor first, and then we are calling the assignment operator to give the string a value. But if we just make this into one whole statement it will perform only one operation. We know that copy constructors are sometimes even <b>more efficient</b> than the default ones, so we can utilize this to our advantage. So we can not only postpone definitions of a variable, but we can also postpone initialization operations too, where we can optimize how a variable is created. This way we are avoiding calls to the constructor and destructor and sparing ourselves unneeded objects.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">Approach A: define outside loop</span>
<span class="linenr"> 1: </span><span style="color: #d26937;">Widget</span> <span style="color: #599cab;">w</span>;
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">for</span> <span style="color: #99d1ce;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = <span style="color: #33859e; font-weight: bold;">0</span>; i &lt; n; ++i<span style="color: #99d1ce;">)</span>
<span class="linenr"> 3: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 4: </span>    w = some value dependent on i;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #245361;">// </span><span style="color: #245361;">Approach B: define inside loop</span>
<span class="linenr"> 8: </span><span style="color: #195466; font-weight: bold;">for</span> <span style="color: #99d1ce;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = <span style="color: #33859e; font-weight: bold;">0</span>; i &lt; n; ++i<span style="color: #99d1ce;">)</span>
<span class="linenr"> 9: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">10: </span>    <span style="color: #d26937;">Widget</span> <span style="color: #599cab;">w</span><span style="color: #33859e;">(</span> some value dependent <span style="color: #d26937;">on</span> <span style="color: #599cab;">i</span><span style="color: #33859e;">)</span>;
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
But what about this case, where we have loops. Should we define the variable outside of the scope of the loop or initialize it <b>every</b> time we go over the iterations. We have two situations. In case <b>A</b> : we have <code>1 constructor + 1 destructor + n assignments</code>. In case <b>B</b> : we have <code>n constructors + n destructors</code>. Case <b>A</b> is valid when the assignment operator is <b>more efficient</b> than the constructor, which can be seen in situations where <code>n</code> is very large. Otherwise approach <b>B</b> is better. Also keep in mind that case <b>A</b> reveals the variable object into <b>larger scope</b> than we need it to be. So in general, we should rely on the second case, where the object is assigned inside of the loop body.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orga336db8">
<h2 id="orga336db8">Resources</h2>
<div class="outline-text-2" id="text-orga336db8">
</div>
</section>
</section>
<section>
<section id="slide-org62ce831">
<h3 id="org62ce831">Memory Management</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/26423270/why-use-new-and-delete-at-all">Why use new and delete</a></li>
<li><a href="https://stackoverflow.com/questions/11603005/what-does-delete-command-really-do-for-memory-for-pointers-in-c">What does delete do</a></li>
<li><a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii">RAII</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/raii">RAII 2</a></li>
<li><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Wiki RAII</a></li>
<li><a href="https://stackoverflow.com/questions/147130/why-doesnt-c-have-a-garbage-collector">Why don't we have a GC in C++</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/113177/why-do-languages-such-as-c-and-c-not-have-garbage-collection-while-java-does">Why no GC in C++</a></li>
<li><a href="http://hboehm.info/gc/">Garbage collector for C++</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reference_counting#reference_cycle">Reference counting</a></li>
<li><a href="https://en.wikipedia.org/wiki/Weak_reference">Weak references</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rule_of_three_(C++_programming)">Rule of 3</a></li>
<li><a href="https://cpppatterns.com/patterns/rule-of-five.html">Rule of 5</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/rule_of_three">Rule of 3/5/0</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/dd293665.aspx">Move constructor and assignment operator</a></li>
<li><a href="https://blog.smartbear.com/c-plus-plus/c11-tutorial-introducing-the-move-constructor-and-the-move-assignment-operator/">C++ 11 move</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/move_constructor">Move constructors</a></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf9bcaba">
<h3 id="orgf9bcaba">Pointers</h3>
<ul>
<li><a href="https://visualstudiomagazine.com/articles/2012/10/19/circular-references.aspx">Circular references</a></li>
<li><a href="https://mortoray.com/2012/01/08/what-is-reference-counting/">What is reference counting</a></li>
<li><a href="http://umich.edu/~eecs381/handouts/C++11_smart_ptrs.pdf">Smart pointer</a></li>
<li><a href="https://www.thegeekstuff.com/2015/02/cpp-smart-pointers/">CPP and smart pointers</a></li>
<li><a href="https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby">Ownership semantics</a></li>
<li><a href="https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one">What is a smart pointer</a></li>
<li><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">Shared pointer</a></li>
<li><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">Unique pointer</a></li>
<li><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr">Weak pointer</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
