<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Resource Management and Good practices</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Resource Management and Good practices</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-02-07 Wed 18:13</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org3d4ce4a">How to manage memory</a></li>
<li><a href="#/slide-orgbf77806">General good practices</a></li>
<li><a href="#/slide-org8e151aa">Exercises</a></li>
<li><a href="#/slide-orgac05237">Resources</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-org3d4ce4a">
<h2 id="org3d4ce4a">How to manage memory</h2>
<aside class="notes">
<p>
When we first learn C++ for the first time we have way too many things going on so we are usually told not to worry about memory management (or we are not even aware that such a thing exists in the language). This is normal, since the language itself is hard enough to learn so we push thins topic for another time. But that time usually comes way too late and we don't have the discipline to think in therms of memory management. Luckily for us, we are writing modern C++, which means that there are a lot of tools deisgn to help us out with this task and to make it much more easy, than it was back in '89.
</p>

<p>
In C++ we have several resources we can manage, where we are not only limited to some dynamically allocated object. We care for files, database connections, mutexes, GUIs, sockets, etc. This means that having memory leaks is just one of our problems, but being unable to connect to a databse, or corrupt the contents of a file, because we are not careful enough is a whole other story. Here we will try to look at how we can use the STL to our advantage and manage resources manually.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org024c1d0">
<h3 id="org024c1d0">When to use <code>new</code> and <code>delete</code></h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">int</span> * <span style="color: #599cab;">ipt</span> = <span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">int</span>;
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"ipt = "</span> &lt;&lt; ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 3: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 4: </span>*ipt = <span style="color: #33859e; font-weight: bold;">1000</span>;
<span class="linenr"> 5: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">delete</span> ipt;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"ipt = "</span> &lt;&lt; ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">10: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl
</pre>
</div>

<aside class="notes">
<p>
When do we actually have to use <code>new</code> and <code>delete</code>? It's so tempting to just say <b>never</b> and move on to the rest of the topics, but this is not exactly true. It's <b>almost</b> true. First let's look at what <code>new</code> and <code>delete</code> do. <code>new</code> is the keyword we use in C++ that allocates a piece of memory in the <b>local store</b> and has a pointer to that piece of anonymous data. <code>delete</code> on the other hand does the opposite and removes the contents of a cell of memory. So let's look at an example. Here we just allocate an integer to the free store and then we read the pointer address and the address contents. The question is what would happen after the <code>delete</code> call? Would we have to same contents or would we get the same number again? The answer is - we would get <b><b>undefined</b></b> behavior. After you call delete, you can still use the pointer for other things, but never ever try to see what it points to, since we will go down the valley of <b>undefined</b> behavior.
</p>

<p>
So using <code>new</code> and <code>delete</code> can lead to peril if we are not careful, so what are our other options?
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org4229bbe">
<h3 id="org4229bbe">A pass by over garbage collection</h3>
<ul>
<li class="fragment roll-in">Weak references</li>
<li class="fragment roll-in">Reference counting</li>
<li class="fragment roll-in">Smart pointers</li>
<li class="fragment roll-in">Rule of three (or 5)</li>

</ul>

<aside class="notes">
<p>
Let's just go over some interesting and important notes about garbage collection and memory management before we continue with the main topics. Why doesn't C++ have a garbage collector like <code>Java</code> or <code>C#</code> or some other languages? Well it's not impossible and there are some implementations of a C++ garbage collector, but it's not something that is used widely in the C++ sphere. There are a lot of reasons why this is so, time constraints, agreements between the C++ implementation group, implementation problems in general, etc. The thing with garbage collection is that it's a pretty heavy process and it isn't as simple as pushing everything into smart pointers and calling it a day. C++ is above all efficient, it gives us a lot of room to make whatever we like. The garbage collection we have is the explicit one we can achieve through smart pointers, but there isn't a thing like the <code>Java</code> or <code>C#</code> collector (an implicit GC) (As a side note, I have included a link to a <b>C++ GC</b> if you still want to try it out). So the question here is - how do smart pointers work in C++. Everybody is talking about them, they do have great functionalities, but how are they actually helpful?
</p>

<p>
In order to understand these concept we need to cover several topics. Let's start with <b>weak references</b>. In general, abstracting ourselves from C++, a <b>weak reference</b> is a pointer that does not protect the content that pointer points to from a garbage collector. If we have a chain of references to an object and even if one of those references are weak, the whole chain is considered to be weak and can be collected at any moment. Now there are several layers of weak references and we can find them in implementations in <code>Java</code>, <code>C#</code>, <code>python</code>, etc. In general, there are two types of GC - <b>tracing</b> and <b>reference counting</b>. We are going to look only <b>reference counting</b> since it's relevant to us.
</p>

<p>
Now <b><b>reference counting</b></b> is a technique where we count the number of references, handlers, and pointers to a certain object, memory block, file, and in general - any resource. Once the number of references reaches <b>0</b>, that resource is collected and destroyed. An interesting aspect of this is that when we destroy an object that is no longer referenced by anything, if that object holds a references to another object, after the destruction of the de-referenced object, the other referenced object have their reference count decremented. So there is also a technique where we can add the no longer referenced objects to a list, which we regularly (and by we I mean the GC) visit and destroy some objects from it. All of these processes require constant updating. There are several advantages to this technique, although it being simple - for one, it's very responsive as it doesn't waste any time in de-allocating space for us, thus making it adequate for systems with limited memory. Also the performance of this doesn't go down as the memory is freed. The problem to all of this is that this algorithm takes up memory spaces for the counts, it is not the most efficient method, that is why it's so simple, and it also can't prevent <b>reference cycles</b>. A <b>reference cycle</b> is just an object that refers to itself <b>directly</b> or <b>indirectly</b>. This means that their reference count is going to be always above zero. Here <b>weak references</b> come in handy since they can break such a chain.
</p>

<p>
(In this whole segment I managed to re-use the word "reference" 20 times&#x2026;geez, talk about DRY)
</p>

<p>
Okay now let's talk about some smart pointers. In general they are some abstract data type that provide the functionality to de-allocate memory for us and to release resources.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org50fa750">
<h3 id="org50fa750">RAII</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">without RAII</span>
<span class="linenr"> 1: </span><span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">handle</span>=createNewResource<span style="color: #99d1ce;">()</span>;
<span class="linenr"> 2: </span>handle-&gt;performInvalidOperation<span style="color: #99d1ce;">()</span>;  <span style="color: #245361;">// </span><span style="color: #245361;">this will throw an excpetion</span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">some code</span>
<span class="linenr"> 4: </span>deleteResource<span style="color: #99d1ce;">(</span>handle<span style="color: #99d1ce;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">resource leek never cleaned!</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #245361;">// </span><span style="color: #245361;">with RAII</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">SomeResource</span> <span style="color: #99d1ce;">{</span>
<span class="linenr"> 8: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 9: </span>   <span style="color: #599cab;">SomeResource</span><span style="color: #33859e;">(</span><span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">rawRes_</span><span style="color: #33859e;">)</span> : rawRes<span style="color: #33859e;">(</span>rawRes_<span style="color: #33859e;">)</span> <span style="color: #33859e;">{}</span>;
<span class="linenr">10: </span>   ~<span style="color: #599cab;">SomeResource</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">delete</span> rawRes; <span style="color: #33859e;">}</span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">12: </span>   <span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">rawRes</span>;
<span class="linenr">13: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #d26937;">SomeResource</span> <span style="color: #599cab;">handle</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">createNewResource</span><span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">16: </span>handle-&gt;performInvalidOperation<span style="color: #99d1ce;">()</span>;
</pre>
</div>

<aside class="notes">
<p>
In C++ we have this magical idiom called <b><b>RAII</b></b>, or <b>Resource Acquisition Is Initialization</b>. This binds the life cycle of a resource that must be acquired before use, to the lifetime of an object. Again, we are not just talking about pieces of memory, but sockets, database connections, file descriptors, mutexes, things that are considered as a resources, are bounded to an object. Then, functions are able to access that resource (through the object), use it, and when it is no longer needed, the object manages the state of the resource, and closes it appropriately. You might also see this idiom as <b>Scope-Bound Resource Management</b>. The important thing here is that even when we get an exception during some constructor, the already created base objects are also released in reverse order of initialization. We are both managing resource leaks and exception safety!! C++ provides us with some ready-made solutions to this principle. <code>vector</code>, <code>string</code>, and <code>thread</code> manage their resources on their own so we don't have to worry about them, but we also have <code>unique_ptr</code> and <code>shared_ptr</code> where we can manage resources and not worry about their releasing and exceptions.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orga5cf0ec">
<h3 id="orga5cf0ec">Using the STL to our advantage</h3>
<aside class="notes">
<p>
In the previous section I mentioned that we can use smart pointers to our advantage to handle heap memory and resources. Before we had to write out own memory management classes that worked likes smart pointers, when C++ 11 first came out, we had <code>auto_ptr</code>, which tried to do that. But it was somewhat impaired to several functionalities like copying and assigning. Since then, <code>auto_ptr</code> is deprecated and we use either <code>unique_ptr</code> or <code>share_ptr</code>. Now I want to get this out of the way, when working with smart pointers, <b>unique</b> is the standard and <b>shared</b> is the exception.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc85c87c">
<h3 id="orgc85c87c">How to store objectes in smart pointers</h3>

</section>
</section>
<section>
<section id="slide-orgbf77806">
<h2 id="orgbf77806">General good practices</h2>
<div class="outline-text-2" id="text-orgbf77806">
</div>
</section>
</section>
<section>
<section id="slide-orge4d22aa">
<h3 id="orge4d22aa">Use <code>const</code>, <code>enums</code>, and <code>inline</code></h3>
</section>
</section>
<section>
<section id="slide-orgabfe6dd">
<h3 id="orgabfe6dd">Make full copies of objects</h3>
</section>
</section>
<section>
<section id="slide-orgbfda228">
<h3 id="orgbfda228">Postpone variable definitions</h3>

</section>
</section>
<section>
<section id="slide-org8e151aa">
<h2 id="org8e151aa">Exercises</h2>

</section>
</section>
<section>
<section id="slide-orgac05237">
<h2 id="orgac05237">Resources</h2>
<div class="outline-text-2" id="text-orgac05237">
</div>
</section>
</section>
<section>
<section id="slide-org3860e95">
<h3 id="org3860e95">Memory Management</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii">RAII</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/raii">RAII 2</a></li>
<li><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Wiki RAII</a></li>
<li><a href="https://stackoverflow.com/questions/147130/why-doesnt-c-have-a-garbage-collector">Why don't we have a GC in C++</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/113177/why-do-languages-such-as-c-and-c-not-have-garbage-collection-while-java-does">Why no GC in C++</a></li>
<li><a href="http://hboehm.info/gc/">Garbage collector for C++</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reference_counting#reference_cycle">Reference counting</a></li>
<li><a href="https://en.wikipedia.org/wiki/Weak_reference">Weak references</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
