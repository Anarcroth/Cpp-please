<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Resource Management and Good practices</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Resource Management and Good practices</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-02-12 Mon 22:13</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org4b1378d">How to manage memory</a></li>
<li><a href="#/slide-orgd4be2e9">General good practices</a></li>
<li><a href="#/slide-orge057309">Exercises</a></li>
<li><a href="#/slide-orga50416e">Resources</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-org4b1378d">
<h2 id="org4b1378d">How to manage memory</h2>
<aside class="notes">
<p>
When we first learn C++ for the first time we have way too many things going on so we are usually told not to worry about memory management (or we are not even aware that such a thing exists in the language). This is normal, since the language itself is hard enough to learn so we push thins topic for another time. But that time usually comes way too late and we don't have the discipline to think in therms of memory management. Luckily for us, we are writing modern C++, which means that there are a lot of tools deisgn to help us out with this task and to make it much more easy, than it was back in '89.
</p>

<p>
In C++ we have several resources we can manage, where we are not only limited to some dynamically allocated object. We care for files, database connections, mutexes, GUIs, sockets, etc. This means that having memory leaks is just one of our problems, but being unable to connect to a databse, or corrupt the contents of a file, because we are not careful enough is a whole other story. Here we will try to look at how we can use the STL to our advantage and manage resources manually.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0fbc039">
<h3 id="org0fbc039">RAII</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">without RAII</span>
<span class="linenr"> 1: </span><span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">handle</span>=createNewResource<span style="color: #99d1ce;">()</span>;
<span class="linenr"> 2: </span>handle-&gt;performInvalidOperation<span style="color: #99d1ce;">()</span>;  <span style="color: #245361;">// </span><span style="color: #245361;">this will throw an excpetion</span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">some code</span>
<span class="linenr"> 4: </span>deleteResource<span style="color: #99d1ce;">(</span>handle<span style="color: #99d1ce;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">resource leek never cleaned!</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #245361;">// </span><span style="color: #245361;">with RAII</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">SomeResource</span> <span style="color: #99d1ce;">{</span>
<span class="linenr"> 8: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 9: </span>   <span style="color: #599cab;">SomeResource</span><span style="color: #33859e;">(</span><span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">rawRes_</span><span style="color: #33859e;">)</span> : rawRes<span style="color: #33859e;">(</span>rawRes_<span style="color: #33859e;">)</span> <span style="color: #33859e;">{}</span>;
<span class="linenr">10: </span>   ~<span style="color: #599cab;">SomeResource</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">delete</span> rawRes; <span style="color: #33859e;">}</span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">12: </span>   <span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">rawRes</span>;
<span class="linenr">13: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #d26937;">SomeResource</span> <span style="color: #599cab;">handle</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">createNewResource</span><span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">16: </span>handle-&gt;performInvalidOperation<span style="color: #99d1ce;">()</span>;
</pre>
</div>

<aside class="notes">
<p>
In C++ we have this magical idiom called <b><b>RAII</b></b>, or <b>Resource Acquisition Is Initialization</b>. This binds the life cycle of a resource that must be acquired before use, to the lifetime of an object. Again, we are not just talking about pieces of memory, but sockets, database connections, file descriptors, mutexes, things that are considered as a resources, are bounded to an object. Then, functions are able to access that resource (through the object), use it, and when it is no longer needed, the object manages the state of the resource, and closes it appropriately. You might also see this idiom as <b>Scope-Bound Resource Management</b>. The important thing here is that even when we get an exception during some constructor, the already created base objects are also released in reverse order of initialization. We are both managing resource leaks and exception safety!! C++ provides us with some ready-made solutions to this principle. <code>vector</code>, <code>string</code>, and <code>thread</code> manage their resources on their own so we don't have to worry about them, but we also have <code>unique_ptr</code> and <code>shared_ptr</code> where we can manage resources and not worry about their releasing and exceptions.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgf3fb51e">
<h3 id="orgf3fb51e">When to use <code>new</code> and <code>delete</code></h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">int</span> * <span style="color: #599cab;">ipt</span> = <span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">int</span>;
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"ipt = "</span> &lt;&lt; ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 3: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 4: </span>*ipt = <span style="color: #33859e; font-weight: bold;">1000</span>;
<span class="linenr"> 5: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">delete</span> ipt;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"ipt = "</span> &lt;&lt; ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">10: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl
</pre>
</div>

<aside class="notes">
<p>
When do we actually have to use <code>new</code> and <code>delete</code>? It's so tempting to just say <b>never</b> and move on to the rest of the topics, but this is not exactly true. It's <b>almost</b> true. First let's look at what <code>new</code> and <code>delete</code> do. <code>new</code> is the keyword we use in C++ that allocates a piece of memory in the <b>local store</b> and has a pointer to that piece of anonymous data. <code>delete</code> on the other hand does the opposite and removes the contents of a cell of memory. So let's look at an example. Here we just allocate an integer to the free store and then we read the pointer address and the address contents. The question is what would happen after the <code>delete</code> call? Would we have to same contents or would we get the same number again? The answer is - we would get <b><b>undefined</b></b> behavior. After you call delete, you can still use the pointer for other things, but never ever try to see what it points to, since we will go down the valley of <b>undefined</b> behavior.
</p>

<p>
So using <code>new</code> and <code>delete</code> can lead to peril if we are not careful, so what are our other options?
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgef8bdd9">
<h3 id="orgef8bdd9">A pass by over garbage collection</h3>
<ul>
<li class="fragment roll-in">Weak references</li>
<li class="fragment roll-in">Reference counting</li>
<li class="fragment roll-in">Rule of five</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf85bfd2">
<h4 id="orgf85bfd2">Weak references</h4>
<aside class="notes">
<p>
Let's just go over some interesting and important notes about garbage collection and memory management before we continue with the main topics. Why doesn't C++ have a garbage collector like <code>Java</code> or <code>C#</code> or some other languages? Well it's not impossible and there are some implementations of a C++ garbage collector, but it's not something that is used widely in the C++ sphere. There are a lot of reasons why this is so, time constraints, agreements between the C++ implementation group, implementation problems in general, etc. The thing with garbage collection is that it's a pretty heavy process and it isn't as simple as pushing everything into smart pointers and calling it a day. C++ is above all efficient, it gives us a lot of room to make whatever we like. The garbage collection we have is the explicit one we can achieve through smart pointers, but there isn't a thing like the <code>Java</code> or <code>C#</code> collector (an implicit GC) (As a side note, I have included a link to a <b>C++ GC</b> if you still want to try it out). So the question here is - how do smart pointers work in C++. Everybody is talking about them, they do have great functionalities, but how are they actually helpful?
</p>

<p>
In order to understand these concept we need to cover several topics. Let's start with <b>weak references</b>. In general, abstracting ourselves from C++, a <b>weak reference</b> is a pointer that does not protect the content that pointer points to from a garbage collector. If we have a chain of references to an object and even if one of those references are weak, the whole chain is considered to be weak and can be collected at any moment. Now there are several layers of weak references and we can find them in implementations in <code>Java</code>, <code>C#</code>, <code>python</code>, etc. In general, there are two types of GC - <b>tracing</b> and <b>reference counting</b>. We are going to look only <b>reference counting</b> since it's relevant to us.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orge44cc7f">
<h4 id="orge44cc7f">Reference counting</h4>
<aside class="notes">
<p>
Now <b><b>reference counting</b></b> is a technique where we count the number of references, handlers, and pointers to a certain object, memory block, file, and in general - any resource. Once the number of references reaches <b>0</b>, that resource is collected and destroyed. An interesting aspect of this is that when we destroy an object that is no longer referenced by anything, if that object holds a references to another object, after the destruction of the de-referenced object, the other referenced object have their reference count decremented. So there is also a technique where we can add the no longer referenced objects to a list, which we regularly (and by we I mean the GC) visit and destroy some objects from it. All of these processes require constant updating. There are several advantages to this technique, although it being simple - for one, it's very responsive as it doesn't waste any time in de-allocating space for us, thus making it adequate for systems with limited memory. Also the performance of this doesn't go down as the memory is freed. The problem to all of this is that this algorithm takes up memory spaces for the counts, it is not the most efficient method, that is why it's so simple, and it also can't prevent <b>reference cycles</b>. A <b>reference cycle</b> is just an object that refers to itself <b>directly</b> or <b>indirectly</b>. This means that their reference count is going to be always above zero. Here <b>weak references</b> come in handy since they can break such a chain.
</p>

<p>
(In this whole segment I managed to re-use the word "reference" 20 times&#x2026;geez, talk about DRY)
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0c7f0cb">
<h4 id="org0c7f0cb">Rule of five</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">utility</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">resource</span> 
<span class="linenr"> 3: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 4: </span>  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">foo</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span>  <span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">10: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">()</span> : p<span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #d26937;">{}</span><span style="color: #33859e;">}</span> <span style="color: #33859e;">{</span> <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">default ctor</span>
<span class="linenr">11: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">foo</span>&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> : p<span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #d26937;">{</span>*<span style="color: #888ca6;">(</span>other.p<span style="color: #888ca6;">)</span><span style="color: #d26937;">}</span><span style="color: #33859e;">}</span> <span style="color: #33859e;">{</span> <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">copy ctor</span>
<span class="linenr">12: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">(</span><span style="color: #d26937;">foo</span>&amp;&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> : p<span style="color: #33859e;">{</span>other.p<span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">move ctor</span>
<span class="linenr">13: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">14: </span>      other.p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">15: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #d26937;">foo</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">foo</span>&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">assignment operator</span>
<span class="linenr">18: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">19: </span>      <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #d26937;">(</span>&amp;other != <span style="color: #195466; font-weight: bold;">this</span><span style="color: #d26937;">)</span> <span style="color: #d26937;">{</span>
<span class="linenr">20: </span>        <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">21: </span>        p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">22: </span>        p = <span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #888ca6;">{</span>*<span style="color: #2aa889;">(</span>other.p<span style="color: #2aa889;">)</span><span style="color: #888ca6;">}</span>;
<span class="linenr">23: </span>      <span style="color: #d26937;">}</span>
<span class="linenr">24: </span>      <span style="color: #195466; font-weight: bold;">return</span> *<span style="color: #195466; font-weight: bold;">this</span>;
<span class="linenr">25: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span>    <span style="color: #d26937;">foo</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #d26937;">foo</span>&amp;&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">move assignment operator</span>
<span class="linenr">28: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">29: </span>      <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #d26937;">(</span>&amp;other != <span style="color: #195466; font-weight: bold;">this</span><span style="color: #d26937;">)</span> <span style="color: #d26937;">{</span>
<span class="linenr">30: </span>        <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">31: </span>        p = other.p;
<span class="linenr">32: </span>        other.p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">33: </span>      <span style="color: #d26937;">}</span>
<span class="linenr">34: </span>      <span style="color: #195466; font-weight: bold;">return</span> *<span style="color: #195466; font-weight: bold;">this</span>;
<span class="linenr">35: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">36: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">rest of class . . .</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">cont.</span>
<span class="linenr">1: </span>
<span class="linenr">2: </span>    ~<span style="color: #599cab;">foo</span><span style="color: #99d1ce;">()</span> <span style="color: #245361;">// </span><span style="color: #245361;">destructor</span>
<span class="linenr">3: </span>    <span style="color: #99d1ce;">{</span>
<span class="linenr">4: </span>      <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">5: </span>    <span style="color: #99d1ce;">}</span>
<span class="linenr">6: </span>
<span class="linenr">7: </span>  <span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">8: </span>    <span style="color: #d26937;">resource</span>* <span style="color: #599cab;">p</span>;
<span class="linenr">9: </span><span style="color: #091f2e; background-color: #99d1ce;">}</span>;
</pre>
</div>


<aside class="notes">
<p>
And finally let's talk about the <b>rule of five</b>. These are just a set of rules for building <b>exception safe</b> and <b>resource managing</b> code in C++. The first three rules can be summed up like this. If a class needs to have a user-defined destructor, or copy constructor, or copy assignment operator, then it most probably needs all three. Because we are handling resources in our classes, we will be working with references and pointers, which means that the default implementations of the constructors and destructor will not suffice for us, and we will need to implement them on our own (tutorial 1 covers briefly the topic of writing such custom implementations). The last two rules are also related to this. If we have these custom implementations in our code base, we must also implement a <b><b>move</b></b> constructor and a <b><b>move assignment operator</b></b>. Now we must acknowledge what a <b>move</b> constructor and <b>move assignment operator</b> is. Well basically, they are two new additions we have since <b>C++ 11</b>. They allow us to perform move semantics in C++ in a more efficient way (there are links to references for <b>move</b> s for those who are interested).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org809d5b6">
<h3 id="org809d5b6">Using the STL to our advantage</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">memory</span><span style="color: #99d1ce;">&gt;</span> <span style="color: #245361;">// </span><span style="color: #245361;">holds smart pointers</span>
<span class="linenr">1: </span>
<span class="linenr">2: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">unique_ptr</span><span style="color: #99d1ce;">&lt;</span>Object<span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">obj</span>; <span style="color: #245361;">// </span><span style="color: #245361;">holds a pointer to var obj</span>
<span class="linenr">3: </span>
</pre>
</div>

<aside class="notes">
<p>
In the previous section I mentioned that we can use smart pointers to our advantage to handle heap memory and resources. Before we had to write out own memory management classes that worked likes smart pointers, when C++ 11 first came out, we had <code>auto_ptr</code>, which tried to do that. But it was somewhat impaired to several functionalities like copying and assigning. Since then, <code>auto_ptr</code> is deprecated and we use either <code>unique_ptr</code> or <code>share_ptr</code>. Now I want to get this out of the way, when working with smart pointers, <b>unique</b> is the standard and <b>shared</b> is the exception.
</p>

<p>
So how does a <code>unique_ptr</code> look like? Well, it's basically using any other STL container, where we define what we want inside of it and then we declare our variable.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgd4be2e9">
<h2 id="orgd4be2e9">General good practices</h2>
<div class="outline-text-2" id="text-orgd4be2e9">
</div>
</section>
</section>
<section>
<section id="slide-org37429e7">
<h3 id="org37429e7">Use <code>const</code> whenever possible</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">char</span> <span style="color: #599cab;">greeting</span><span style="color: #99d1ce;">[]</span> = <span style="color: #2aa889;">"Hello"</span>; <span style="color: #245361;">// </span><span style="color: #245361;">basic C string</span>
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #d26937;">char</span> *<span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">no const pointer</span>
<span class="linenr"> 3: </span>                    <span style="color: #245361;">// </span><span style="color: #245361;">no const data</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">char</span> *<span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">no const pointer</span>
<span class="linenr"> 6: </span>                          <span style="color: #245361;">// </span><span style="color: #245361;">const data</span>
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #d26937;">char</span> * <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">const pointer</span>
<span class="linenr"> 9: </span>                           <span style="color: #245361;">// </span><span style="color: #245361;">no const data</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">char</span> * <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">const pointer</span>
<span class="linenr">12: </span>                                 <span style="color: #245361;">// </span><span style="color: #245361;">const data</span>
</pre>
</div>

<aside class="notes">
<p>
We have already talked about the advantages of <b>pass-by-reference-to-const</b> before and we are aware of its benefits. But we can generalize this rule to integrate <code>const</code> in more than just function calls. We know what <code>const</code> does - it tells the compiler that a specific implementation <b>cannot</b> change over the course of the program. Such reinforcement is not only about telling the compiler that, but it also help us make good semantics in our code. Such constraints also help us to minimize bugs, which might accumulate if we are not careful how we are changing the state of our objects. Outside of classes, <code>const</code> can be used to declare global and namespace variables. In classes we can create both static and non-static constant data members. The problem with this keyword is that it has confusing syntax when it comes to pointers. Because we can declare a pointer to be <code>const</code>, the data the pointer it points to be <code>const</code>, or make both the pointer and the contents constant. So when we put <code>const</code> behind the asterisk in a definition, we are telling the compiler that the data contents are constant, but the pointer can change its "pointing". If we put the keyword after the asterisk, the pointer itself will point to only one place and cannot be changed, but the data can be (so we can change the data through another pointer and the constant pointer will still point to the same memory location). Finally we can make them both constants, which just halts a specific part of memory that cannot be changed. <b>Tip:</b> it might be helpful, when reading pointer declarations, to start from right to left, since when you say it out loud it would sound natural.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org907d137">
<h3 id="org907d137">Make full copies of objects</h3>
</section>
</section>
<section>
<section id="slide-org13482b5">
<h3 id="org13482b5">Postpone variable definitions</h3>
</section>
</section>
<section>
<section id="slide-org7d9040e">
<h3 id="org7d9040e">Minimize casting</h3>

</section>
</section>
<section>
<section id="slide-orge057309">
<h2 id="orge057309">Exercises</h2>

</section>
</section>
<section>
<section id="slide-orga50416e">
<h2 id="orga50416e">Resources</h2>
<div class="outline-text-2" id="text-orga50416e">
</div>
</section>
</section>
<section>
<section id="slide-org6bcbafa">
<h3 id="org6bcbafa">Memory Management</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii">RAII</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/raii">RAII 2</a></li>
<li><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Wiki RAII</a></li>
<li><a href="https://stackoverflow.com/questions/147130/why-doesnt-c-have-a-garbage-collector">Why don't we have a GC in C++</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/113177/why-do-languages-such-as-c-and-c-not-have-garbage-collection-while-java-does">Why no GC in C++</a></li>
<li><a href="http://hboehm.info/gc/">Garbage collector for C++</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reference_counting#reference_cycle">Reference counting</a></li>
<li><a href="https://en.wikipedia.org/wiki/Weak_reference">Weak references</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rule_of_three_(C++_programming)">Rule of 3</a></li>
<li><a href="https://cpppatterns.com/patterns/rule-of-five.html">Rule of 5</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/rule_of_three">Rule of 3/5/0</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/dd293665.aspx">Move constructor and assignment operator</a></li>
<li><a href="https://blog.smartbear.com/c-plus-plus/c11-tutorial-introducing-the-move-constructor-and-the-move-assignment-operator/">C++ 11 move</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/move_constructor">Move constructors</a></li>
<li><a href="https://visualstudiomagazine.com/articles/2012/10/19/circular-references.aspx">Circular references</a></li>
<li><a href="https://mortoray.com/2012/01/08/what-is-reference-counting/">What is reference counting</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
