<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Resource Management and Good practices</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Resource Management and Good practices</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-02-13 Tue 19:46</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org2d327ac">How to manage memory</a></li>
<li><a href="#/slide-org410309a">General good practices</a></li>
<li><a href="#/slide-org8da210e">Exercises</a></li>
<li><a href="#/slide-orgbf7a6d8">Resources</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-org2d327ac">
<h2 id="org2d327ac">How to manage memory</h2>
<aside class="notes">
<p>
When we first learn C++ for the first time we have way too many things going on so we are usually told not to worry about memory management (or we are not even aware that such a thing exists in the language). This is normal, since the language itself is hard enough to learn so we push thins topic for another time. But that time usually comes way too late and we don't have the discipline to think in therms of memory management. Luckily for us, we are writing modern C++, which means that there are a lot of tools deisgn to help us out with this task and to make it much more easy, than it was back in '89.
</p>

<p>
In C++ we have several resources we can manage, where we are not only limited to some dynamically allocated object. We care for files, database connections, mutexes, GUIs, sockets, etc. This means that having memory leaks is just one of our problems, but being unable to connect to a databse, or corrupt the contents of a file, because we are not careful enough is a whole other story. Here we will try to look at how we can use the STL to our advantage and manage resources manually.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0e740ca">
<h3 id="org0e740ca">RAII</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">without RAII</span>
<span class="linenr"> 1: </span><span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">handle</span>=createNewResource<span style="color: #99d1ce;">()</span>;
<span class="linenr"> 2: </span>handle-&gt;performInvalidOperation<span style="color: #99d1ce;">()</span>;  <span style="color: #245361;">// </span><span style="color: #245361;">this will throw an excpetion</span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">some code</span>
<span class="linenr"> 4: </span>deleteResource<span style="color: #99d1ce;">(</span>handle<span style="color: #99d1ce;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">resource leek never cleaned!</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #245361;">// </span><span style="color: #245361;">with RAII</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">SomeResource</span> <span style="color: #99d1ce;">{</span>
<span class="linenr"> 8: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 9: </span>   <span style="color: #599cab;">SomeResource</span><span style="color: #33859e;">(</span><span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">rawRes_</span><span style="color: #33859e;">)</span> : rawRes<span style="color: #33859e;">(</span>rawRes_<span style="color: #33859e;">)</span> <span style="color: #33859e;">{}</span>;
<span class="linenr">10: </span>   ~<span style="color: #599cab;">SomeResource</span><span style="color: #33859e;">()</span> <span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">delete</span> rawRes; <span style="color: #33859e;">}</span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">12: </span>   <span style="color: #d26937;">RawResourceHandle</span>* <span style="color: #599cab;">rawRes</span>;
<span class="linenr">13: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">14: </span>
<span class="linenr">15: </span><span style="color: #d26937;">SomeResource</span> <span style="color: #599cab;">handle</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">createNewResource</span><span style="color: #33859e;">()</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">16: </span>handle-&gt;performInvalidOperation<span style="color: #99d1ce;">()</span>;
</pre>
</div>

<aside class="notes">
<p>
In C++ we have this magical idiom called <b><b>RAII</b></b>, or <b>Resource Acquisition Is Initialization</b>. This binds the life cycle of a resource that must be acquired before use, to the lifetime of an object. Again, we are not just talking about pieces of memory, but sockets, database connections, file descriptors, mutexes, things that are considered as a resources, are bounded to an object. Then, functions are able to access that resource (through the object), use it, and when it is no longer needed, the object manages the state of the resource, and closes it appropriately. You might also see this idiom as <b>Scope-Bound Resource Management</b>. The important thing here is that even when we get an exception during some constructor, the already created base objects are also released in reverse order of initialization. We are both managing resource leaks and exception safety!! C++ provides us with some ready-made solutions to this principle. <code>vector</code>, <code>string</code>, and <code>thread</code> manage their resources on their own so we don't have to worry about them, but we also have <code>unique_ptr</code> and <code>shared_ptr</code> where we can manage resources and not worry about their releasing and exceptions.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org8f892a6">
<h3 id="org8f892a6">When to use <code>new</code> and <code>delete</code></h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">int</span> * <span style="color: #599cab;">ipt</span> = <span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">int</span>;
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"ipt = "</span> &lt;&lt; ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 3: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 4: </span>*ipt = <span style="color: #33859e; font-weight: bold;">1000</span>;
<span class="linenr"> 5: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">delete</span> ipt;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"ipt = "</span> &lt;&lt; ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">10: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"*ipt = "</span> &lt;&lt; *ipt &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl
</pre>
</div>

<aside class="notes">
<p>
When do we actually have to use <code>new</code> and <code>delete</code>? It's so tempting to just say <b>never</b> and move on to the rest of the topics, but this is not exactly true. It's <b>almost</b> true. First let's look at what <code>new</code> and <code>delete</code> do. <code>new</code> is the keyword we use in C++ that allocates a piece of memory in the <b>local store</b> and has a pointer to that piece of anonymous data. <code>delete</code> on the other hand does the opposite and removes the contents of a cell of memory. So let's look at an example. Here we just allocate an integer to the free store and then we read the pointer address and the address contents. The question is what would happen after the <code>delete</code> call? Would we have to same contents or would we get the same number again? The answer is - we would get <b><b>undefined</b></b> behavior. After you call delete, you can still use the pointer for other things, but never ever try to see what it points to, since we will go down the valley of <b>undefined</b> behavior.
</p>

<p>
So using <code>new</code> and <code>delete</code> can lead to peril if we are not careful, so what are our other options?
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org2e00b9c">
<h3 id="org2e00b9c">A pass by over garbage collection</h3>
<ul>
<li class="fragment roll-in">Weak references</li>
<li class="fragment roll-in">Reference counting</li>
<li class="fragment roll-in">Rule of five</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgdeafe91">
<h4 id="orgdeafe91">Weak references</h4>
<aside class="notes">
<p>
Let's just go over some interesting and important notes about garbage collection and memory management before we continue with the main topics. Why doesn't C++ have a garbage collector like <code>Java</code> or <code>C#</code> or some other languages? Well it's not impossible and there are some implementations of a C++ garbage collector, but it's not something that is used widely in the C++ sphere. There are a lot of reasons why this is so, time constraints, agreements between the C++ implementation group, implementation problems in general, etc. The thing with garbage collection is that it's a pretty heavy process and it isn't as simple as pushing everything into smart pointers and calling it a day. C++ is above all efficient, it gives us a lot of room to make whatever we like. The garbage collection we have is the explicit one we can achieve through smart pointers, but there isn't a thing like the <code>Java</code> or <code>C#</code> collector (an implicit GC) (As a side note, I have included a link to a <b>C++ GC</b> if you still want to try it out). So the question here is - how do smart pointers work in C++. Everybody is talking about them, they do have great functionalities, but how are they actually helpful?
</p>

<p>
In order to understand these concept we need to cover several topics. Let's start with <b>weak references</b>. In general, abstracting ourselves from C++, a <b>weak reference</b> is a pointer that does not protect the content that pointer points to from a garbage collector. If we have a chain of references to an object and even if one of those references are weak, the whole chain is considered to be weak and can be collected at any moment. Now there are several layers of weak references and we can find them in implementations in <code>Java</code>, <code>C#</code>, <code>python</code>, etc. In general, there are two types of GC - <b>tracing</b> and <b>reference counting</b>. We are going to look only <b>reference counting</b> since it's relevant to us.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgad2927c">
<h4 id="orgad2927c">Reference counting</h4>
<aside class="notes">
<p>
Now <b><b>reference counting</b></b> is a technique where we count the number of references, handlers, and pointers to a certain object, memory block, file, and in general - any resource. Once the number of references reaches <b>0</b>, that resource is collected and destroyed. An interesting aspect of this is that when we destroy an object that is no longer referenced by anything, if that object holds a references to another object, after the destruction of the de-referenced object, the other referenced object have their reference count decremented. So there is also a technique where we can add the no longer referenced objects to a list, which we regularly (and by we I mean the GC) visit and destroy some objects from it. All of these processes require constant updating. There are several advantages to this technique, although it being simple - for one, it's very responsive as it doesn't waste any time in de-allocating space for us, thus making it adequate for systems with limited memory. Also the performance of this doesn't go down as the memory is freed. The problem to all of this is that this algorithm takes up memory spaces for the counts, it is not the most efficient method, that is why it's so simple, and it also can't prevent <b>reference cycles</b>. A <b>reference cycle</b> is just an object that refers to itself <b>directly</b> or <b>indirectly</b>. This means that their reference count is going to be always above zero. Here <b>weak references</b> come in handy since they can break such a chain.
</p>

<p>
(In this whole segment I managed to re-use the word "reference" 20 times&#x2026;geez, talk about DRY)
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org88ad850">
<h4 id="org88ad850">Rule of five</h4>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">utility</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">resource</span> 
<span class="linenr"> 3: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 4: </span>  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">foo</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span>  <span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">10: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">()</span> : p<span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #d26937;">{}</span><span style="color: #33859e;">}</span> <span style="color: #33859e;">{</span> <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">default ctor</span>
<span class="linenr">11: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">foo</span>&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> : p<span style="color: #33859e;">{</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #d26937;">{</span>*<span style="color: #888ca6;">(</span>other.p<span style="color: #888ca6;">)</span><span style="color: #d26937;">}</span><span style="color: #33859e;">}</span> <span style="color: #33859e;">{</span> <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">copy ctor</span>
<span class="linenr">12: </span>    <span style="color: #599cab;">foo</span><span style="color: #33859e;">(</span><span style="color: #d26937;">foo</span>&amp;&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> : p<span style="color: #33859e;">{</span>other.p<span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">move ctor</span>
<span class="linenr">13: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">14: </span>      other.p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">15: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #d26937;">foo</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">foo</span>&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">assignment operator</span>
<span class="linenr">18: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">19: </span>      <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #d26937;">(</span>&amp;other != <span style="color: #195466; font-weight: bold;">this</span><span style="color: #d26937;">)</span> <span style="color: #d26937;">{</span>
<span class="linenr">20: </span>        <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">21: </span>        p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">22: </span>        p = <span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">resource</span><span style="color: #888ca6;">{</span>*<span style="color: #2aa889;">(</span>other.p<span style="color: #2aa889;">)</span><span style="color: #888ca6;">}</span>;
<span class="linenr">23: </span>      <span style="color: #d26937;">}</span>
<span class="linenr">24: </span>      <span style="color: #195466; font-weight: bold;">return</span> *<span style="color: #195466; font-weight: bold;">this</span>;
<span class="linenr">25: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span>    <span style="color: #d26937;">foo</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #599cab;">=</span><span style="color: #33859e;">(</span><span style="color: #d26937;">foo</span>&amp;&amp; <span style="color: #599cab;">other</span><span style="color: #33859e;">)</span> <span style="color: #245361;">// </span><span style="color: #245361;">move assignment operator</span>
<span class="linenr">28: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">29: </span>      <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #d26937;">(</span>&amp;other != <span style="color: #195466; font-weight: bold;">this</span><span style="color: #d26937;">)</span> <span style="color: #d26937;">{</span>
<span class="linenr">30: </span>        <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">31: </span>        p = other.p;
<span class="linenr">32: </span>        other.p = <span style="color: #33859e; font-weight: bold;">nullptr</span>;
<span class="linenr">33: </span>      <span style="color: #d26937;">}</span>
<span class="linenr">34: </span>      <span style="color: #195466; font-weight: bold;">return</span> *<span style="color: #195466; font-weight: bold;">this</span>;
<span class="linenr">35: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">36: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">rest of class . . .</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">cont.</span>
<span class="linenr">1: </span>
<span class="linenr">2: </span>    ~<span style="color: #599cab;">foo</span><span style="color: #99d1ce;">()</span> <span style="color: #245361;">// </span><span style="color: #245361;">destructor</span>
<span class="linenr">3: </span>    <span style="color: #99d1ce;">{</span>
<span class="linenr">4: </span>      <span style="color: #195466; font-weight: bold;">delete</span> p;
<span class="linenr">5: </span>    <span style="color: #99d1ce;">}</span>
<span class="linenr">6: </span>
<span class="linenr">7: </span>  <span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">8: </span>    <span style="color: #d26937;">resource</span>* <span style="color: #599cab;">p</span>;
<span class="linenr">9: </span><span style="color: #091f2e; background-color: #99d1ce;">}</span>;
</pre>
</div>


<aside class="notes">
<p>
And finally let's talk about the <b>rule of five</b>. These are just a set of rules for building <b>exception safe</b> and <b>resource managing</b> code in C++. The first three rules can be summed up like this. If a class needs to have a user-defined destructor, or copy constructor, or copy assignment operator, then it most probably needs all three. Because we are handling resources in our classes, we will be working with references and pointers, which means that the default implementations of the constructors and destructor will not suffice for us, and we will need to implement them on our own (tutorial 1 covers briefly the topic of writing such custom implementations). The last two rules are also related to this. If we have these custom implementations in our code base, we must also implement a <b><b>move</b></b> constructor and a <b><b>move assignment operator</b></b>. Now we must acknowledge what a <b>move</b> constructor and <b>move assignment operator</b> is. Well basically, they are two new additions we have since <b>C++ 11</b>. They allow us to perform move semantics in C++ in a more efficient way (there are links to references for <b>move</b> s for those who are interested).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org53008df">
<h3 id="org53008df">Using the STL to our advantage</h3>
<ul>
<li class="fragment roll-in"><code>unique_ptr</code></li>
<li class="fragment roll-in"><code>shared_ptr</code></li>
<li class="fragment roll-in"><code>weak_ptr</code></li>

</ul>

</section>
<section >

<p>
<code>unique_ptr</code>
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">foo</span> <span style="color: #99d1ce;">()</span>
<span class="linenr">1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">2: </span>    <span style="color: #d26937;">unique_ptr</span><span style="color: #33859e;">&lt;</span>Thing<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">p</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">Thing</span><span style="color: #d26937;">()</span><span style="color: #33859e;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">p owns the Thing</span>
<span class="linenr">3: </span>    p-&gt;do_something<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">tell the thing to do something</span>
<span class="linenr">4: </span>    defrangulate<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">might throw an exception</span>
<span class="linenr">5: </span><span style="color: #99d1ce;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">p gets destroyed; destructor deletes the Thing</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #d26937;">unique_ptr</span><span style="color: #99d1ce;">&lt;</span>Thing<span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">p1</span> <span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">Thing</span><span style="color: #99d1ce;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">p1 owns the Thing</span>
<span class="linenr">1: </span><span style="color: #d26937;">unique_ptr</span><span style="color: #99d1ce;">&lt;</span>Thing<span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">p2</span><span style="color: #99d1ce;">(</span>p1<span style="color: #99d1ce;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">error - copy construction is not allowed.</span>
<span class="linenr">2: </span><span style="color: #d26937;">unique_ptr</span><span style="color: #99d1ce;">&lt;</span>Thing<span style="color: #99d1ce;">&gt;</span> <span style="color: #599cab;">p3</span>; <span style="color: #245361;">// </span><span style="color: #245361;">an empty unique_ptr;</span>
<span class="linenr">3: </span>p3 = p1; <span style="color: #245361;">// </span><span style="color: #245361;">error, copy assignment is not allowed</span>
</pre>
</div>

<aside class="notes">
<p>
In the previous section I mentioned that we can use smart pointers to our advantage to handle heap memory and resources. Before we had to write out own memory management classes that worked likes smart pointers, when C++ 11 first came out, we had <code>auto_ptr</code>, which tried to do that. But it was somewhat impaired to several functionalities like copying and assigning. Since then, <code>auto_ptr</code> is deprecated and instead we have 3 other types of smart pointers - <code>unique_ptr</code>, <code>weak_ptr</code>, or <code>share_ptr</code>. Now I want to get this out of the way, when working with smart pointers, <b>unique</b> is the standard and <b>shared</b> is the exception. Because these two smart pointers are the most common ones, we can take a look at how they work.
</p>

<p>
So how does a <code>unique_ptr</code> look like? Well, it's basically using any other STL container, where we define what we want inside of it and then we declare our variable. There are several big advantages to using this pointer. First, it has <b>zero</b> overhead. Because it has the <code>T*</code> implementation, taking in anything, which means that it points to anything and the moment that pointer goes out of scope, the pointer and the pointed data gets destroyed. <code>unique_ptr</code> allows us to manage resources without worrying about how they get released and how they get deleted when the time comes. The syntax is the same as using a normal pointer, so we don't have to worry about that. Also, the word <b>"unique"</b> is arbitrary. This pointer can <b>"own"</b> only one object, which means that we can avoid collisions, where multiple pointers can access one piece of data and leave it dangling. This means that we cannot copy nor assign one unique pointer to another (this like copy constructors and assignment operators are disallowed for this type).
</p>

</aside>

</section>
<section >

<p>
<code>shared_ptr</code>
</p>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">foo</span><span style="color: #99d1ce;">()</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">the new is in the shared_ptr constructor expression:</span>
<span class="linenr"> 3: </span>    <span style="color: #d26937;">shared_ptr</span><span style="color: #33859e;">&lt;</span>Thing<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">p1</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">Thing</span><span style="color: #33859e;">)</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #d26937;">shared_ptr</span><span style="color: #33859e;">&lt;</span>Thing<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">p2</span> = p1; <span style="color: #245361;">// </span><span style="color: #245361;">p1 and p2 now share ownership of the Thing</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #d26937;">shared_ptr</span><span style="color: #33859e;">&lt;</span>Thing<span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">p3</span><span style="color: #33859e;">(</span><span style="color: #195466; font-weight: bold;">new</span> <span style="color: #d26937;">Thing</span><span style="color: #33859e;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">another Thing</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    p1 = find_some_thing<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">p1 may no longer point to first Thing</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>    do_something_with<span style="color: #33859e;">(</span>p2<span style="color: #33859e;">)</span>;
<span class="linenr">12: </span>
<span class="linenr">13: </span>    p3-&gt;defrangulate<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">call a member function like built-in pointer</span>
<span class="linenr">14: </span>
<span class="linenr">15: </span>    cout &lt;&lt; *p2 &lt;&lt; endl; <span style="color: #245361;">// </span><span style="color: #245361;">dereference like built-in pointer</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">reset with a member function or assignment to nullptr:</span>
<span class="linenr">18: </span>    p1.reset<span style="color: #33859e;">()</span>; <span style="color: #245361;">// </span><span style="color: #245361;">decrement count, delete if last</span>
<span class="linenr">19: </span>    p2 = <span style="color: #33859e; font-weight: bold;">nullptr</span>; <span style="color: #245361;">// </span><span style="color: #245361;">convert nullptr to an empty shared_ptr, and decrement count;</span>
<span class="linenr">20: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Now that we know what so unique about <code>unique_ptr</code>, we can talk about shared pointers. The syntax and basic functionality of a <code>shared_ptr</code> are the same as any other smart pointer, but there are some implementations differences. For one, we can have multiple pointers that share the same object on the free store (hence the name <b>shared</b>). Using the powers of reference counting, depending on how many references there are to the specific object, C++ can determine when to delete that memory space. This is how it works - once a pointer get out of scope or gets assigned to a <code>nullptr</code>, the total reference count gets decremented. If the number reaches <b>zero</b>, the object gets deleted. If we are to get into the situation of a <b>reference cycle</b>, the smart <code>shared_ptr</code> got us covered by using the so called <code>weak_ptr</code>. These weak pointers are used only as observers to the actual object and <b>do not</b> affect its lifetime. Because of this, the shared state between the objects is known to C++, the reference counts don't get confused and we get proper object deletion when the count is at 0.
</p>

<p>
From the above code we can trace how the shared pointer managed and shares the resource it points to. We can decrement the counter manually or through <code>nullptr</code> assignment.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org410309a">
<h2 id="org410309a">General good practices</h2>
<div class="outline-text-2" id="text-org410309a">
</div>
</section>
</section>
<section>
<section id="slide-org9eba90f">
<h3 id="org9eba90f">Use <code>const</code> whenever possible</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #d26937;">char</span> <span style="color: #599cab;">greeting</span><span style="color: #99d1ce;">[]</span> = <span style="color: #2aa889;">"Hello"</span>; <span style="color: #245361;">// </span><span style="color: #245361;">basic C string</span>
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #d26937;">char</span> *<span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">no const pointer</span>
<span class="linenr"> 3: </span>                    <span style="color: #245361;">// </span><span style="color: #245361;">no const data</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">char</span> *<span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">no const pointer</span>
<span class="linenr"> 6: </span>                          <span style="color: #245361;">// </span><span style="color: #245361;">const data</span>
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span style="color: #d26937;">char</span> * <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">const pointer</span>
<span class="linenr"> 9: </span>                           <span style="color: #245361;">// </span><span style="color: #245361;">no const data</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">char</span> * <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #599cab;">p</span> = greeting; <span style="color: #245361;">// </span><span style="color: #245361;">const pointer</span>
<span class="linenr">12: </span>                                 <span style="color: #245361;">// </span><span style="color: #245361;">const data</span>
</pre>
</div>

<aside class="notes">
<p>
We have already talked about the advantages of <b>pass-by-reference-to-const</b> before and we are aware of its benefits. But we can generalize this rule to integrate <code>const</code> in more than just function calls. We know what <code>const</code> does - it tells the compiler that a specific implementation <b>cannot</b> change over the course of the program. Such reinforcement is not only about telling the compiler that, but it also help us make good semantics in our code. Such constraints also help us to minimize bugs, which might accumulate if we are not careful how we are changing the state of our objects. Outside of classes, <code>const</code> can be used to declare global and namespace variables. In classes we can create both static and non-static constant data members. The problem with this keyword is that it has confusing syntax when it comes to pointers. Because we can declare a pointer to be <code>const</code>, the data the pointer it points to be <code>const</code>, or make both the pointer and the contents constant. So when we put <code>const</code> behind the asterisk in a definition, we are telling the compiler that the data contents are constant, but the pointer can change its "pointing". If we put the keyword after the asterisk, the pointer itself will point to only one place and cannot be changed, but the data can be (so we can change the data through another pointer and the constant pointer will still point to the same memory location). Finally we can make them both constants, which just halts a specific part of memory that cannot be changed. <b>Tip:</b> it might be helpful, when reading pointer declarations, to start from right to left, since when you say it out loud it would sound natural.
</p>

</aside>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">TextBlock</span> 
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">char</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #33859e;">[]</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">position</span><span style="color: #33859e;">)</span> <span style="color: #195466; font-weight: bold;">const</span>
<span class="linenr"> 4: </span>    <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> text<span style="color: #d26937;">[</span>position<span style="color: #d26937;">]</span>; <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">operator[] for const objects</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #d26937;">char</span>&amp; <span style="color: #195466; font-weight: bold;">operator</span><span style="color: #33859e;">[]</span><span style="color: #33859e;">(</span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">position</span><span style="color: #33859e;">)</span>
<span class="linenr"> 7: </span>    <span style="color: #33859e;">{</span> <span style="color: #195466; font-weight: bold;">return</span> text<span style="color: #d26937;">[</span>position<span style="color: #d26937;">]</span>; <span style="color: #33859e;">}</span> <span style="color: #245361;">// </span><span style="color: #245361;">operator[] for non-const objects</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr">10: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">text</span>;
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #d26937;">TextBlock</span> <span style="color: #599cab;">tb</span><span style="color: #99d1ce;">(</span><span style="color: #2aa889;">"Hello"</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">14: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; tb<span style="color: #99d1ce;">[</span><span style="color: #33859e; font-weight: bold;">0</span><span style="color: #99d1ce;">]</span>; <span style="color: #245361;">// </span><span style="color: #245361;">calls non-const TextBlock::operator[]</span>
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">TextBlock</span> <span style="color: #599cab;">ctb</span><span style="color: #99d1ce;">(</span><span style="color: #2aa889;">"World"</span><span style="color: #99d1ce;">)</span>;
<span class="linenr">17: </span><span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; ctb<span style="color: #99d1ce;">[</span><span style="color: #33859e; font-weight: bold;">0</span><span style="color: #99d1ce;">]</span>; <span style="color: #245361;">// </span><span style="color: #245361;">calls const TextBlock::operator[]</span>
</pre>
</div>

<aside class="notes">
<p>
Apart from making data members constant, we can also look at constant member functions. The two benefits we get is that we are creating an interface that is telling us what should be what, thus making it easier to understand. The second part is that they will allows us to work with constant object, thus making out work by passing by objects by ref to const much easier. There is another thing about constant member functions, and that is that they can differ only on their constness, allowing us overload them based only on that.
</p>

<p>
Now we should take some time to talk about the two different types of constness we can have in C++. There is <b>bitwise (logical) constness</b> and <b>logical constness</b>. To be bitwise const means that, inside a constant member function, we are not allowed to change <b><b>any</b></b> of the class data members. Basically this corresponds to the C++ understanding what <code>const</code> is. The compiler just searches in the function body for any assignment operators that might change some non-static state in the object. But bitwise constness doesnt' always do what it might seem to do. If we have a pointer that points to something and the function is const, the data that the pointer points to can still be changed. This means that we can write our functions const all we want, but that doesn't guarantee that <b><b>all</b></b> of the data will remain unchanged. This leads us to the notion of <b>logical constness</b>. This means that const member functions can change the values of data members as long as the change is unseen from the user perspective. In general it's a good idea to prefer logical over bitwise constness.
</p>

</aside>

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">CTextBlock</span> 
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">length</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr"> 6: </span>    <span style="color: #d26937;">char</span> *<span style="color: #599cab;">pText</span>;
<span class="linenr"> 7: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">textLength</span>;
<span class="linenr"> 8: </span>    <span style="color: #d26937;">bool</span> <span style="color: #599cab;">lengthIsValid</span>;
<span class="linenr"> 9: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #33859e; font-weight: bold;">CTextBlock</span>::<span style="color: #599cab;">length</span><span style="color: #99d1ce;">()</span> <span style="color: #195466; font-weight: bold;">const</span>
<span class="linenr">12: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">13: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span><span style="color: #c23127;">!</span>lengthIsValid<span style="color: #33859e;">)</span> 
<span class="linenr">14: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">15: </span>        <span style="color: #245361;">// </span><span style="color: #245361;">error!</span>
<span class="linenr">16: </span>        textLength = <span style="color: #33859e; font-weight: bold;">std</span>::strlen<span style="color: #d26937;">(</span>pText<span style="color: #d26937;">)</span>;
<span class="linenr">17: </span>        lengthIsValid = <span style="color: #33859e; font-weight: bold;">true</span>;
<span class="linenr">18: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">19: </span>    <span style="color: #195466; font-weight: bold;">return</span> lengthIsValid;
<span class="linenr">20: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">CTextBlock</span> 
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr"> 3: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">length</span><span style="color: #33859e;">()</span> <span style="color: #195466; font-weight: bold;">const</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #195466; font-weight: bold;">private</span>:
<span class="linenr"> 6: </span>    <span style="color: #d26937;">char</span> *<span style="color: #599cab;">pText</span>;
<span class="linenr"> 7: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">mutable allows us to change the values</span>
<span class="linenr"> 8: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">even in const functions</span>
<span class="linenr"> 9: </span>    <span style="color: #195466; font-weight: bold;">mutable</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #599cab;">textLength</span>;
<span class="linenr">10: </span>    <span style="color: #195466; font-weight: bold;">mutable</span> <span style="color: #d26937;">bool</span> <span style="color: #599cab;">lengthIsValid</span>;
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>;
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">size_t</span> <span style="color: #33859e; font-weight: bold;">CTextBlock</span>::<span style="color: #599cab;">length</span><span style="color: #99d1ce;">()</span> <span style="color: #195466; font-weight: bold;">const</span>
<span class="linenr">14: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">15: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span><span style="color: #c23127;">!</span>lengthIsValid<span style="color: #33859e;">)</span> 
<span class="linenr">16: </span>    <span style="color: #33859e;">{</span>
<span class="linenr">17: </span>        <span style="color: #245361;">// </span><span style="color: #245361;">valid calls</span>
<span class="linenr">18: </span>        textLength = <span style="color: #33859e; font-weight: bold;">std</span>::strlen<span style="color: #d26937;">(</span>pText<span style="color: #d26937;">)</span>;
<span class="linenr">19: </span>        lengthIsValid = <span style="color: #33859e; font-weight: bold;">true</span>;
<span class="linenr">20: </span>    <span style="color: #33859e;">}</span>
<span class="linenr">21: </span>    <span style="color: #195466; font-weight: bold;">return</span> lengthIsValid;
<span class="linenr">22: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Let's take this example - we want to cache the length of the string we have, which means that inside of the <code>length()</code> function we need to make an assignment, but at the same time the function should be constant (as per good conventions). In this situation, we can see that if we want to save some internal state of the object, we must violate the bitwsie constness of the function, that's why we can overcome this by applying the logical constess, and use the <code>mutable</code> keyword. It allows us to change the state of a data member even in situations where we have a <code>const</code> function. This is what logical constness looks like, because the user has on idea we are changing the internal state of the object, but at the same time, we are following the logic of what we want to do, that is save some cached state.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc90570c">
<h3 id="orgc90570c">Postpone variable definitions</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">encryptPassword</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">password</span><span style="color: #99d1ce;">)</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #d26937;">string</span> <span style="color: #599cab;">encrypted</span>;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>password.length<span style="color: #d26937;">()</span> &lt; MinimumPasswordLength<span style="color: #33859e;">)</span> 
<span class="linenr"> 5: </span>    <span style="color: #33859e;">{</span>
<span class="linenr"> 6: </span>        <span style="color: #195466; font-weight: bold;">throw</span> logic_error<span style="color: #d26937;">(</span><span style="color: #2aa889;">"Password is too short"</span><span style="color: #d26937;">)</span>;
<span class="linenr"> 7: </span>    <span style="color: #33859e;">}</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">work</span>
<span class="linenr">10: </span>    <span style="color: #195466; font-weight: bold;">return</span> encrypted;
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">encryptPassword</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">password</span><span style="color: #99d1ce;">)</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #195466; font-weight: bold;">if</span> <span style="color: #33859e;">(</span>password.length<span style="color: #d26937;">()</span> &lt; MinimumPasswordLength<span style="color: #33859e;">)</span> 
<span class="linenr"> 3: </span>    <span style="color: #33859e;">{</span>
<span class="linenr"> 4: </span>        <span style="color: #195466; font-weight: bold;">throw</span> <span style="color: #d26937;">logic_error</span><span style="color: #d26937;">(</span><span style="color: #2aa889;">"Password is too short"</span><span style="color: #d26937;">)</span>;
<span class="linenr"> 5: </span>    <span style="color: #33859e;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #d26937;">string</span> <span style="color: #599cab;">encrypted</span>;
<span class="linenr"> 8: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">work</span>
<span class="linenr"> 9: </span>    <span style="color: #195466; font-weight: bold;">return</span> encrypted;
<span class="linenr">10: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">encryptPassword</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">password</span><span style="color: #99d1ce;">)</span>
<span class="linenr"> 1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">import std and check length as above</span>
<span class="linenr"> 3: </span>    <span style="color: #d26937;">string</span> <span style="color: #599cab;">encrypted</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">default-construct encrypted</span>
<span class="linenr"> 6: </span>    encrypted = password;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">assign to encrypted</span>
<span class="linenr"> 9: </span>    encrypt<span style="color: #33859e;">(</span>encrypted<span style="color: #33859e;">)</span>;
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #195466; font-weight: bold;">return</span> encrypted;
<span class="linenr">12: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span> <span style="color: #599cab;">encryptPassword</span><span style="color: #99d1ce;">(</span><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">string</span>&amp; <span style="color: #599cab;">password</span><span style="color: #99d1ce;">)</span>
<span class="linenr">1: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">2: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">define and initialize via copy</span>
<span class="linenr">3: </span>    <span style="color: #245361;">// </span><span style="color: #245361;">constructor</span>
<span class="linenr">4: </span>    <span style="color: #d26937;">string</span> <span style="color: #599cab;">encrypted</span><span style="color: #33859e;">(</span>password<span style="color: #33859e;">)</span>;
<span class="linenr">5: </span>
<span class="linenr">6: </span>    encrypt<span style="color: #33859e;">(</span>encrypted<span style="color: #33859e;">)</span>;
<span class="linenr">7: </span>    <span style="color: #195466; font-weight: bold;">return</span> encrypted;
<span class="linenr">8: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This might seem intuitive at first, but there are real benefits to postponing your declarations and initialization as much as possible. Because we are dealing with the overhead of constructing and destructing every object in our scope, being able to "tighten-up" our program can lead to better optimizations. We can fall in the cases where we might think we are using s certain variable, because our compiler is not compiling about it, but take for instance the example. We can see that the construction of the string object happens before the test case. If the <code>try-catch</code> block throws, the string was created for no apparent reason. If we refactor the code, it will create the string only when it is really needed, instead of preemptively. We can even further make this code better by assigning it a value as we are defining it. If we first define it and then assign a value, we are calling the default constructor first and then we are calling the assignment operator to give the string a value. But if we just make this into one whole statement it will make only one operation. We know that copy constructors are sometimes even more efficient than the default ones, so we can utilize this to our advantage. So we can not only postpone definitions of a variable, but we can also postpone initializations too, where we can optimize how a variable is created. This way we are avoiding the calling the constructor and destructor and sparing unneeded objects.
</p>

</aside>

</section>
<section >

<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">Approach A: define outside loop</span>
<span class="linenr"> 1: </span><span style="color: #d26937;">Widget</span> <span style="color: #599cab;">w</span>;
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">for</span> <span style="color: #99d1ce;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = <span style="color: #33859e; font-weight: bold;">0</span>; i &lt; n; ++i<span style="color: #99d1ce;">)</span> 
<span class="linenr"> 3: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 4: </span>    w = some value dependent on i;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #245361;">// </span><span style="color: #245361;">Approach B: define inside loop</span>
<span class="linenr"> 8: </span><span style="color: #195466; font-weight: bold;">for</span> <span style="color: #99d1ce;">(</span><span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = <span style="color: #33859e; font-weight: bold;">0</span>; i &lt; n; ++i<span style="color: #99d1ce;">)</span> 
<span class="linenr"> 9: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">10: </span>    <span style="color: #d26937;">Widget</span> <span style="color: #599cab;">w</span><span style="color: #33859e;">(</span> some value dependent <span style="color: #d26937;">on</span> <span style="color: #599cab;">i</span><span style="color: #33859e;">)</span>;
<span class="linenr">11: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
But what about this case, where we have loops. Should we define the variable outside of the scope of the loop or initialize it every time we go over the iterations. We have two situations. In case <b>A</b> : we have 1 constructor + 1 destructor + n assignments. In case <b>B</b> : we have n constructors + n destructors. Case <b>A</b> is valid when the assignment operator is more efficient than the constructor, which can be seen in situations where n is very large. Otherwise approach <b>B</b> is better. Also keep in mind that case <b>A</b> reveals the variable object into larger scope than we need it to be. So in general, we should rely on the second case, where the object is assigned inside of the loop body.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org8da210e">
<h2 id="org8da210e">Exercises</h2>

</section>
</section>
<section>
<section id="slide-orgbf7a6d8">
<h2 id="orgbf7a6d8">Resources</h2>
<div class="outline-text-2" id="text-orgbf7a6d8">
</div>
</section>
</section>
<section>
<section id="slide-org6c4b100">
<h3 id="org6c4b100">Memory Management</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/26423270/why-use-new-and-delete-at-all">Why use new and delete</a></li>
<li><a href="https://stackoverflow.com/questions/11603005/what-does-delete-command-really-do-for-memory-for-pointers-in-c">What does delete do</a></li>
<li><a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii">RAII</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/raii">RAII 2</a></li>
<li><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Wiki RAII</a></li>
<li><a href="https://stackoverflow.com/questions/147130/why-doesnt-c-have-a-garbage-collector">Why don't we have a GC in C++</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/113177/why-do-languages-such-as-c-and-c-not-have-garbage-collection-while-java-does">Why no GC in C++</a></li>
<li><a href="http://hboehm.info/gc/">Garbage collector for C++</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reference_counting#reference_cycle">Reference counting</a></li>
<li><a href="https://en.wikipedia.org/wiki/Weak_reference">Weak references</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rule_of_three_(C++_programming)">Rule of 3</a></li>
<li><a href="https://cpppatterns.com/patterns/rule-of-five.html">Rule of 5</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/rule_of_three">Rule of 3/5/0</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/dd293665.aspx">Move constructor and assignment operator</a></li>
<li><a href="https://blog.smartbear.com/c-plus-plus/c11-tutorial-introducing-the-move-constructor-and-the-move-assignment-operator/">C++ 11 move</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/move_constructor">Move constructors</a></li>
<li><a href="https://visualstudiomagazine.com/articles/2012/10/19/circular-references.aspx">Circular references</a></li>
<li><a href="https://mortoray.com/2012/01/08/what-is-reference-counting/">What is reference counting</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.00,
maxScale: 2.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
