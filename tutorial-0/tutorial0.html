<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>C++ a more in depth look into the language</title>
<meta name="author" content="(Martin Nestorov)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/reveal.css"/>

<link rel="stylesheet" href="file:///home/mdn/reveal.js-3.6.0/css/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'file:///home/mdn/reveal.js-3.6.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">C++ a more in depth look into the language</h1><h2 class="author">Martin Nestorov</h2><p class="date">Created: 2018-01-03 ср 15:06</p>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-orgf13f3ec">Who am I?</a></li>
<li><a href="#/slide-org870e76b">What we are going to cover</a></li>
<li><a href="#/slide-orgf4c150b">File structure</a></li>
<li><a href="#/slide-org9f2d0d4">How does compilation work?</a></li>
<li><a href="#/slide-org9f1f8d6">Memory management</a></li>
<li><a href="#/slide-orgb6618f7">References</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-orgf13f3ec">
<h2 id="orgf13f3ec">Who am I?</h2>
<ul>
<li>Martin Nestorov</li>
<li>Junior 2nd sem.</li>
<li>I like to type . . . a lot</li>
<li>email: mdn150@aubg.edu</li>
<li>Twitter: @mnestorov</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgb2c3371">
<h3 id="orgb2c3371">Why I chose to make these small tutorials</h3>
<ul>
<li>People seem to have some problems with the transition from C++ to FDS.</li>
<li>I want to help!</li>
<li>I want to also learn!</li>

</ul>

<aside class="notes">
<p>
Over the course of the past several years I found a certain love for C++, but instead of just reading about the language and doing some small experiments with it, I wanted to share my knowledge and to get better at it. Seeing how some students struggle with C++ in the beginning courses, I decided that I can help out. That way not only am I learning more in-depth concepts, but also I am making the lives of students easier (hopefully).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org53a86ce">
<h3 id="org53a86ce">How to look at C++</h3>
<p>
C++ as <b>four</b> sub-languages
</p>
<ul>
<li>C</li>
<li>OOP</li>
<li>STL</li>
<li>Templates</li>

</ul>

<aside class="notes">
<p>
There is an old joke about C++ - "How do you shoot yourself in the foot? In C you just shoot yourself in the foot. In C++ you accidentally create a dozen instances of yourself and shoot them all in the foot. Providing emergency medical assistance is impossible since you can't tell which are bitwise copies and which are just pointing at others and saying, "That's me, over there."
</p>

<p>
C++ can sometimes be vary annoying, because we have absolutely no idea how it works and what it does. The fact that having very similar syntax for wildly different things doesn't help either. So instead of just banging our heads until bleeding sets in, we can try to understand a little bit better what is happening with this language and (hopefully) try to minimize <b><b>undefined</b></b> behavior. In fact C++ is that special language where if you don't know that you are doing, the language re-enforces that by acting in a way where it doesn't know what it might do. That's pretty scary. That's why I will try to minimize this effect with these tutorials and help you out to make better C++ programs and to introduce effective methods or writing C++ code.
</p>

<p>
C++ can be generally divided into four sub-categories or sub-languages. It's a daunting task to go over all of these aspects and trying to teach everything, mainly because I can't! But instead I will try to cover some topics that haven't been covered in depth in the C++ lectures and are somewhat elude to the students. Now our list seems like this
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org870e76b">
<h2 id="org870e76b">What we are going to cover</h2>
<ul>
<li>File structure</li>
<li>Memory management</li>
<li>Templates</li>
<li>Inheritance</li>
<li>OOP</li>
<li>STL</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf4c150b">
<h2 id="orgf4c150b">File structure</h2>
<ul>
<li>Advantages:
<ul>
<li>Better code organization</li>
<li>Faster compiling</li>
<li>Separation of <b>implementation</b> from <b>interface</b></li>

</ul></li>

<li>Disadvantages:
<ul>
<li>More complicated structure</li>

</ul></li>

</ul>

<aside class="notes">
<p>
It has come to my attention that many people, while writing their homeworks, neglect the advantages of structuring their <b><b>source</b></b> files. This is most noticeable when they are writing the first 3 FDS homeworks or their FDS project. Being able to properly manage your project into several files and to navigate between them in an optimal and cohesive way will minimize your C++ suffering (and coding experience in general).
</p>

<p>
Now most of you already know this, but there are several great advantages to separating your <b>implementation</b> (cpp) files from your <b>interface</b> (h) files. One advantage is that this will bring code clarity to your program. Instead of navigating through one big <b>400</b> line <code>Source.cpp</code> file, and wondering where that one definition of that object is and then going back to the <code>main()</code> method to fix one line, you will have a nicely structured system. Every class will have it's own implementation and interface file, thus minimizing code searching and optimizing code writing! But that's not all. This separation will allow you to compile your programs even faster. That is, every <b>source</b> file is compiled on its own. When you make a small change in your original 400 line monstrosity, you have to wait for all of that code to <b><b>re-compile</b></b>, but if you have the files separated, you just have to re-compile only the changes files, making waiting time much smaller (naturally this effect can be seen when compiling large programs, while small ones won't have such noticeable impact on time). And lastly, we also gain the benefit of implementation from interface separation.
</p>

<p>
But what we are sacrificing for these benefits is that we are increasing our project complexity. This shouldn't scare us that much, but we do have to keep this in mind - <b><b>We have to limit ourselves not to over layer our program</b></b>.
</p>

<p>
Since most of you are working with Visual Studio, here is how your structure looks like now: Picture 1
</p>

<p>
And here is how you would want it to look: Picture 2
</p>

<p>
Now I am not going to tell you how to add files and where to put them, I will just show you how to properly implement header and source files and how to avoid collisions and also how to stop writing those damn "xfz.h" files.
</p>

<p>
First things first.
What's the difference between headers and sources? Apart from the obvious name difference, header files are considered to be the <b>interface</b> part of the source code, that is, the place where we explain what the program does, but <b>not</b> how it does it. The source (cpp) files are the <b>implementation</b> part, this is where we explain <b>how</b> we implement the interface. Keeping them separate allows us to keep a clean directory and structure and to separate our logic from our implementation.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgae16eab">
<h3 id="orgae16eab">How to work with header?</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">iostream</span><span style="color: #99d1ce;">&gt;</span> <span style="color: #245361;">//</span><span style="color: #245361;">header we always include</span>
<span class="linenr"> 1: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"awesomeclass1.h"</span>
<span class="linenr"> 2: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"awesomeclass2.h"</span>
<span class="linenr"> 3: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"awesomeclass3.h"</span> <span style="color: #245361;">// </span><span style="color: #245361;">our own class headers</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span><span style="color: #99d1ce;">()</span>
<span class="linenr"> 6: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 7: </span>    <span style="color: #d26937;">awesomeclass1</span> <span style="color: #599cab;">ac</span>;
<span class="linenr"> 8: </span>    <span style="color: #d26937;">awesomeclass2</span> <span style="color: #599cab;">ac2</span>;
<span class="linenr"> 9: </span>    <span style="color: #d26937;">awesomeclass3</span> <span style="color: #599cab;">ac3</span>;
<span class="linenr">10: </span>
<span class="linenr">11: </span>    ac.do_something<span style="color: #33859e;">(</span>ac2<span style="color: #33859e;">)</span>;
<span class="linenr">12: </span>
<span class="linenr">13: </span>    ac3 = ac;
<span class="linenr">14: </span>
<span class="linenr">15: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr">16: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
So what are header files and what do they do?
</p>

<p>
Header files, usually ending with the <code>*.h</code> file extension (can be also <code>*.hxx</code>, <code>*.hpp</code>, or nothing at all), are code files that are <b><b>included</b></b> in our source files. We can look at header files as code that only serves as the interface to our classes. That is, it holds a declaration which we later on implement and/or include in our source files. Although we will talk about header files and how we <code>#include</code> them later on, what we can say now is that for every header file that is included, the contents of that file are put in the place of the <code>#include</code> keyword. What we can expect header files to do is to hold <b>declarations</b> inside of them. They just tell us what we are going to implement, but not <b>how</b> we are going to implement it (that's the job of the source files).
</p>

<p>
<b><b>NOTE:</b></b> that for the <code>iostream</code> we used angle brackets and for our classes we used quotes. This just means that the header file <b>iostream</b> comes with the compiler and that the linker should look in the system directories for the definition. The quotes indicate that we are providing the header file and that the linker should look at the build directory.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org6f49374">
<h3 id="org6f49374">Header guards</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">x.h</span>
<span class="linenr"> 1: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">x</span> <span style="color: #99d1ce;">{</span> . . . <span style="color: #99d1ce;">}</span>;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">a.h</span>
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">a</span> <span style="color: #99d1ce;">{</span> <span style="color: #d26937;">X</span> <span style="color: #599cab;">x</span> . . . <span style="color: #99d1ce;">}</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #245361;">// </span><span style="color: #245361;">b.h</span>
<span class="linenr"> 7: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">b</span> <span style="color: #99d1ce;">{</span> <span style="color: #d26937;">X</span> <span style="color: #599cab;">x</span> . . . <span style="color: #99d1ce;">}</span>;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #245361;">// </span><span style="color: #245361;">source.cpp</span>
<span class="linenr">10: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"a.h"</span> <span style="color: #245361;">// </span><span style="color: #245361;">include x.h for the first time</span>
<span class="linenr">11: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"b.h"</span> <span style="color: #245361;">// </span><span style="color: #245361;">error! include x.h again!</span>
</pre>
</div>

</section>
</section>
<section>
<section id="slide-orge1c80fd">
<h3 id="orge1c80fd"></h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #245361;">// </span><span style="color: #245361;">x.h</span>
<span class="linenr">1: </span><span style="color: #c23127;">#if</span><span style="color: #c23127;">n</span><span style="color: #c23127;">def</span> __X_H_INCLUDED__
<span class="linenr">2: </span><span style="color: #c23127;">#define</span> <span style="color: #599cab;">__X_H_INCLUDED__</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">x</span> <span style="color: #99d1ce;">{</span> . . . <span style="color: #99d1ce;">}</span>;
<span class="linenr">5: </span>
<span class="linenr">6: </span><span style="color: #c23127;">#endif</span>
</pre>
</div>

<aside class="notes">
<p>
Because we are going to be using a lot of headers in our program, we would need to include all of them. But because these files are actually copied when we <b>include</b> them, we would have several problems. One would be the code duplication. Another one will be the multiple declarations of classes and functions. To overcome this problem we would need to <b>guard</b> our header files in order not to use them more than once in our program. That is why we use the directives <code>#ifndef</code>, <code>#define</code>, and <code>#endif</code>. When we wrap our header file around with these directives, we ensure that the preprocessor will not copy a single file more than once into the source file.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org77453c9">
<h3 id="org77453c9">Declarations vs Definitions</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #245361;">// </span><span style="color: #245361;">declarations</span>
<span class="linenr"> 1: </span><span style="color: #195466; font-weight: bold;">extern</span> <span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>;
<span class="linenr"> 2: </span><span style="color: #195466; font-weight: bold;">extern</span> <span style="color: #d26937;">char</span> <span style="color: #599cab;">b</span>;
<span class="linenr"> 3: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">foo</span>; <span style="color: #245361;">// </span><span style="color: #245361;">extern not allowed for user types</span>
<span class="linenr"> 4: </span><span style="color: #d26937;">double</span> <span style="color: #599cab;">sum</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">double</span>, <span style="color: #d26937;">int</span><span style="color: #99d1ce;">)</span>;  <span style="color: #245361;">// </span><span style="color: #245361;">no need for extern</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span style="color: #245361;">// </span><span style="color: #245361;">definitions</span>
<span class="linenr"> 7: </span><span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>; <span style="color: #245361;">// </span><span style="color: #245361;">the implementation of a</span>
<span class="linenr"> 8: </span><span style="color: #d26937;">char</span> <span style="color: #599cab;">c</span>; <span style="color: #245361;">// </span><span style="color: #245361;">the implementation of c</span>
<span class="linenr"> 9: </span><span style="color: #d26937;">double</span> <span style="color: #599cab;">div</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">double</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span><span style="color: #99d1ce;">)</span> <span style="color: #99d1ce;">{</span> <span style="color: #195466; font-weight: bold;">return</span> a / x; <span style="color: #99d1ce;">}</span>
<span class="linenr">10: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">foo</span> <span style="color: #99d1ce;">{</span> . . . <span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
I want to take some time now to revisit two old concepts before we continue - namely I want to talk about <b>declarations</b> and <b>definitions</b>. Here we will mention the role of the <b>compiler</b> and <b>linker</b> briefly, but we will cover them later on. Now a <b>declaration</b> introduces an identifier and its type, be that type of a variable, object, or a function. Basically we are saying to the compiler that there is something with this name and this type, but we are not specifying <b>how</b> this specific thing is implemented. This is what the <b>compiler</b> needs in order to make a reference to that declaration. We can imagine the situation where we have a function which we want to use in multiple files in our program, it's just a very useful function, but we don't want to provide the implementation of the function in every source file. That's why we just declare the function, the compiler sees the declaration, makes a reference to it without the need to know its implementation, and then when we build the final executable, the linker links every reference of the declared function to its implementation. If you remember from the C++ course, a function prototype is a declaration.
</p>

<p>
A <b>definition</b> in C++ is when we a define something in its complete form. This means that we need to both declare something and define it at the same time. We actually implement that specific identifier we have declared. When we write functions and give them a function body at the same time is a form of definition. When we write <code>int x;</code> we are both declaring and defining the variable <code>x</code>. This means that we are telling the compiler that there is a variable <code>x</code> of type <code>int</code> that is in the global scope in the current source file. It's important to note that giving this variable a value is not necessary in order to define it. But in the examples we have this specific keyword <code>extern</code> that is associated with declarations. What <code>extern</code> does is that it marks the variable and tells the compiler that this is only a definition and that a declaration will be found somewhere else. In general we use <code>extern</code> when we want to declare global variables in header files and <b>define</b> them in some source file.
</p>

<p>
We can <b>declare</b> something as much as we like in as many files as we want, but we can only <b>define</b> something only <b>once</b>. Often when we get errors telling us that something is undefined (this is at linker time), what that means is that we have something declared, but we have not defined its implementation anywhere and we get a <b>missing symbols error</b>. On the other hand when we have multiple definitions of the same thing, the linker is confused as to which specific definition we want and we get a <b>duplicate symbols error</b>.
</p>

<p>
Okay now let us go back to header files.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org19f9d31">
<h3 id="org19f9d31">When and how to use headers</h3>
<p>
<code>class A</code> ==&gt; (uses) ==&gt; <code>class B</code> 
</p>

<ul>
<li>do nothing if: A makes no references at all to B</li>
<li>do nothing if: The only reference to B is in a friend declaration</li>
<li>forward declare B if: A contains a B pointer or reference: <code>B* b</code>;</li>
<li>forward declare B if: one or more functions has a B <b>object/pointer/reference</b> as a parameter, or as a return type: <code>B MyFunction(B myb)</code>;</li>
<li><code>#include "b.h"</code> if: B is a parent class of A</li>
<li><code>#include "b.h"</code> if: A contains a B object: <code>B b</code>;</li>

</ul>

</section>
</section>
<section>
<section id="slide-org01807c2">
<h3 id="org01807c2"></h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #c23127;">#if</span><span style="color: #c23127;">n</span><span style="color: #c23127;">def</span> __X_H_INCLUDED__
<span class="linenr"> 1: </span><span style="color: #c23127;">#define</span> <span style="color: #599cab;">__X_H_INCLUDED__</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #245361;">// </span><span style="color: #245361;">Forward declare dependencies</span>
<span class="linenr"> 4: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">F</span>;
<span class="linenr"> 5: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">B</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #245361;">// </span><span style="color: #245361;">Include dependencies</span>
<span class="linenr"> 8: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">map</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 9: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"c.h"</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #245361;">// </span><span style="color: #245361;">Our current class</span>
<span class="linenr">12: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">myclass</span> : <span style="color: #195466; font-weight: bold;">public</span> <span style="color: #d26937;">c</span>
<span class="linenr">13: </span><span style="color: #99d1ce;">{</span>
<span class="linenr">14: </span><span style="color: #195466; font-weight: bold;">public</span>:
<span class="linenr">15: </span>  <span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">map</span><span style="color: #33859e;">&lt;</span><span style="color: #d26937;">int</span>, <span style="color: #d26937;">char</span><span style="color: #33859e;">&gt;</span> <span style="color: #599cab;">matrix</span>;  <span style="color: #245361;">// </span><span style="color: #245361;">a map object that is required by our class</span>
<span class="linenr">16: </span>  <span style="color: #d26937;">F</span>* <span style="color: #599cab;">f</span>;                        <span style="color: #245361;">// </span><span style="color: #245361;">F pointer, so forward declare F</span>
<span class="linenr">17: </span>  <span style="color: #d26937;">void</span> <span style="color: #599cab;">Func</span><span style="color: #33859e;">(</span><span style="color: #d26937;">B</span>&amp; <span style="color: #599cab;">b</span><span style="color: #33859e;">)</span>;             <span style="color: #245361;">// </span><span style="color: #245361;">B reference, so forward declare B</span>
<span class="linenr">18: </span>
<span class="linenr">19: </span>  <span style="color: #195466; font-weight: bold;">friend</span> <span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">MyFriend</span>;       <span style="color: #245361;">// </span><span style="color: #245361;">friend declaration is not a dependency</span>
<span class="linenr">20: </span>                               <span style="color: #245361;">// </span><span style="color: #245361;">don't do anything about MyFriend</span>
<span class="linenr">21: </span><span style="color: #99d1ce;">}</span>
<span class="linenr">22: </span><span style="color: #c23127;">#endif</span>
</pre>
</div>

<aside class="notes">
<p>
Since we will be writing a lot of classes, there will be a lot of dependencies. As an example, a derived class will always be dependent of its parent class, which means that we must be aware of the parent class at compile time, so we can use the derived class. There are two general forms of dependencies - one is, that there will be things that can be <b>forward declared</b>, and the other is, that things need to be <code>#include</code>-ed. Let's take an example with the following. Image we have class <code>A</code>, which uses class <code>B</code>. This makes A dependent on B. To decide if we need to <b>forward declare</b> or to include A depends on what the interaction between the two classes is.
</p>

<p>
Some explanation is required here. First of we are protecting our class with the header guards. Then we are forward declaring two classes <code>F</code> and <code>B</code>. This means that we are telling the compiler that there is a user type class called <b>F</b> and <b>B</b> and that the implementation of the classes are somewhere else. This allows us to access the methods and variables of <b>F</b> and <b>B</b> without needing to specify their implementation. Forward declarations can be useful, because they can reduce compilation time. If we just want to access and use one or two functions from a class, instead of including the whole class (and copying its contents to the current file) we can just forward declare it and save ourselves some time.
</p>

<p>
In general we want to remember this simple rule - prefer forward declarations to includes, in order to save compilation time and circular dependency issues. The benefits to these rules is that we are encapsulating the classes we use as much as possible, because the classes that use our classes don't need to know how they work. This means that if we restrict our use of includes and think about how the dependencies of the classes interact, we are writing encapsulated and decoupled code.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgf4f026d">
<h3 id="orgf4f026d">Circular Dependencies</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr">0: </span><span style="color: #245361;">// </span><span style="color: #245361;">b.h</span>
<span class="linenr">1: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"a.h"</span>
<span class="linenr">2: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">B</span> <span style="color: #99d1ce;">{</span> <span style="color: #d26937;">A</span>* <span style="color: #599cab;">a</span>; <span style="color: #99d1ce;">}</span>;
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #245361;">// </span><span style="color: #245361;">a.h</span>
<span class="linenr">5: </span><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">"b.h"</span>
<span class="linenr">6: </span><span style="color: #195466; font-weight: bold;">class</span> <span style="color: #d26937;">B</span> <span style="color: #99d1ce;">{</span> <span style="color: #d26937;">B</span>* <span style="color: #599cab;">b</span>; <span style="color: #99d1ce;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
I mentioned at some point about circular dependencies, but they are something that is very common when we are writing OOP code. In this example we see a circular dependency. If we were to just include both header files, we would be stuck in loop, trying to figure out which class to include first, giving us a compilation error. In order to overcome this (and keep in mind that there is nothing wrong with such circular dependencies) we can just forward declare one of the two classes and include the other so we can break from this cycle. Now before you ask "what about the situation where we have explicit object declarations instead of pointers to objects?", let's just say that such a situation is <b>impossible</b>. Not that you can't write such a program, but there is an inherit design flaw to such code, it's virtually impossible to make such a code work, and there is a clear flaw in logic if you find yourself in such a situation. The other question you might have is - well when should we use pointers to objects? This totally depends on your program. For instance, if we have a <code>class Car</code> and a <code>class Wheel</code>, it's logical for the <b>Car</b> to include the <b>Wheel</b> class, but the <b>Wheel</b> class only needs a pointer to the Car object (it doesn't need the whole Car).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org9f2d0d4">
<h2 id="org9f2d0d4">How does compilation work?</h2>
<p>
There are 3 steps of compiling C++ code:
</p>
<ul>
<li>Preprocessing</li>
<li>Compilation
<ul>
<li>Compilation</li>
<li>Assembly</li>

</ul></li>
<li>Linking</li>

</ul>

<aside class="notes">
<p>
When we are trying to run a piece of code (in our case C++), the computer goes through several steps before we see the output, or the errors. 
</p>

<p>
The first part is the so called <b><b>preprocessing</b></b> step, where the <b>preprocessor</b> handles the <code>preprocessor</code> <b>directives</b>. These are the <code>#include</code>, <code>#define</code>, <code>#if</code>, <code>#ifndef</code>, <code>#ifdef</code> keywords we put on the top of our files. At this stage, one file at a time, each of these <b>directives</b> are replaces with their respective pieces of code from other files (they are usually only declarations). That is why when we have multiple source files, we include only the header files, because they only show us the declarations and not the definitions (thus we minimize time in this step). So after the directives have been replaced with the respective file contents or snippets of files (depending in the <code>#if</code> <code>#ifndef</code> and <code>#ifdef</code> and the macro <code>#define</code> keywords) we get at the end "pure C++" code. The preprocessor also adds line numbers so that the further steps can identify where the inserted code came from. As an example, if we write <code>#include &lt;iostream&gt;</code> we actually just insert the contents from the <code>iostream</code> library on the top of our main source file (again we must remember that most of the time, we are just including declarations).
</p>

<p>
As a side note, this whole process is very similar for C code as well.
</p>

<p>
So at the end of all of this copying, we get a temporary file that is just C/C++ code. It's indicated by the <code>*.i</code> or <code>*.ii</code> file extension, meaning that this file is just C/C++ code and must not be preprocessed.
</p>

<p>
We must note that the preprocessor is agnostic to the C++ syntax, that is why for instance, in Visual Studio we have the <code>#pragma</code> directive that tries to do the <code>#ifndef</code> directive work, but that's just a lie. 
</p>

<p>
We have to be careful where and how we put our <b>includes</b>.
</p>

<p>
<b><b>Tip:</b></b> one of the things we want to do while writing C++ code is to minimize our reliance on the preprocessor. That is, if we are <code>#define</code>-ning macros as constants so that we can use them throughout our program, we might encounter strange errors, because these directives may be treated as not part of the language. As an example, if we write <code>#define A_RATIO 1.18</code> the preprocessor might skip the name and just include the double 1.18. Then if we get, or when we get, an error referring to 1.18, we might not know it's because it was a macro define lost from the preprocessor. Instead we can just use <code>const~s as such: ~const double ARatio = 1.18;</code> Now we know that the compiler will see this variable and we won't bang our head against the wall with unnecessary errors.
</p>

<p>
In order to get only the preprocessed file we can run the
<code>g++ -E hello-world.cpp -o hello-world.ii</code>
which will produce the <code>hello-world.ii</code> file and then we can look inside of it and find out what it includes.
</p>

<p>
After we have our "pure C++" code (ending with the <code>*.i/*.ii</code>) suffix, we are ready to move to the next step - <b>Compilation</b>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org8cfb89f">
<h3 id="org8cfb89f">Compilation</h3>
<ul>
<li>Step 1 - Compile</li>
<li>Step 2 - Assemble</li>

</ul>

<p>
To get the object file we can run
</p>

<div class="org-src-container">

<pre  class="src src-sh">g++ -c hello-world.ii
</pre>
</div>

<p>
or
</p>

<div class="org-src-container">

<pre  class="src src-sh">g++ -c hello-world.cpp
</pre>
</div>

<p>
and we can then look inside what an object file looks like with
</p>

<div class="org-src-container">

<pre  class="src src-sh">nm hello-world.o
</pre>
</div>

<p>
or
</p>

<div class="org-src-container">

<pre  class="src src-sh">objdump -t hello-world.o
</pre>
</div>

<aside class="notes">
<p>
The <b><b>compilation</b></b> step is another relatively simple phase, where the preprocessed pure C++ file is transformed into <b>assembly</b> code. From there the compiler invokes an underlying back-end (assembler tool-chain) and assembles the assembly code into <b>machine</b> code, thus producing an actual <b>binary file</b> (where there are different binary file formats such as: <code>EFL</code>, <code>a.out</code>, <code>COFF</code>, <code>SOM</code>). This is the so called <b>object file</b>, which contains the compiled code into binary form of the symbols defined in the input. This file is usually no directly executable. The object files also contain additional data in the form of sections, used for linking, debugging, symbolic cross-reference resolution, comments, re-allocations, program symbols, etc (sections can be <code>.text</code>, <code>.bss</code>, <code>.data</code>, <code>.reloc</code>, etc.). The object files contain the metadata that hold the memory locations (addressed) of the variables and functions (called symbols) into an associative data structure called a <b>symbolic table</b>. Note that these addresses might not be the final addresses of the symbol in the final executable. The things that might be interesting to us is the symbol table. This is a data structure in the object file that's basically a name and an index. It maps different items in the object file to names that the linker can understand. If you call a function from your code, the compiler doesn't put the final address of the routine in the object file. Instead, it puts a placeholder value into the code and adds a note that tells the linker to look up the reference in the various symbol tables from all the object files it's processing and stick the final location there.
</p>

<p>
One big advantage to this is that the <b>compiler</b> can stop the compilation at this phase. Because you won't need to re-compile every file, but only those that <b>have been</b> changed, you can specify which files to compile and save time. <b><b>IDEs</b></b> and some other tools can do this automatically and check the timestamps of the files and only compile those source codes which have been modified. On the compilation step we get the normal compiler errors, such as <b>syntax errors</b>, <b>failed function overload errors</b>, etc.
</p>

<p>
Once we have the object file we can transform it into special <b>executables</b>, <b>shared</b>, or <b>dynamic</b> libraries. Here the <b>linker</b> comes into play.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org4968f50">
<h3 id="org4968f50">Linking</h3>
<p>
The <b><b>linker</b></b> just links all of the object files into one executable file.
</p>


<div class="figure">
<p><img src="./pics/objfilebeforelinking.png" alt="objfilebeforelinking.png" height="38%," width="38%" />
</p>
</div>

<aside class="notes">
<p>
The <b><b>linker</b></b> just links all of the object files into one executable file. The just of it is that the linker <b>links</b> object files by resolving undefined definitions of functions in the object files. That is, it goes through the object files and for every undefined function it tries to replace the reference of the undefined symbol with the correct address in another object file or in the standard library. The whole linking process is somewhat tedious and difficult to follow as it involves moving memory locations and relocation of symbols so we can skip this part, but for those who are interested, there are several links that explain exactly how the linker does its job.
</p>

<p>
One thing that we will encounter are the terms <b><b>dynamic</b></b> and <b><b>static</b></b> linking. <b>Static</b> linking is the process that links the program and the libraries together at normal link time. This means that the binding between the program and the library is known at link time. We are linking the program statically to a <b>shared archive</b> of objects (libraries). An example would be the standard <code>libc.a</code> library for <b><b>C</b></b>. A draw back to this approach is that the size of the executable is quite big, because everything must be bundled together. These static libraries are identified by the <code>*.a</code> file extension.
</p>

<p>
Although the deployment of such <b>executables</b> is much easier and allows us to have <b>0 dependencies</b>, the size of the binary can get too big and such static linkage does not allow us to reuse memory for executable code between different processes. What this means is that when we have multiple executables that rely on the same library, unless our OS is very smart, it's very likely that we are loading the same piece of code over and over, incrementally increasing the memory we are using for the same piece of code. Another problem is that if we are to change something and have to <b>re-build</b> and <b>run</b> the executable, we would spend a lot of time reallocating with the static library.
</p>

<p>
To overcome this problem we can use <b><b>dynamic</b></b> libraries. For the Windows users, these are the famous <code>*.dll</code> files. In essence, we get an <b>incomplete</b> binary, which is told <b>during</b> runtime, where to search for the code in the respective library. That is - the linkage of the functions from the shared objects and our program is done during runtime right before the program starts. The linker just mentions to the executable that there is a function from a shared object used at this particular place and notes it in the binary, and then carries on. The symbols of the shared objects (the ones in the libraries we are using) are only verified and validated that they exist, but are not combined into the final executable binary. Thus we get several great advantages to using dynamic linking and libraries:
</p>
<ul>
<li>Portable executables with smaller size.</li>
<li>Standard libraries can be updated and re-patched without the need of re-linkage of every program.</li>
<li>We can run multiple processes that use the same shared libraries without the need of copying the same code, thus saving large amounts of memory space.</li>

</ul>

<p>
This is the last step before we can take the <code>.exe</code> file, load it into memory and run it. At the linking stage we get different errors, such as <b>multiple function definitions</b>, or <b>undefined functions</b>, <b>missing references</b>, etc.
</p>

<p>
<b><b>Loading and running</b></b> - Now that we have a ready executable file we just have to <b>load</b> it into memory and run it. The <b><b>loader</b></b> is a general part of the OS and it operates in several steps. The general idea is this - first we validate memory and access privileges to the exe. The OS reads the header of our binary, checks if we have enough space to run the program, checks what kind of access permissions we have, checks the ability to run the instructions, makes sure that this is a valid executable image, and then goes through several steps of loading. To be exact - it allocates primary memory to run the file, copies the address spaces from secondary to primary memory, copies the multiple sections of the executable to the primary memory, copies the command line arguments on to the stack, refreshes the register and re-points the <b><b>esp</b></b> (the stack pointer) to the top of the cleared stack, and finally jumps to the start of the program and runs the <code>main()</code> method.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgf6a2c28">
<h3 id="orgf6a2c28">Conclusion</h3>
<ul>
<li>Understanding undefined behavior better</li>
<li>Understanding errors</li>
<li>Good grip on how data is represented in C++</li>

</ul>

<aside class="notes">
<p>
<b><b>Conclusion</b></b> - we can see that this is somewhat of a long process, where a lot of steps take place. This is done, from one point of view, for easier implementation and reduction of complexity. Being able to control all of these functionalities allows us to create big programs, to compile them in an easy and fast manner, and to understand what kind of errors we are getting at what stage. With the powers of "conditional compilation" we are able to create pre-compiled libraries that need only linking, this is called a "separate compilation model". Knowing the difference between the compilation phase and the link phase can make it easier to hunt for bugs. Compiler errors are usually syntactic in nature &#x2013; a missing semicolon, an extra parenthesis. Linking errors usually have to do with missing or multiple definitions. If you get an error that a function or variable is defined multiple times from the linker, that's a good indication that the error is that two of your source code files have the same function or variable. 
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org9f1f8d6">
<h2 id="org9f1f8d6">Memory management</h2>
<p>
The memory layout can be divided into <b>five</b> sections:
</p>
<ul>
<li>text</li>
<li>data</li>
<li>bss</li>
<li>stack</li>
<li>heap / free store</li>

</ul>

<aside class="notes">
<p>
The different segments in memory are the <b>text</b>, <b>data</b>, <b>bss</b>, <b>stack</b>, and <b>heap</b>.
</p>

<p>
The text segment holds the executable instructions inside. The OS tries to make is so that if the same program is running on multiple instances, this part of the code is shared between the individual processes, instead of being copied multiple times.
</p>

<p>
The <b><b>data</b></b> segment is where the non zero initialized global and statically allocated variables are. Each running instance of the program has an individual segment holding this piece of data.
</p>

<p>
The <b><b>bss</b></b> segment (**B**lock **S**tarted by **S**ymbol) is where all of the zero initialized global and statically allocated variables are. Again, each running instance has an individual bss segment. While running the bss segment is stored in the data segment, but in the execution file it is stored in the bss section.
</p>

<p>
The <b><b>heap</b></b> is the dynamic part of the memory allocation (C uses <code>malloc()</code>, <code>calloc()</code>, and <code>realloc()</code>, while C++ has <code>new</code>). We should make a quick clarification here. You might encounter two different terms that are often used interchangeably - one is the <b>heap</b> and the other is the <b>free store</b>. The difference between them in terms of their functionality is none, but following the C++ standards we can see that the heap is never mentioned apart from being an <b>abstract data structure</b>. This is so, because the heap is allocated or freed via <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code>, while the free store is allocated or deleted with <code>new</code> and <code>delete</code>. Although <code>new</code> and <code>delete</code> might be implemented in terms of <code>malloc()</code> and <code>free()</code>, these are not the same memory locations and they cannot be used <b><b>safely</b></b> interchangeably. For the sake of simplicity, we will continue referring to them under the <b>heap</b> term, but note that C++ does not used the heap the way C uses it.
</p>

<p>
Everything in this part of the memory is anonymous and needs a pointer to gain access to it. When we allocate new memory the process address space grows upwards. This means that as new items are added, the addresses of those items are numerically greater than the addresses of the previous ones. To free up memory from the heap we use <code>free()</code> for C and <code>delete</code> for C++, thus leaving holes in the memory. This means that when you are allocating objects to the heap and then deleting them, because of their different size, you might get into the situation where some deleted object free up space between objects that are still on the heap. Thus physically leaving free space that cannot be used by larger objects. This is the idea of leaving holes. 
</p>

<p>
We can picture it as if we have a blank wall and then start arranging pictures on it. If we are not careful with our picture arrangement we might get most of the pictures on the wall, but at some point we might get small free spaces that are just blank wall. Thus we technically do have space for more pictures, but this space is fragmented and unusable for bigger pictures (presuming that we cannot chop up our pictures into pieces). This is the same with the memory allocation and de-allocation on the heap. On our machines, where we have virtual memory, we don't really experience this problem, because it is important for the virtual memory to have the object into one continuous block. We can experience this problem of memory fragmentation when we start getting allocation errors (such as <code>malloc()</code> returning <code>null</code>, or when we cannot free up memory properly, or when our program takes too long to reallocate memory.
</p>

<p>
To overcome this problem we might use some tactical position of object creation to avoid such problems. We can allocate objects from different areas according to their size and/or their expected lifetime. So if you're going to create a lot of objects and destroy them all together later, allocate them from a memory pool. Any other allocations you do in between them won't be from the pool, hence won't be located in between them in memory, so memory will not be fragmented as a result (Using a good algorithm for allocating memory, we can, instead of allocating memory for a lot of small objects, pre-allocate memory for a contiguous array of those smaller objects. Sometimes being a little wasteful when allocating memory can go along way for performance and may save you the trouble of having to deal with memory fragmentation).
</p>

<p>
In general we don't have to worry that much for this sort of fragmentation unless our program is long running and has a wide mixture of long lived/short lived, big/small objects that are constantly created and destroyed. But even then the automatic memory allocation is on our side and helps us as much as it can. So we can start worrying about this only when we see clear sings of slow processes and blatant memory errors.
</p>

<p>
The great thing about C++ is that the STL handles these allocations very well and it's optimized so if we are relying on the STL (and we should), then we wouldn't have any problems.
</p>

<p>
The end of the heap is indicated by the <code>break</code> pointer. It is impossible to allocate more data beyond this range, but with system calls <code>brk()</code> and <code>sbrk()</code> we can move the break further up the memory and free up more space for our running program (keep in mind that such direct system calls are generally a bad practice and should be avoided).
</p>

<p>
The <b><b>stack</b></b> is the static part of the memory allocation in our program. Here local variables are allocated. These are all the variables that are declared inside a function body and are not set as <code>static</code>. Following the stack data structure, local variables, function parameters, addresses, etc. are popped up or pushed down for quick and easy access.
</p>

<p>
When a function is called a stack frame (a procedure activation record) is pushed on top of the stack. A stack frame holds information for the address from where the function was called, where to jump back when the function ends (return address), local variables, function parameters, and any other information needed by the function. When the function returns, the stack frame is popped from the top of the stack. The stack grows downwards, meaning that the address of each stack frame is numerically smaller than the previous one.
</p>

<p>
So when a program is running, the data, bss, and heap segments are aligned into one continuous memory block (area) called a data segment. The stack is kept separate from them. In theory it is possible for the stack and heap to collide and grow inside each other, but the OS prevents such collisions.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgd2c80c7">
<h3 id="orgd2c80c7">Memory space in C++</h3>
<p>
This is all the space and data the program needs in order to run properly.
</p>

<p>
\[ address space = memory space \]
</p>


<div class="figure">
<p><img src="./pics/memlayout.png" alt="memlayout.png" height="38%," width="38%" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-org9e0041f">
<h3 id="org9e0041f">How to handle memory in C++</h3>
<ul>
<li>Pointers</li>
<li>Pass by value</li>
<li>Pass by reference</li>

</ul>

<aside class="notes">
<p>
Before we start actually looking at any code. . . why do we use pointers? Well we know that it <b><b>saves</b></b> time but how exactly? We saw that in order to get data from the free storage we must use pointers, but is that the only benefit? Much to our <b>"surprise"</b>, there are a lot of awesome advantages to using pointers, and with a little practice we can enjoy them.
</p>

<p>
So first things first, why do we save time and space with them? Because C++, by default, <b>copies</b> every parameter we pass in to a function, which means that if we have large object (or large variables for that matter) which we must pass to a lot of functions, that object, and all of its data, will be copied to the stack frame of that function and then, when we leave the function, the copied data will be discarded. This means that when we are passing by value, a copy of <b><b>every</b></b> parameter is made and we make changes to the <b>copy</b>, <b>not</b> on the originally passed data. Not only are we doing unnecessary copy work, but we might also fall into the trap that we are transforming the object and changing its state, but in reality, we are doing only work with the copied object. Here is a practical example - two years ago, I wrote a C++ program that passed objects like crazy in order to render an image at the end. The program, depending on the level quality it rendered, took between 30 secs to 30 minutes for the highest quality. The same program, when it used the power of passing by reference, took from 10 secs to 5 minutes max. Ain't optimization beautiful.
</p>

<p>
Lets get back to the world of C++ and go over how we pass arguments to functions. In particular we will try to review the difference between passing by value and passing by reference and dealing with pointers.
</p>

<p>
Lets take this example now:
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org229cbbc">
<h3 id="org229cbbc">Pass by reference in C</h3>
<div class="org-src-container">

<pre  class="src src-C"><span class="linenr"> 0: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">stdio.h</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">f</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">int</span> *<span style="color: #599cab;">j</span><span style="color: #99d1ce;">)</span> 
<span class="linenr"> 3: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 4: </span>    <span style="color: #33859e;">(</span>*j<span style="color: #33859e;">)</span>++;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span><span style="color: #99d1ce;">()</span> 
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = <span style="color: #33859e; font-weight: bold;">20</span>;
<span class="linenr">10: </span>    <span style="color: #d26937;">int</span> *<span style="color: #599cab;">p</span> = &amp;i;
<span class="linenr">11: </span>    f<span style="color: #33859e;">(</span>p<span style="color: #33859e;">)</span>; <span style="color: #245361;">// </span><span style="color: #245361;">or f(&amp;i); will yield the same result</span>
<span class="linenr">12: </span>    printf<span style="color: #33859e;">(</span><span style="color: #2aa889;">"i = %d\n"</span>, i<span style="color: #33859e;">)</span>;
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr">15: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
With this example we can see how, although we are passing a pointer, we are still employing the pass-by-value idiom. This is normal for all C code (this will also work for C++ as well). This type of passing is called "C-style pass-by-value imitation". The code does what we expect, because after the function call we <b>de-reference</b> the pointer which we have passed to the function in order to get the integer it was pointing to. <b>De-referencing</b> means that we are evaluating what the pointer points to. In our case, when the function call finishes and we de-reference the pointer, we are just looking at the value to which the pointer is pointing. So here is what's happening, when we pass a pointer to the function, that pointer gets copied, and that copy is used in the function. At this point we have two pointers, which are pointing to the same value. When we go through the function body, the <b>copied</b> pointer <b>changes</b> the value it points to (in our case it changes the <code>i</code> variable declared in <code>main</code>). In other words, the copy of the pointer in the function body changes the same <code>int</code> we have in memory, regardless of the fact that a copy pointer is doing that (the integer is still changed because we are pointing to that integer). This is how we "imitate" pass-by-reference, the old way.
</p>

<p>
Let's look at the same example, but in C++ code.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgef4e04a">
<h3 id="orgef4e04a">Pass by reference in C++</h3>
<div class="org-src-container">

<pre  class="src src-C++"><span class="linenr"> 0: </span><span style="color: #c23127;">#include</span> <span style="color: #99d1ce;">&lt;</span><span style="color: #2aa889;">iostream</span><span style="color: #99d1ce;">&gt;</span>
<span class="linenr"> 1: </span>
<span class="linenr"> 2: </span><span style="color: #d26937;">void</span> <span style="color: #599cab;">f</span><span style="color: #99d1ce;">(</span><span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">a</span><span style="color: #99d1ce;">)</span>
<span class="linenr"> 3: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 4: </span>     a += <span style="color: #33859e; font-weight: bold;">1</span>;
<span class="linenr"> 5: </span><span style="color: #99d1ce;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span><span style="color: #99d1ce;">()</span>
<span class="linenr"> 8: </span><span style="color: #99d1ce;">{</span>
<span class="linenr"> 9: </span>    <span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span> = <span style="color: #33859e; font-weight: bold;">5</span>;
<span class="linenr">10: </span>    f<span style="color: #33859e;">(</span>a<span style="color: #33859e;">)</span>;
<span class="linenr">11: </span>    <span style="color: #33859e; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa889;">"a = "</span> &lt;&lt; a &lt;&lt; <span style="color: #33859e; font-weight: bold;">std</span>::endl;
<span class="linenr">12: </span>
<span class="linenr">13: </span>    <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #33859e; font-weight: bold;">0</span>;
<span class="linenr">14: </span><span style="color: #99d1ce;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Doing the exact same thing, the difference is that we have no pointer declared, because we don't need one, and we changed the sign of parameter we pass, from an <code>*</code> to an <code>&amp;</code>. Here C++ and it's awesome new feature allows us to actually pass a real reference to the function. This means that the function is working with the real data we have passed, and <b><b>not</b></b> with a copy of it. If we make changes to the variable inside the function, those changes will <b>stick</b> once we leave the function!
</p>

<p>
Hopefully this cleared some things about pointers, but the question now is: when should I pass by reference and when by value, and when I am passing by reference, which of the two ways should I employ? The general answer to this is - it depends on the code you are writing and the problem you are solving, but because this is too generic, here is some better advise - when writing C, imitate the pass by reference when you <b>want</b> the data to be changed, other wide, pass it by value. When writing C++, do the same, use the C++ style with real reference passing, and also, as a bonus rule, pass <b><b>objects</b></b> by reference (this minimizes the situation where you have to copy large amounts of data to functions that only read from the passed objects).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgb6618f7">
<h2 id="orgb6618f7">References</h2>
<div class="outline-text-2" id="text-orgb6618f7">
</div>
</section>
</section>
<section>
<section id="slide-org2b13e89">
<h3 id="org2b13e89"><b><b>Preprocessing, Compilation, and Linking</b></b></h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Object_file">https://en.wikipedia.org/wiki/Object_file</a></li>
<li><a href="https://www.toptal.com/c-plus-plus/c-plus-plus-understanding-compilation">https://www.toptal.com/c-plus-plus/c-plus-plus-understanding-compilation</a></li>
<li><a href="http://www.cplusplus.com/doc/tutorial/preprocessor/">http://www.cplusplus.com/doc/tutorial/preprocessor/</a></li>
<li><a href="https://stackoverflow.com/questions/6264249/how-does-the-compilation-linking-process-work">https://stackoverflow.com/questions/6264249/how-does-the-compilation-linking-process-work</a></li>
<li><a href="https://stackoverflow.com/questions/12122446/how-does-c-linking-work-in-practice/30507725#30507725">https://stackoverflow.com/questions/12122446/how-does-c-linking-work-in-practice/30507725#30507725</a></li>
<li><a href="http://www.iecc.com/linker/">http://www.iecc.com/linker/</a></li>
<li><a href="https://www.airs.com/blog/archives/38">https://www.airs.com/blog/archives/38</a></li>
<li><a href="http://www.cirosantilli.com/elf-hello-world/">http://www.cirosantilli.com/elf-hello-world/</a></li>
<li><a href="https://stackoverflow.com/questions/3322911/what-do-linkers-do/33690144#33690144">https://stackoverflow.com/questions/3322911/what-do-linkers-do/33690144#33690144</a></li>
<li><a href="http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html">http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html</a></li>
<li><a href="https://www.cprogramming.com/compilingandlinking.html">https://www.cprogramming.com/compilingandlinking.html</a></li>
<li><a href="http://www.cplusplus.com/articles/2v07M4Gy/">http://www.cplusplus.com/articles/2v07M4Gy/</a></li>
<li><a href="http://www.tenouk.com/ModuleW.html">http://www.tenouk.com/ModuleW.html</a></li>
<li><a href="http://www.tenouk.com/Bufferoverflowc/Bufferoverflow1.html">http://www.tenouk.com/Bufferoverflowc/Bufferoverflow1.html</a></li>
<li><a href="http://nickdesaulniers.github.io/blog/2016/08/13/object-files-and-symbols/">http://nickdesaulniers.github.io/blog/2016/08/13/object-files-and-symbols/</a></li>
<li><a href="http://nickdesaulniers.github.io/blog/2016/11/20/static-and-dynamic-libraries/">http://nickdesaulniers.github.io/blog/2016/11/20/static-and-dynamic-libraries/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Object_file">https://en.wikipedia.org/wiki/Object_file</a></li>
<li><a href="https://stackoverflow.com/questions/3880924/how-to-view-symbols-in-object-files">https://stackoverflow.com/questions/3880924/how-to-view-symbols-in-object-files</a></li>
<li><a href="https://stackoverflow.com/questions/69112/what-is-a-symbol-table">https://stackoverflow.com/questions/69112/what-is-a-symbol-table</a></li>
<li><a href="https://codeyarns.com/2014/08/07/how-to-list-symbols-in-object-file/">https://codeyarns.com/2014/08/07/how-to-list-symbols-in-object-file/</a></li>

</ul>

</section>
</section>
<section>
<section id="slide-org49869f4">
<h3 id="org49869f4"><b><b>Memory management</b></b></h3>
<ul>
<li><a href="https://stackoverflow.com/questions/3770457/what-is-memory-fragmentation">https://stackoverflow.com/questions/3770457/what-is-memory-fragmentation</a></li>
<li><a href="http://www.tenouk.com/ModuleW.html">http://www.tenouk.com/ModuleW.html</a></li>
<li><a href="https://stackoverflow.com/questions/2229498/passing-by-reference-in-c">https://stackoverflow.com/questions/2229498/passing-by-reference-in-c</a></li>
<li><a href="https://stackoverflow.com/questions/13654138/what-exactly-is-the-difference-between-pass-by-reference-in-c-and-in-c">https://stackoverflow.com/questions/13654138/what-exactly-is-the-difference-between-pass-by-reference-in-c-and-in-c</a></li>
<li><a href="http://www.guideforschool.com/625348-memory-address-calculation-in-an-array/">http://www.guideforschool.com/625348-memory-address-calculation-in-an-array/</a></li>
<li><a href="http://www.gotw.ca/gotw/009.htm">http://www.gotw.ca/gotw/009.htm</a></li>
<li><a href="http://www-cs-students.stanford.edu/~sjac/c-to-cpp-info/references">http://www-cs-students.stanford.edu/~sjac/c-to-cpp-info/references</a></li>

</ul>

</section>
</section>
<section>
<section id="slide-org7edefe9">
<h3 id="org7edefe9"><b><b>File Structure</b></b></h3>
<ul>
<li><a href="http://www.cplusplus.com/forum/articles/10627/">http://www.cplusplus.com/forum/articles/10627/</a></li>
<li><a href="http://www.learncpp.com/cpp-tutorial/19-header-files/">http://www.learncpp.com/cpp-tutorial/19-header-files/</a></li>
<li><a href="https://stackoverflow.com/questions/333889/why-have-header-files-and-cpp-files">https://stackoverflow.com/questions/333889/why-have-header-files-and-cpp-files</a></li>
<li><a href="https://www.cprogramming.com/declare_vs_define.html">https://www.cprogramming.com/declare_vs_define.html</a></li>
<li><a href="https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration">https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration</a></li>
<li><a href="http://aszt.inf.elte.hu/~gsd/halado_cpp/ch09s03.html">http://aszt.inf.elte.hu/~gsd/halado_cpp/ch09s03.html</a></li>
<li><a href="https://stackoverflow.com/questions/4757565/what-are-forward-declarations-in-c">https://stackoverflow.com/questions/4757565/what-are-forward-declarations-in-c</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/mdn/reveal.js-3.6.0/lib/js/head.min.js"></script>
<script src="file:///home/mdn/reveal.js-3.6.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1920,
height: 1080,
margin: 0.20,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'file:///home/mdn/reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'file:///home/mdn/reveal.js-3.6.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
